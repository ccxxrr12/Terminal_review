## 第2章 数据表示和寻址

### 题目2.8（来自图8，有手写解答和标记）
**题目内容**：进行十六进制数据的加减运算，并说明是否有进位或借位：
(1) 1234H + 7802H
(2) F034H + 5AB0H
(3) C051H - 1234H
(4) 9876H - ABCD H（注：图片中“ABGDH”可能为笔误，应为“ABCDH”）

**答案**：
(1) 1234H + 7802H = 8A36H，**无进位**（CF=0）。
(2) F034H + 5AB0H = 14AE4H，**有进位**（CF=1），因为结果超过16位。
(3) C051H - 1234H = AE1DH，**无借位**（CF=0）。
(4) 9876H - ABCD H = ECA9H，**有借位**（CF=1），因为被减数小于减数。

**解析**：
- 十六进制加减运算需按位计算，注意进位和借位。
- 对于加法：如果最高位有进位，CF=1；否则CF=0。计算时，从低位开始，逐位相加，满16进1。
- 对于减法：如果被减数小于减数，需要借位，CF=1；否则CF=0。计算时，从低位开始，逐位相减，不够时向高位借1当16。
- 验证：
  - (1) 1234H + 7802H：4+2=6, 3+0=3, 2+8=10=A（无进位）, 1+7=8，结果8A36H，无进位。
  - (2) F034H + 5AB0H：4+0=4, 3+B=14=E（进位1）, 0+A+1=11=B（进位1）, F+5+1=15=F（进位1），结果14AE4H（17位），CF=1。
  - (3) C051H - 1234H：1-4需借位，11-4=7, 5-3-1=1, 0-2需借位，16+0-2=14=E, C-1-1=A，结果AE1DH，无借位。
  - (4) 9876H - ABCD H：6-D需借位，16+6-D=9, 7-C-1需借位，16+7-C-1=10=A, 8-B-1需借位，16+8-B-1=12=C, 9-A-1= -2（借位），结果ECA9H，CF=1。

**知识点讲解**：
- **进位标志（CF）**：在无符号数运算中，表示最高位的进位（加法）或借位（减法）。
- **十六进制运算**：每位对应4位二进制，加法满16进1，减法不够借1当16。
- **无符号数运算**：CF用于无符号数溢出判断，OF用于有符号数溢出判断（本题未涉及OF）。

**做题步骤**：
1. 将十六进制数转换为二进制或直接计算。
2. 逐位进行加减法，记录中间结果和进位/借位。
3. 检查最高位是否有进位或借位，设置CF。
4. 将结果转换为十六进制，并验证。

---

### 题目2.9（来自图8，有手写解答和标记）
**题目内容**：数码0~9、大写字母A~Z、小写字母a~z对应的ASCII码分别是多少？ASCII码0DH和0AH分别对应什么字符？

**答案**：
- 数码0~9：ASCII码为30H~39H。
- 大写字母A~Z：ASCII码为41H~5AH。
- 小写字母a~z：ASCII码为61H~7AH。
- ASCII码0DH：回车符（CR）。
- ASCII码0AH：换行符（LF）。

**解析**：
- ASCII码是7位编码，常用十六进制表示。
- 数字字符'0'~'9'对应30H~39H（十进制48~57），递增。
- 大写字母'A'~'Z'对应41H~5AH（十进制65~90），递增。
- 小写字母'a'~'z'对应61H~7AH（十进制97~122），递增。
- 控制字符0DH和0AH常用于文本换行：CR将光标移到行首，LF将光标移到下一行。

**知识点讲解**：
- **ASCII码表**：标准字符编码，包括可打印字符和控制字符。
- **字符规律**：数字、大写字母、小写字母的ASCII码连续，且小写字母比大写字母大20H。
- **控制字符**：非打印字符，用于设备控制，如回车、换行。

**做题步骤**：
1. 回忆ASCII码表，或参考标准编码表。
2. 注意数字和字母的编码规律。
3. 特殊控制字符需记忆常见值。

---

### 题目2.10（来自图8，有手写解答和标记）
**题目内容**：设置一个数据段，按照如下要求定义变量或符号常量：
(1) my1b为字符串变量：Personal Computer
(2) my2b为用十六进制数表示的字节变量：20
(3) my3b为用十六进制数表示的字节变量：20
(4) my4b为用二进制数表示的字节变量：20
(5) my5w为20个未赋值的字变量
(6) my6c为100的常量
(7) my7c表示字符串：Personal Computer

**答案**（汇编语言数据段定义示例）：
```asm
.data
my1b db 'Personal Computer',0   ; 字符串变量，以0结尾
my2b db 20h                    ; 十六进制字节变量，20h = 32
my3b db 20h                    ; 同上
my4b db 00010100b              ; 二进制字节变量，20的二进制为10100（8位需补零：00010100b）
my5w dw 20 dup(?)              ; 20个未赋值的字变量
my6c equ 100                   ; 常量100
my7c equ <'Personal Computer'> ; 字符串常量（或使用db定义）
```

**解析**：
- 变量定义使用伪指令：db（字节）、dw（字）、dd（双字）。
- 字符串需用引号括起，可加结束符0（C风格字符串）。
- 常量使用equ或=定义，不分配存储空间，编译时替换。
- 数值可用不同进制：十六进制加h，二进制加b，十进制默认。
- dup(?)用于分配未初始化空间。

**知识点讲解**：
- **数据段定义**：在.data节中定义变量和常量。
- **变量类型**：
  - db：定义字节变量，初始值可为数值或字符串。
  - dw：定义字变量（2字节）。
  - dup(?))：分配未初始化空间，?表示值未定。
- **常量定义**：equ用于定义符号常量，编译时直接替换值。
- **数值表示**：注意进制后缀，十六进制（h）、二进制（b）。

**做题步骤**：
1. 确定变量类型（字节、字等）。
2. 选择适当伪指令（db、dw等）。
3. 根据要求初始化值，注意进制表示。
4. 字符串需用引号，常量用equ。

---

### 题目2.11（来自图8，有手写解答和标记）
**题目内容**：定义常量NUM，其值为5；数据段中定义字数组变量DATALIST，它的头5个字单元中依次存放-10、2、5和4，最后1个单元初值不定。（注：图片中只列出了4个值，可能漏了一个，假设第5个值为0或其他）

**答案**：
```asm
NUM equ 5                       ; 定义常量NUM=5
.data
DATALIST dw -10, 2, 5, 4, ?    ; 字数组，前4个初始化，第5个未定
```

**解析**：
- 常量用equ定义，数组用dw定义多个值。
- 值之间用逗号分隔，?表示未初始化。
- 题目要求头5个字单元，但只给了4个值，因此第5个用?占位。或者，如果要求5个值，可假设第5个为0：`dw -10, 2, 5, 4, 0`。

**知识点讲解**：
- **数组定义**：使用dw后跟列表，如dw 1,2,3。
- **未初始化单元**：用?表示，编译时不赋初值，运行时值不确定。
- **负数表示**：汇编器中，负数直接写-10，编译为补码形式。

**做题步骤**：
1. 用equ定义常量。
2. 用dw定义数组，列出初始值。
3. 确保单元数量匹配，用?填充未初始化部分。

---

### 题目2.12（来自图8，有手写解答和标记）
**题目内容**：从低地址开始以字节为单位，用十六进制形式给出下列语句依次分配的数值：
`db 'ABC',10,10h,'EF',3 dup(-1,2,3 dup(4))`
`dw 10h,-5,3 dup(0)`

**答案**：
字节序列（十六进制）：
41H, 42H, 43H, 0AH, 10H, 45H, 46H, FFH, 02H, 04H, 04H, 04H, FFH, 02H, 04H, 04H, 04H, FFH, 02H, 04H, 04H, 04H
字序列（十六进制，小端序）：10H, 00H, FBH, FFH, 00H, 00H, 00H, 00H, 00H, 00H

**解析**：
- db部分：
  - 'A'=41H, 'B'=42H, 'C'=43H。
  - 10=0AH（十进制10）。
  - 10h=10H（十六进制10）。
  - 'E'=45H, 'F'=46H。
  - 3 dup(-1,2,3 dup(4))：重复3次，每次为-1（FFH）、2（02H）、3个4（04H,04H,04H）。
  - 所以序列：FFH,02H,04H,04H,04H, FFH,02H,04H,04H,04H, FFH,02H,04H,04H,04H。
- dw部分（字为2字节，小端序）：
  - 10h=0010H，存储为10H,00H。
  - -5=FFFBH（16位补码），存储为FBH,FFH。
  - 3 dup(0)=0000H，存储为00H,00H，重复3次，所以00H,00H,00H,00H,00H,00H。
- 完整字节序列：db部分后接dw部分。

**知识点讲解**：
- **dup操作符**：用于重复定义，如3 dup(1)等价于1,1,1。
- **小端序**：多字节数据中，低字节存放在低地址。
- **负数存储**：用补码表示，-5的16位补码为FFFBH。
- **字符编码**：'A'~'Z'对应41H~5AH。

**做题步骤**：
1. 处理db部分：依次计算每个字节值，展开dup。
2. 处理dw部分：将每个字转换为小端序字节序列。
3. 合并所有字节，按地址从低到高列出。

---

### 题目2.13（来自图8，有手写解答和标记）
**题目内容**：设在某个程序中有如下片段，请写出每条传送指令执行后寄存器EAX的内容。
数据段定义：
```asm
varw dw 1234h,5678h
varb db 3,4
count1 equ $ - varw
vard dd 12345678h
count2 equ $ - vard
buff db 10 dup(0)
mess db 'hello'
count3 equ $ - buff
```
代码段（传送指令序列，图片描述不完整，假设常见指令）：
```asm
mov eax, varw      ; EAX = 偏移地址 of varw
mov eax, [varw]    ; EAX = 1234h（低16位），高16位为0
mov eax, varb      ; EAX = 偏移地址 of varb
mov eax, [vard]    ; EAX = 12345678h
mov eax, count1    ; EAX = 值 of count1（$ - varw的计算结果）
; 其他指令可能包括mov eax, count2等
```

**答案**（基于常见题目补充）：
- `mov eax, varw`：EAX = varw的偏移地址（例如，如果varw在地址00400000H，EAX=00400000H）。
- `mov eax, [varw]`：EAX = 00001234H（小端序，从varw地址取2字节1234H，零扩展为32位）。
- `mov eax, varb`：EAX = varb的偏移地址。
- `mov eax, [vard]`：EAX = 12345678H（从vard地址取4字节）。
- `mov eax, count1`：EAX = 4（因为varw为2字，4字节，count1 = 4）。
- `mov eax, count2`：EAX = 4（vard为1双字，4字节，count2 = 4）。
- `mov eax, count3`：EAX = 10（buff为10字节，count3 = 10）。

**解析**：
- 直接使用变量名（如varw）表示偏移地址。
- 使用[varw]表示取内存内容。
- 字变量varw占2字节，取值时零扩展为32位。
- equ常量在编译时计算，$表示当前地址，$ - varw计算变量大小。

**知识点讲解**：
- **寻址方式**：
  - 直接寻址：mov eax, [varw] 取内存值。
  - 立即数寻址：mov eax, offset varw 取地址（但这里varw本身表示地址）。
- **数据大小**：dw定义字（2字节），dd定义双字（4字节）。
- **小端序**：低字节在低地址。
- **地址计算**：$表示当前地址，equ常量是编译时值。

**做题步骤**：
1. 确定变量类型和内存布局。
2. 区分变量名（地址）和[变量名]（值）。
3. 根据指令类型计算EAX值。
4. 注意小端序和零扩展。

---

### 题目2.14（来自图8，有手写解答和标记）
**题目内容**：按照如下输出格式，在屏幕上显示ASCII表：
```
| 0 1 2 3 4 5 6 7 8 9 A B C D E F
+--------------------------------
0 |  (显示可打印字符)
1 |
...
7 |
```

**答案**（汇编代码示例）：
```asm
.data
header db '| 0 1 2 3 4 5 6 7 8 9 A B C D E F', 0Dh, 0Ah, '+--------------------------------', 0Dh, 0Ah, 0
table db 128 dup(?)   ; 存储ASCII字符值
.code
; 初始化table，填充ASCII值（0-127）
mov ecx, 128
mov esi, 0
init_loop:
    mov table[esi], sil   ; sil是ESI的低8位，即0-127
    inc esi
    loop init_loop

; 显示表头
mov eax, offset header
call dispmsg

; 显示表格内容
mov ecx, 8        ; 8行（0-7）
mov ebx, 0        ; 行号起始值
row_loop:
    ; 显示行号
    mov al, bl    ; 行号
    add al, 30h   ; 转换为数字字符
    call dispchar
    mov al, ' '   ; 空格
    call dispchar
    mov al, '|'   ; 竖线
    call dispchar
    mov al, ' '
    call dispchar

    ; 显示16列字符
    mov edx, 0    ; 列号
    col_loop:
        mov eax, ebx   ; 行号
        shl eax, 4     ; 行号*16
        add eax, edx   ; 行号*16 + 列号
        mov al, table[eax]  ; 获取ASCII值
        cmp al, 20h    ; 检查是否可打印（>=20H）
        jb non_printable
        cmp al, 7Eh
        ja non_printable
        jmp display
    non_printable:
        mov al, '.'    ; 不可打印字符显示点
    display:
        call dispchar
        mov al, ' '
        call dispchar
        inc edx
        cmp edx, 16
        jb col_loop

    ; 换行
    mov al, 0Dh
    call dispchar
    mov al, 0Ah
    call dispchar
    inc ebx
    loop row_loop
```

**解析**：
- ASCII表共128字符，但通常显示可打印部分（20H-7EH）。
- 格式：第一行为标题，之后每行显示16个字符。
- 行号由高4位决定，列号由低4位决定。
- 使用循环和输出函数实现。

**知识点讲解**：
- **ASCII表结构**：每行16字符，字符代码=行号*16 + 列号。
- **可打印字符**：20H-7EH，其余显示为点或其他符号。
- **显示函数**：需使用系统调用或库函数，如dispmsg显示字符串，dispchar显示字符。
- **循环控制**：用ECX和LOOP指令，或CMP和JCC。

**做题步骤**：
1. 定义表头字符串。
2. 初始化ASCII值数组。
3. 使用嵌套循环生成每行内容。
4. 检查字符是否可打印，替换不可打印字符。
5. 格式对齐。

---

### 题目2.15（来自图7，被红色笔迹批改，有打勾和星标）
**题目内容**：数据段有如下定义，IA-32处理器将以小端方式保存在主存：
`var dd 12345678h`
以字节为单位按地址从低到高的顺序，写出这个变量内容，并说明如下指令的执行结果：
```asm
mov eax, [var]   ; EAX = ?
mov bx, [var]    ; BX = ?
mov cx, [var+2]  ; CX = ?
mov dh, [var]    ; DH = ?
mov dh, [var+3]  ; DH = ?
```

**答案**：
- 变量var内容（小端序，低地址到高地址）：78H, 56H, 34H, 12H。
- 指令结果：
  - `mov eax, [var]`：EAX = 12345678H（取4字节）。
  - `mov bx, [var]`：BX = 5678H（取低2字节）。
  - `mov cx, [var+2]`：CX = 1234H（取地址var+2处的2字节，即高2字节）。
  - `mov dh, [var]`：DH = 78H（取低字节）。
  - `mov dh, [var+3]`：DH = 12H（取最高字节）。

**解析**：
- 小端序：低字节存低地址，var地址处为78H，var+1为56H，var+2为34H，var+3为12H。
- 指令根据操作数大小取内存值：
  - eax为32位，取4字节。
  - bx为16位，取2字节。
  - dh为8位，取1字节。
- 地址计算：[var+2]表示从var偏移2字节。

**知识点讲解**：
- **小端序**：多字节数据中，低字节存放在低地址。
- **内存访问**：指令如mov eax, [var]取4字节，mov bx, [var]取2字节。
- **寄存器大小**：EAX（32位）、BX（16位）、DH（8位）。
- **地址偏移**：[var+2]表示有效地址为var的地址加2。

**做题步骤**：
1. 将双字值12345678H分解为字节序列（小端序）。
2. 根据指令操作数大小确定取多少字节。
3. 从低地址开始取对应字节。

---

### 题目2.16（来自图7，被红色笔迹批改，有打勾）
**题目内容**：给出IA-32处理器32位寻址方式的组成公式，并说明各部分的作用。

**答案**：
IA-32处理器的32位寻址方式组成公式：
**有效地址 = 基址寄存器 + 变址寄存器 × 比例因子 + 位移量**
各部分作用：
- **基址寄存器**：任何32位通用寄存器（如EAX、EBX等），用于指向内存段的起始地址。
- **变址寄存器**：除ESP外的32位通用寄存器，用于索引数组或结构元素。
- **比例因子**：1、2、4或8，用于支持字节、字、双字或四字数组的索引。
- **位移量**：8位、16位或32位立即数，用于固定偏移。

**解析**：
- 寻址方式用于计算内存操作数的有效地址。
- 例如：[ebx + esi*4 + 10h]：ebx是基址，esi是变址，4是比例因子，10h是位移量。
- 这种灵活性支持数组、结构体和指针运算。

**知识点讲解**：
- **寻址模式**：IA-32支持多种寻址方式，如直接、间接、基址、变址等。
- **比例因子**：简化数组访问，如元素大小为4字节时，变址寄存器乘以4。
- **位移量**：可用于访问结构体字段或局部变量。

**做题步骤**：
1. 回忆寻址公式。
2. 解释每个组成部分的意义。
3. 举例说明。

---

### 题目2.17（来自图7，被红色笔迹批改，有打勾和星标）
**题目内容**：说明下列指令中源操作数的寻址方式。假设VARD是一个双字变量。
(1) mov edx,1234h
(2) mov edx,[vard]
(3) mov edx,ebx
(4) mov edx,[ebx]
(5) mov edx,[ebx+1234h]
(6) mov edx,vard[ebx]
(7) mov edx,[ebx+edi]
(8) mov edx,[ebx+edi+1234h]
(9) mov edx,vard[esi+edi]
(10) mov edx,[ebp*4]

**答案**：
(1) 立即数寻址
(2) 直接寻址
(3) 寄存器寻址
(4) 寄存器间接寻址
(5) 寄存器相对寻址
(6) 寄存器相对寻址（与(5)类似）
(7) 基址变址寻址
(8) 相对基址变址寻址
(9) 基址变址寻址（带变量偏移）
(10) 比例变址寻址（或基址比例寻址）

**解析**：
- 寻址方式由源操作数形式决定。
- 涉及变量、寄存器、偏移量的组合。
- vard[ebx]等价于[vard + ebx]，是寄存器相对寻址。

**知识点讲解**：
- **寻址方式分类**：
  - 立即数：操作数为常数，如1234h。
  - 寄存器：操作数为寄存器，如ebx。
  - 直接寻址：[vard]，地址由变量给出。
  - 寄存器间接：[ebx]，地址在寄存器中。
  - 寄存器相对：[ebx+1234h]，地址=寄存器+偏移。
  - 基址变址：[ebx+edi]，地址=基址寄存器+变址寄存器。
  - 相对基址变址：[ebx+edi+1234h]，地址=基址+变址+偏移。
  - 比例变址：[ebp*4]，地址=寄存器*比例因子。

**做题步骤**：
1. 识别源操作数组成部分（常数、寄存器、内存访问）。
2. 根据公式判断寻址方式。
3. 注意内存访问中偏移量和寄存器的组合。

---

## 第3章 通用数据处理指令

### 题目3.3填空题（来自图6，被蓝色笔迹圈出）
**题目内容**：填空：
(1) 指令“PUSH DS”执行后，ESP会________。
(2) 指令“POP EDX”的功能也可以用MOV和ADD指令实现，依次应该是________指令。
(3) 例3-3的TAB定义如果是“1234567890”，则显示结果是________。
(4) 进行8位二进制数加法：BAH+6CH，8位结果是________，标志PF=________。
进行16位二进制数加法：45BAH+786CH，16位结果是________，标志PF=________。
(5) 已知AX=98H，执行“NEG AX”指令后，AX=________，标志SF=________。
(6) 假设CL=98H，执行“MOVZX DX,CL”指令后，DX=________，这称为________扩展。
(7) 假设CL=98H，执行“MOVSX DX,CL”指令后，DX=________，这称为________扩展。
(8) 执行指令“XOR EAX,EAX”和“SUB EAX,EAX”后，EAX=________，CF=________。而执行指令“MOV EAX,0”后，EAX=________，CF和OF________。
(9) 例3-9的程序执行结束后，变量QVAR的内容是________。
(10) 欲将EDX内的无符号数除以16，使用指令“SHR EDX，________”，其中后一个数是一个立即数。

**答案**：
(1) ESP减少4（栈向低地址增长，PUSH后ESP-4）。
(2) MOV EDX, [ESP] 和 ADD ESP, 4（先取栈顶值，再调整栈指针）。
(3) 显示结果取决于程序，但TAB为字符串，可能显示“1234567890”或转换后形式。假设显示原字符串。
(4) 8位加法：BAH+6CH=126H，8位结果=26H，PF=0（奇偶校验，26H有3个1，奇数个1，PF=0）。
16位加法：45BAH+786CH=0BE26H，16位结果=BE26H，PF=0（BE26H有9个1，奇数，PF=0）。
(5) NEG AX求补码，98H的补码为-104，AX=FF98H（16位），SF=1（负号）。
(6) MOVZX DX,CL：零扩展，CL=98H扩展为0098H，DX=0098H，零扩展。
(7) MOVSX DX,CL：符号扩展，CL=98H（负）扩展为FF98H，DX=FF98H，符号扩展。
(8) XOR EAX,EAX：EAX=0，CF=0；SUB EAX,EAX：EAX=0，CF=0；MOV EAX,0：EAX=0，CF和OF不变。
(9) 例3-9程序可能为乘法，QVAR内容需查原程序，假设为结果值。
(10) SHR EDX, 4（右移4位相当于除以16）。

**解析**：
- PUSH/POP影响栈指针ESP。
- 加法结果需截断到指定位数，PF表示奇偶校验（低8位中1的个数为偶数时PF=1）。
- NEG计算补码，用于负数表示。
- MOVZX零扩展（无符号），MOVSX符号扩展（有符号）。
- 逻辑运算不影响标志位除CF/OF。

**知识点讲解**：
- **栈操作**：PUSH使ESP减4（32位），POP使ESP加4。
- **标志位**：PF为奇偶标志，结果低8位中1的个数为偶数时PF=1。
- **扩展指令**：MOVZX用于无符号数扩展，MOVSX用于有符号数扩展。
- **移位指令**：SHR右移等价于无符号数除以2的n次方。

**做题步骤**：
1. 根据指令语义计算结果。
2. 注意数据大小和符号。
3. 检查标志位设置规则。

---

### 题目3.8（来自图5，有手写解答和计算过程）
**题目内容**：假设当前ESP=0012FFBOH，说明下面每条指令后ESP等于多少。
```asm
push edx
push dword ptr 0f79h
pop eax
pop word ptr [bx]
pop ebx
```

**答案**：
- push edx：ESP减少4，ESP=0012FFB0H - 4 = 0012FFACH。
- push dword ptr 0f79h：ESP再减4，ESP=0012FFACH - 4 = 0012FFA8H。
- pop eax：ESP加4，ESP=0012FFA8H + 4 = 0012FFACH。
- pop word ptr [bx]：ESP加2（因为word为16位），ESP=0012FFACH + 2 = 0012FFAEH。
- pop ebx：ESP加4，ESP=0012FFAEH + 4 = 0012FFB2H。

**解析**：
- PUSH操作：ESP减操作数大小（字节数）。
- POP操作：ESP加操作数大小。
- dword ptr为32位（4字节），word ptr为16位（2字节）。
- 注意：pop word ptr [bx]从栈弹出16位，所以ESP加2。

**知识点讲解**：
- **栈指针ESP**：指向栈顶，栈向低地址增长。
- **操作数大小**：PUSH和POP根据操作数调整ESP。
- **指针类型**：dword ptr指示32位操作，word ptr指示16位操作。

**做题步骤**：
1. 初始ESP值。
2. 根据每个指令调整ESP。
3. 注意操作数大小。

---

### 题目3.9（来自图5，有手写解答）
**题目内容**：已知数字0~9对应的格雷码依次为18H、34H、05H、06H、09H、0AH、0CH、11H、12H、14H，请为如下程序的每条指令加上注释，说明每条指令的功能和执行结果。
```asm
; 数据段
table db 18H,34H,05H,06H,09H,0aH,0cH,11H,12H,14H
; 代码段
mov ebx,offset table
mov al,8
xlat
```

**答案**：
- `mov ebx,offset table`：将table的偏移地址加载到BX寄存器。功能：设置XLAT的基地址。执行结果：EBX指向table的首地址。
- `mov al,8`：将数字8加载到AL寄存器。功能：设置索引值。执行结果：AL=8。
- `xlat`：查表转换，从table中取索引为AL的字节。功能：将AL作为索引，从EBX指向的表中取字节到AL。执行结果：AL=table[8]=12H（数字8的格雷码）。
- 不使用XLAT的修改：
  ```asm
  mov ebx, offset table
  mov al, 8
  mov al, [ebx+al]   ; 直接内存访问替代XLAT
  ```

**解析**：
- XLAT指令：AL作为索引，从DS:EBX指向的表中取字节到AL。
- 格雷码表：table包含数字0-9的格雷码。
- 索引8对应第9个元素（从0开始），值为12H。

**知识点讲解**：
- **XLAT指令**：用于查表转换，简化字节表查找。
- **格雷码**：一种编码，相邻数字只有一位不同。
- **内存访问**：XLAT等价于MOV AL, [EBX+AL]。

**做题步骤**：
1. 理解XLAT指令功能。
2. 根据索引值查找表。
3. 提供替代指令。

---

### 题目3.10（来自图5，有手写解答）
**题目内容**：举例说明CF和OF标志的差异。

**答案**：
CF和OF标志都表示运算是否溢出，但应用场景不同：
- **CF（进位标志）**：用于无符号数运算，表示最高位的进位（加法）或借位（减法）。
- **OF（溢出标志）**：用于有符号数运算，表示结果是否超出有符号数范围。
示例：
- 无符号数加法：FFH + 01H = 100H，CF=1（无符号溢出），但OF=0（有符号数-1+1=0，无溢出）。
- 有符号数加法：7FH + 01H = 80H，CF=0（无进位），但OF=1（有符号数127+1=-128，溢出）。

**解析**：
- CF关注无符号数的位溢出，OF关注有符号数的符号变化。
- 相同运算可能设置不同标志。

**知识点讲解**：
- **无符号数**：范围0到2^n-1，CF=1表示结果超出范围。
- **有符号数**：范围-2^(n-1)到2^(n-1)-1，OF=1表示结果符号错误。

**做题步骤**：
1. 解释CF和OF的含义。
2. 举例说明不同情况。
3. 强调应用场景。

---

### 题目3.12（来自图5，有手写解答和计算过程）
**题目内容**：给出下列各条指令执行后AL的值，以及CF、ZF、SF、OF和PF的状态。
```asm
mov al,89h
add al,al
add al,9dh
cmp al,0bch
sub al,al
dec al
inc al
```

**答案**：
- `mov al,89h`：AL=89H，标志未定义（通常不影响，但实际中可能保留原值，但通常认为mov不影响标志位）。
- `add al,al`：89H+89H=112H，8位结果AL=12H，CF=1（有进位），OF=1（有符号数溢出：-119 + -119 = -238，超出范围），SF=0（结果最高位0），ZF=0（非零），PF=0（12H=00010010B，3个1，奇数）。
- `add al,9dh`：12H+9DH=AFH，AL=AFH，CF=0（无进位），OF=0（有符号数：18 + (-99) = -81，在范围内），SF=1（AFH=10101111B，最高位1），ZF=0，PF=1（AFH有5个1，奇数，PF=0？检查：10101111B，1的个数=6，偶数，PF=1。更正：AFH=1010 1111，5个1？不对，是6个1：1+0+1+0+1+1+1+1=6，偶数，PF=1）。
- `cmp al,0bch`：比较AFH和BCH，计算AFH - BCH，结果不保存，但影响标志。AFH - BCH = -0DH，CF=1（有借位），OF=0（无溢出），SF=1（结果为负），ZF=0，PF=？根据结果低8位，但cmp不影响PF？实际上cmp会影响所有状态标志，包括PF。但通常PF根据结果低8位中1的个数决定。这里结果低8位为AFH-BCH的结果，但实际计算时，CPU内部进行减法，然后设置标志。我们通常不直接计算PF，但可根据规则：如果结果为负数，则SF=1。具体PF值可计算，但题目可能不要求精确PF，或可略过。
- `sub al,al`：AL=AFH - AFH = 0，AL=0，CF=0，OF=0，SF=0，ZF=1，PF=1（0的个数为8，偶数）。
- `dec al`：AL=0-1=FFH，AL=FFH，CF不变（dec不影响CF），OF=0，SF=1，ZF=0，PF=1（FFH有8个1，偶数）。
- `inc al`：AL=FFH+1=00H，AL=0，CF不变（inc不影响CF），OF=1（有符号数溢出：-1+1=0，无溢出？OF=0），SF=0，ZF=1，PF=1。

**注意**：由于计算过程复杂，特别是PF，需要仔细计算每个结果的低8位中1的个数。这里给出一般性答案，具体PF值可根据二进制计算。

**解析**：
- 每个指令执行后，需重新计算标志位。
- 注意加法和减法对CF和OF的影响不同。
- dec和inc不影响CF，但影响其他标志。

**知识点讲解**：
- **标志位计算规则**：
  - CF：无符号溢出。
  - OF：有符号溢出。
  - ZF：结果为0。
  - SF：结果最高位。
  - PF：结果低8位中1的个数为偶数。
- **指令对标志的影响**：mov不影响标志，算术指令影响，cmp只影响标志不保存结果。

**做题步骤**：
1. 逐步执行指令，计算AL值。
2. 对每个算术指令，计算CF、OF、SF、ZF、PF。
3. 注意特殊指令如cmp、dec、inc的规则。

---

### 题目3.13（来自图5，有手写解答）
**题目内容**：如下两段程序执行后，EDX EAX寄存器对的值各是多少？
（图片描述不完整，假设常见题目）
示例：
程序1：
```asm
mov eax, 100
mul eax  ; EDX:EAX = EAX * EAX
```
程序2：
```asm
mov eax, 100
imul eax  ; EDX:EAX = EAX * EAX
```

**答案**：
- 程序1：mul eax（无符号乘法），100*100=10000，EDX=0, EAX=10000。
- 程序2：imul eax（有符号乘法），100*100=10000，EDX=0, EAX=10000。

**解析**：
- 100在无符号和有符号下都是正数，结果相同。
- mul和imul对于正数乘法结果一致。

**知识点讲解**：
- **乘法指令**：
  - mul：无符号乘法，结果在EDX:EAX。
  - imul：有符号乘法，结果在EDX:EAX。
- **结果大小**：32位乘法产生64位结果。

**做题步骤**：
1. 确定乘法类型。
2. 计算乘积。
3. 分配高低位。

---

### 题目3.14（来自图4，被红色圆圈标注，有下划线）
**题目内容**：请分别用一条汇编语言指令完成如下功能。
(1) 把EBX寄存器和EDX寄存器的内容相加，并把结果存入EDX寄存器。
(2) 用寄存器EBX和ESI的基址变址寻址方式把存储器的一个字节与AL寄存器的内存相加，并把结果送到AL中。
(3) 用EBX和位移量0b2h的寄存器相对寻址方式把存储器中的一个双字和ECX寄存器的内容相加，并把结果送回存储器中。
(4) 将32位变量VARD与数3412H相加，并把结果送回该存储单元中。
(5) 把数0A0H与EAX寄存器的内容相加，并把结果送回EAX中。

**答案**：
(1) `add edx, ebx`
(2) `add al, [ebx+esi]`
(3) `add [ebx+0b2h], ecx`
(4) `add vard, 3412h`
(5) `add eax, 0a0h`

**解析**：
- 加法指令add支持寄存器、内存和立即数操作数。
- 注意操作数大小匹配。
- (4)中3412H是16位，但vard是32位，汇编器可能自动扩展，但最好用add vard, 3412h（MASM处理）。

**知识点讲解**：
- **ADD指令**：语法add dest, src，结果存dest。
- **寻址方式**：支持多种内存寻址。
- **操作数大小**：需一致，否则错误。

**做题步骤**：
1. 确定操作数类型。
2. 选择适当寻址方式。
3. 编写指令。

---

### 题目3.15（来自图4，被红色圆圈标注）
**题目内容**：两个64位无符号整数分别存放在变量buffer1和buffer2中，定义数据并编写代码完成EDX.EAX ← buffer1 - buffer2功能。

**答案**：
```asm
.data
buffer1 dq 123456789abcdef0h  ; 64位变量
buffer2 dq 0fedcba9876543210h
.code
mov eax, dword ptr buffer1    ; 低32位
mov edx, dword ptr buffer1+4  ; 高32位
sub eax, dword ptr buffer2    ; 减低32位
sbb edx, dword ptr buffer2+4  ; 减高32位，带借位
```

**解析**：
- 64位减法需分高低32位进行。
- sub处理低32位，sbb处理高32位并减去借位。
- dword ptr指示取32位。

**知识点讲解**：
- **64位运算**：在32位处理器上，使用EDX:EAX组合。
- **SBB指令**：带借位减法，dest = dest - src - CF。
- **内存访问**：用dword ptr指定大小。

**做题步骤**：
1. 定义64位变量。
2. 加载buffer1到EDX:EAX。
3. 用sub和sbb减buffer2。

---

### 题目3.16（来自图4，被红色圆圈标注）
**题目内容**：分别执行如下程序片段，说明每条指令的执行结果：
(1)
```asm
mov esi,10011100b
and esi,80h
or esi,7fh
xor esi,0feh
```
(2)
```asm
mov eax,1010b
shr eax,2
shl eax,1
and eax,3
mov eax,1011b
rol eax,2
rcr eax,1
or eax,3
xor eax,eax
```

**答案**：
(1)
- mov esi,10011100b：ESI=10011100B=9CH。
- and esi,80h：ESI=9CH AND 80H=80H。
- or esi,7fh：ESI=80H OR 7FH=FFH。
- xor esi,0feh：ESI=FFH XOR FEH=01H。
(2)
- mov eax,1010b：EAX=1010B=0AH。
- shr eax,2：EAX=10B=2, CF=0（最后移出位）。
- shl eax,1：EAX=100B=4, CF=0。
- and eax,3：EAX=4 AND 3=0, CF=0（逻辑运算不影响CF，但之前CF未变）。
- mov eax,1011b：EAX=1011B=0BH。
- rol eax,2：EAX=101100B=2CH, CF=1（最后移入位）。
- rcr eax,1：EAX=100110B=26H, CF=0（带CF旋转）。
- or eax,3：EAX=26H OR 3=27H, CF=0。
- xor eax,eax：EAX=0, ZF=1, CF=0, OF=0。

**解析**：
- 逻辑和移位指令影响标志位。
- 注意移位方向和行为。
- 旋转指令涉及CF。

**知识点讲解**：
- **移位指令**：
  - SHR：逻辑右移，补0。
  - SHL：逻辑左移，补0。
  - ROL：循环左移。
  - RCR：带CF循环右移。
- **标志位**：移位影响CF和OF，逻辑运算影响SF、ZF、PF。

**做题步骤**：
1. 计算每个指令结果。
2. 跟踪标志位变化。
3. 注意指令语义。

---

### 题目3.21（来自图3，被划圈和红笔圈画，有手写注释）
**题目内容**：如下程序片段实现EAX乘以某个数X的功能，请判断X等于多少。
```asm
mov ecx, eax
shl eax, 3
lea eax, [eax+eax*8]
sub eax, ecx
```

**答案**：X = 71。

**解析**：
- 设原EAX值为A。
- mov ecx, eax：ECX = A。
- shl eax, 3：EAX = A * 8。
- lea eax, [eax+eax*8]：EAX = EAX + EAX*8 = 8A + 64A = 72A。
- sub eax, ecx：EAX = 72A - A = 71A。
- 所以X=71。

**知识点讲解**：
- **移位乘法**：shl左移n位相当于乘以2^n。
- **LEA指令**：可用于计算地址，也可用于算术运算。
- **优化乘法**：用移位和加减代替乘法。

**做题步骤**：
1. 逐步模拟指令执行。
2. 用代数表达式表示。
3. 简化表达式。

---

### 题目3.22（来自图3，被划圈和红笔圈画，有手写注释）
**题目内容**：请使用移位和加减法指令编写一个程序片段计算EAX×21，假设乘积不超过32位。提示：21=16+4+1。

**答案**：
```asm
mov ebx, eax   ; 保存原值
shl eax, 4     ; EAX = EAX * 16
mov ecx, eax   ; 保存16*EAX
mov eax, ebx   ; 恢复原值
shl eax, 2     ; EAX = EAX * 4
add eax, ecx   ; EAX = 4*EAX + 16*EAX = 20*EAX
add eax, ebx   ; EAX = 20*EAX + 1*EAX = 21*EAX
```

**解析**：
- 21=16+4+1，所以EAX×21 = EAX×16 + EAX×4 + EAX×1。
- 使用SHL实现乘16和乘4。
- 最后相加。

**知识点讲解**：
- **移位乘法**：左移1位乘2，左移4位乘16。
- **效率**：移位和加减比乘法指令快。

**做题步骤**：
1. 将乘数分解为2的幂和。
2. 用SHL实现乘2的幂。
3. 用ADD求和。

---

### 题目3.23（来自图3，被划圈和红笔圈画，有手写注释）
**题目内容**：阅读如下程序，为每条指令添加注释，指出其功能或作用，并说明这个程序运行后显示的结果。如果将程序中的寄存器间接寻址替换为寄存器相对寻址，如何修改程序？
程序片段：
```asm
; 数据段
num db 6,7,7,8,3,0,0,0
count equ $ - num
; 代码段
mov ecx, count
mov esi, 0
lp:
 mov al, [num+esi]
 add al, 30h
 call dispchar
 inc esi
 loop lp
```

**答案**：
- 注释：
  - `mov ecx, count`：设置循环次数为数字个数（8）。
  - `mov esi, 0`：初始化索引寄存器为0。
  - `mov al, [num+esi]`：从数组num取第esi个字节到AL。
  - `add al, 30h`：将数字转换为ASCII字符（数字0的ASCII为30H）。
  - `call dispchar`：显示AL中的字符。
  - `inc esi`：索引加1。
  - `loop lp`：循环直到ECX=0。
- 显示结果：数字序列转换为字符显示，即"67783000"。
- 改为寄存器相对寻址：原代码已使用[num+esi]，是寄存器相对寻址。如果改为纯寄存器间接寻址，需修改为：
  `mov esi, offset num`然后`mov al, [esi]`和`inc esi`。

**解析**：
- 程序将字节数组中的数字转换为ASCII字符并显示。
- 寄存器相对寻址：[num+esi]有效地址为num的地址加ESI。
- 显示函数dispchar输出字符。

**知识点讲解**：
- **寻址方式**：
  - 寄存器间接：[esi]，地址在寄存器中。
  - 寄存器相对：[num+esi]，地址=变量地址+寄存器。
- **ASCII转换**：数字加30H得到字符。
- **循环结构**：用ECX和LOOP实现。

**做题步骤**：
1. 分析每条指令的功能。
2. 模拟执行得到输出。
3. 修改寻址方式时调整地址加载。

---

### 题目3.24（来自图3，被划圈和红笔圈画，有手写注释）
**题目内容**：说明如下程序执行后的显示结果：
```asm
xor ebx, ebx
mov al, [ebx+msg]
add al, 20h
mov [ebx], al
; 假设msg为字符串地址
```
（图片描述不完整，假设msg定义）

**答案**：显示结果取决于msg内容。假设msg为字符串"Hello"，则程序将第一个字符'H'转换为小写'h'，但存储到地址0，可能出错。显示结果可能为小写h或其他。

**解析**：
- xor ebx,ebx设置EBX=0。
- mov al, [ebx+msg]取msg第一个字符（'H'=48H）。
- add al, 20H：大写字母转小写（48H+20H=68H='h'）。
- mov [ebx], al存储到地址0，非法操作（地址0通常受保护）。
- 显示函数未给出，可能显示修改后的字符或崩溃。

**知识点讲解**：
- **大小写转换**：大写字母加20H得小写。
- **内存访问**：地址0通常受保护，可能导致异常。
- **字符串处理**：需确保地址有效。

**做题步骤**：
1. 确定msg内容。
2. 模拟指令执行。
3. 考虑系统行为。

---

### 题目3.25（来自图2，被红色圆圈标注，有手写注释“tab = 该字母-'a'”）
**题目内容**：下面程序的功能是将数组ARRAY1的每个元素加固定值（8000H），将和保存在数组ARRAY2中。在空白处填入适当的语句或语句的一部分。
程序片段：
```asm
; 数据段
array1 dd 1,2,3,4,5,6,7,8,9,10
count equ ($ -array1)/4
array2 dd count dup(0)

;代码段
    mov ecx,count
    mov ebx,0
again:
    mov eax,array1[ebx*4]
    add eax,8000h
    mov array2[ebx*4],eax
    add ebx,1
    loop again
```

**答案**：空白处已填全，但图片中有手写注释，可能需修正。正确代码如上。

**解析**：
- 数组为双字（4字节），所以用ebx*4索引。
- 循环count次。
- 每个元素加8000H。

**知识点讲解**：
- **数组遍历**：用基址索引寻址（如array1[ebx*4]）。
- **循环控制**：用ECX和LOOP。
- **数据定义**：dd定义双字，dup分配空间。

**做题步骤**：
1. 确定数组类型和大小。
2. 设置循环次数。
3. 使用索引访问元素。
4. 完成运算和存储。

---

## 第4章 控制转移指令

### 题目4.1 简答题（来自图1，有手写标记）
**题目内容**：
(1) CPUID指令返回识别字符串的首个字符“G”在哪个寄存器中?
(2) 数据的直接寻址和指令的直接寻址有什么区别?
(3) 什么特点决定了目标地址的相对寻址方式应用最多?
(4) JCC指令能跳转到代码段之外吗?
(5) 什么是奇偶校验?
(6) 助记符JZ和JE为什么表达同一条指令?
(7) 为什么判断无符号数大小和有符号大小的条件转移指令不同?
(8) 双分支结构中两个分支体之间的JMP指令有什么作用?
(9) 如果循环体的代码量远超过128个字节，还能用LOOP指令实现计数控制循环吗?
(10) 什么是“先循环后判断”循环结构?

**答案**：
(1) CPUID指令返回的识别字符串（制造商ID字符串）存储在EBX、EDX、ECX中，其中首个字符“G”在EBX的低8位（即BL寄存器）。
(2) 数据的直接寻址是操作数的有效地址直接包含在指令中；指令的直接寻址是转移目标地址直接包含在指令中。两者都是直接给出地址，但一个用于数据访问，一个用于指令跳转。
(3) 相对寻址方式的目标地址是当前指令指针的偏移量，这样的代码与加载地址无关，便于重定位，所以应用最多。
(4) 不能。JCC指令是条件近转移，只能在当前代码段内跳转。
(5) 奇偶校验是一种错误检测方法，通过设置校验位使得数据位和校验位中1的个数为偶数（偶校验）或奇数（奇校验）。
(6) JZ（为零跳转）和JE（相等跳转）的机器码相同，因为它们都是基于ZF标志位：ZF=1时跳转。汇编器支持多个助记符方便记忆。
(7) 因为无符号数和有符号数的比较规则不同，所以判断大小的条件不同。例如，无符号数用CF和ZF，有符号数用OF、SF和ZF组合。
(8) 双分支结构中，第一个分支体执行完后，用JMP跳过第二个分支体，避免落入第二个分支。
(9) 可以。LOOP指令的转移范围是-128~127字节，如果循环体超过这个范围，可以用LOOP指令配合JMP指令，或者用DEC ECX和JNZ指令实现。
(10) “先循环后判断”循环结构是先执行循环体，再判断循环条件，即至少执行一次循环体。

**解析**：略。

**知识点讲解**：略。

**做题步骤**：略。

---

### 题目4.2 判断题（来自图1，有手写标记）
**题目内容**：
(1) 单独指令指针改变或者指令指针和代码段寄存器值的改变都将引起程序流程的跳转。
(2) 指令的相对寻址都是近转移。
(3) 采用指令的寄存器间接寻址，目标地址来自存储单元。
(4) JMP指令对应高级语言的GOTO语句，所以不能使用。
(5) 因为条件转移指令JCC要利用标志作为条件，所以也影响标志。
(6) JA和JC指令的条件都是“大于”，所以是同一个指令的两个助记符。
(7) JC和JB的条件都是CF = 1，所以是同一条指令。
(8) 控制循环是否结束只能在一次循环结束之后进行。
(9) 介绍LOOP指令时，常说它相当于DEC ECX和JNZ两条指令。但考虑对状态标志的影响，它们有差别。LOOP指令不影响标志，而DEC指令却会影响除CF之外的其他状态标志。
(10) 若ECX = 0，则LOOP指令和JECX指令都发生转移。

**答案**：
(1) 正确。改变EIP或CS:EIP都会引起流程跳转。
(2) 错误。相对寻址可以是近转移，也可以是短转移（8位偏移）或近转移（16/32位偏移）。
(3) 错误。寄存器间接寻址的目标地址来自寄存器，而不是存储单元。存储单元是内存，寄存器间接寻址是用寄存器值作为地址。
(4) 错误。JMP指令可以用于实现多分支结构等，合理使用是可以的，但应避免滥用导致代码混乱。
(5) 错误。JCC指令只根据标志位条件跳转，不影响标志位。
(6) 错误。JA是无符号数大于跳转（CF=0且ZF=0），JC是进位为1跳转（CF=1），条件不同。
(7) 正确。JC和JB是同一条指令的两个助记符，条件都是CF=1。
(8) 错误。循环结束判断可以在循环体之前、之后或中间进行。
(9) 正确。LOOP指令不影响标志位，DEC指令会影响SF、ZF、OF、PF等，但不影响CF。
(10) 错误。ECX=0时，LOOP指令不转移（因为先dec ecx，再判断ecx≠0），而JECX指令在ECX=0时转移。

**解析**：略。

**知识点讲解**：略。

**做题步骤**：略。

---

### 题目4.3 填空题（来自图1，有手写标记）
**题目内容**：
(1) JMP指令根据目标地址的转移范围和寻址方式，可以分成4种类型：段内转移、___，段内转移、___，段间转移、___，段间转移、___。
(2) MASM给短转移、近转移和远转移定义的类型名依次是___、___和___。
(3) 假设在平展存储模型下，EBX = 1256H，双字变量TABLE的偏移地址是20A1H，线性地址32F7H处存放3280H，执行指令“JMP EBX”后，EIP =___，执行指令...

**答案**：
(1) 段内转移、直接寻址；段内转移、间接寻址；段间转移、直接寻址；段间转移、间接寻址。
(2) SHORT、NEAR PTR、FAR PTR。
(3) EIP = 1256H。（注：JMP EBX是段内间接转移，目标地址在EBX中，所以EIP=EBX=1256H。）

**解析**：略。

**知识点讲解**：略。

**做题步骤**：略。