# MASM


### 一、环境搭建
MASM是微软推出的汇编器，需先配置开发环境：

1. **工具选择**  
   - 推荐使用 **MASM32 SDK**（适用于32位汇编）：包含汇编器（`ml.exe`）、链接器（`link.exe`）、库文件和示例。  
   - 或通过 **Visual Studio** 配置：VS内置MASM，需在项目属性中启用“MASM”组件。  

2. **基本操作流程**  
   汇编源码（`.asm`）→ 汇编（`ml.exe`）生成目标文件（`.obj`）→ 链接（`link.exe`）生成可执行文件（`.exe`）。  
   示例命令（CMD中）：  
   ```cmd
   ml /c /coff test.asm  ; 汇编（/c：仅汇编，/coff：生成COFF格式目标文件）
   link /subsystem:console test.obj  ; 链接（/subsystem:console：控制台程序）
   ```


### 二、MASM源程序基本结构
MASM程序由**段（Segment）** 组成，核心段包括数据段、代码段、堆栈段，通过伪指令定义。

#### 1. 段定义伪指令
- `.data`：数据段（定义常量、变量等）  
- `.code`：代码段（存放指令）  
- `.stack`：堆栈段（默认大小100h字节，可指定：`.stack 1000h`）  
- `end [标号]`：程序结束（标号为入口点，如`end start`）  


#### 2. 最简示例（16位DOS程序）
```asm
; 数据段：定义字符串
.data
    msg db 'Hello, MASM!', 0dh, 0ah, '$'  ; 0dh=回车，0ah=换行，$为DOS输出结束符

; 代码段：程序逻辑
.code
start:  ; 入口点
    mov ax, @data  ; @data是数据段基地址（MASM伪变量）
    mov ds, ax     ; 初始化数据段寄存器DS（16位需显式设置）

    mov ah, 09h    ; DOS功能调用：输出字符串（功能号09h）
    mov dx, offset msg  ; DX=字符串偏移地址
    int 21h        ; 触发中断执行功能

    mov ah, 4ch    ; DOS功能调用：程序退出（功能号4ch）
    int 21h
end start  ; 结束程序，入口为start
```


### 三、数据定义与数据类型
MASM通过伪指令定义数据，支持多种类型，格式：`变量名 数据类型 初始值`。

#### 1. 基本数据类型
| 伪指令 | 含义（x86）       | 示例                          |
|--------|-------------------|-------------------------------|
| `db`   | 字节（8位）       | `a db 10h`（定义字节变量a=0x10） |
| `dw`   | 字（16位）        | `b dw 1234h`（字变量b=0x1234）  |
| `dd`   | 双字（32位）      | `c dd 12345678h`              |
| `dq`   | 四字（64位）      | `d dq 1122334455667788h`      |
| `dt`   | 十字节（80位）    | `e dt 123.45`（BCD码）        |

#### 2. 字符串与数组
- 字符串：用`db`定义，默认逐个字符存为字节。  
  例：`str1 db 'abc'` → 内存中为`61h, 62h, 63h`（ASCII码）。  
- 数组：连续定义多个值，用逗号分隔。  
  例：`arr db 1,2,3,4`（4字节数组）；`table dw 10 dup(0)`（10个0的字数组，`dup`为重复操作符）。

#### 3. 常量与符号
- `equ`：定义符号常量（不可重定义）。  
  例：`MAX equ 100` → 后续`MAX`等价于100。  
- `= `：定义可重定义常量。  
  例：`COUNT = 5` → 可再用`COUNT = 10`修改。


### 四、寄存器（x86架构）
汇编依赖寄存器操作，x86核心寄存器分类如下：

#### 1. 通用寄存器（32位/16位/8位别名）
| 32位   | 16位   | 8位高字节 | 8位低字节 | 主要用途                     |
|--------|--------|-----------|-----------|------------------------------|
| EAX    | AX     | AH        | AL        | 累加器（算术运算、返回值）   |
| EBX    | BX     | BH        | BL        | 基址寄存器（数据访问）       |
| ECX    | CX     | CH        | CL        | 计数器（循环、串操作）       |
| EDX    | DX     | DH        | DL        | 数据寄存器（扩展算术、I/O）   |
| ESI    | SI     | -         | -         | 源变址寄存器（串操作源地址） |
| EDI    | DI     | -         | -         | 目的变址寄存器（串操作目的） |
| EBP    | BP     | -         | -         | 基址指针（堆栈帧）           |
| ESP    | SP     | -         | -         | 堆栈指针（栈顶地址）         |

#### 2. 段寄存器（16位，32位中仍用于内存寻址）
- `CS`：代码段寄存器（指向当前指令所在段）  
- `DS`：数据段寄存器（默认数据访问段）  
- `SS`：堆栈段寄存器（指向堆栈段）  
- `ES`、`FS`、`GS`：附加段寄存器（额外数据段）

#### 3. 控制寄存器
- `EIP`：指令指针（指向 next 指令，不可直接修改）  
- 标志寄存器（EFLAGS）：存储运算状态（如零标志ZF、进位标志CF等）。


### 五、寻址方式
MASM支持多种内存寻址方式，格式：`[地址表达式]`。

1. **立即数寻址**：操作数为常量。  
   例：`mov eax, 1234h`（EAX = 0x1234）。

2. **寄存器寻址**：操作数为寄存器。  
   例：`mov ebx, eax`（EBX = EAX的值）。

3. **直接寻址**：操作数为内存地址（偏移量）。  
   例：`mov ecx, [0x1234]`（ECX = 内存0x1234处的双字）；  
   或用变量名：`mov dl, [msg]`（DL = msg变量的第一个字节）。

4. **寄存器间接寻址**：地址存于寄存器中。  
   例：`mov eax, [ebx]`（EAX = EBX指向的内存双字）。

5. **基址+偏移寻址**：`[基址寄存器 + 偏移量]`。  
   例：`mov ax, [bx + 10h]`（AX = BX+0x10处的字）。

6. **基址+变址寻址**：`[基址寄存器 + 变址寄存器]`。  
   例：`mov ecx, [ebp + esi]`（ECX = EBP+ESI处的双字）。

7. **比例变址寻址**（32位）：`[基址 + 变址 * 比例 + 偏移]`。  
   例：`mov edx, [ebx + esi*4 + 8]`（适用于数组访问，比例=1/2/4/8）。


### 六、核心指令系统
#### 1. 数据传送指令
- `mov 目的, 源`：传送数据（注意：不能直接传段寄存器到通用寄存器，16位需通过AX中转）。  
  例：`mov ds, ax`（正确）；`mov ds, bx`（错误）。  
- `push 操作数`：压栈（32位压4字节，16位压2字节）。  
- `pop 目的`：出栈。  
- `lea 目的寄存器, 地址`：取地址（加载有效地址）。  
  例：`lea eax, [ebx + 10h]`（EAX = EBX + 0x10，非内存值）。


#### 2. 算术运算指令
- `add 目的, 源`：加法（目的 += 源，影响CF/ZF等标志）。  
- `sub 目的, 源`：减法（目的 -= 源）。  
- `mul 源`：无符号乘法（8位：AX = AL * 源；16位：DX:AX = AX * 源；32位：EDX:EAX = EAX * 源）。  
- `div 源`：无符号除法（8位：AL = AX / 源，AH = 余数；16位：AX = DX:AX / 源，DX = 余数）。  
- `inc 目的`：自增1（不影响CF）；`dec 目的`：自减1。  


#### 3. 逻辑与移位指令
- `and 目的, 源`：按位与（例：`and al, 0fh` 清AL高4位）。  
- `or 目的, 源`：按位或（例：`or al, 30h` 转换为ASCII数字）。  
- `xor 目的, 源`：按位异或（例：`xor eax, eax` 清零EAX）。  
- `not 目的`：按位取反。  
- `shl 目的, 计数`：逻辑左移（低位补0，高位进CF）。  
- `shr 目的, 计数`：逻辑右移（高位补0，低位进CF）。  
- `sal`/`sar`：算术移位（与shl/shr类似，但sar高位补符号位）。  


#### 4. 转移与循环指令
- **无条件转移**：`jmp 标号`（跳转到标号处）。  
- **条件转移**（依赖标志寄存器）：  
  | 指令   | 条件（标志位）          | 含义               |
  |--------|-------------------------|--------------------|
  | `jz`   | ZF=1（结果为0）         | 为零则转移         |
  | `jnz`  | ZF=0（结果非0）         | 非零则转移         |
  | `jc`   | CF=1（有进位/借位）     | 有进位则转移       |
  | `jnc`  | CF=0（无进位/借位）     | 无进位则转移       |
  | `je`   | ZF=1（等于）            | 等于则转移（同jz） |
  | `jne`  | ZF=0（不等于）          | 不等于则转移       |

- **循环指令**：  
  - `loop 标号`：CX/ECX减1，若不为0则跳转到标号（16位用CX，32位用ECX）。  
  - `loopz`/`loope`：CX减1，若ZF=1且CX≠0则循环。  


#### 5. 子程序与中断
- **子程序调用**：`call 子程序名`（压栈返回地址，跳转）；`ret`（出栈返回地址，跳转）。  
  例：  
  ```asm
  sub1 proc  ; 定义子程序
      mov ax, 1
      ret
  sub1 endp  ; 子程序结束

  ; 调用：
  call sub1  ; 执行sub1，返回后继续
  ```

- **中断调用**：`int n`（触发n号中断，如DOS的`int 21h`，BIOS的`int 10h`）。  
  例：`int 3`（调试中断）。


### 七、伪指令与宏
MASM的伪指令不生成机器码，用于辅助汇编；宏可简化重复代码。

#### 1. 常用伪指令
- `assume 段寄存器:段名`：指定段寄存器与段的关联（告诉汇编器如何解析地址）。  
  例：`assume cs:code, ds:data`。  
- `org 偏移量`：指定后续指令/数据的起始偏移量。  
  例：`org 100h`（COM程序入口偏移）。  
- `ptr`：强制类型转换（用于明确内存操作大小）。  
  例：`mov byte ptr [ebx], 0`（将EBX指向的字节设为0）。  
- `db/dw/dd`：数据定义（见“数据类型”）。  


#### 2. 宏定义与使用
用`macro`和`endm`定义宏，格式：  
```asm
宏名 macro [参数]
    ; 宏体（指令序列）
endm
```
例：定义一个输出字符的宏（依赖DOS功能）：  
```asm
printChar macro c
    mov dl, c    ; DL=字符ASCII码
    mov ah, 02h  ; DOS功能：输出字符
    int 21h
endm

; 调用：
printChar 'A'  ; 输出'A'
printChar 0ah  ; 输出换行
```


### 八、程序结构示例
#### 1. 分支结构（if-else）
```asm
; 判断ax是否等于bx
cmp ax, bx    ; 比较ax和bx（ax - bx，仅影响标志位）
je equal      ; 若相等（ZF=1），跳转到equal
; else分支
mov dx, 0
jmp done
equal:
; if分支
mov dx, 1
done:
```

#### 2. 循环结构（计算1~10之和）
```asm
.data
sum dw 0
.code
mov cx, 10    ; 循环次数=10
mov ax, 0     ; 累加器初始为0
l1:
add ax, cx    ; ax += cx（cx从10递减到1）
loop l1       ; cx--，若cx≠0则循环
mov sum, ax   ; 结果存sum
```


### 九、32位Windows程序基础
32位程序依赖Windows API，而非DOS中断，示例（输出字符串到控制台）：  
```asm
.386                  ; 启用32位指令集
.model flat, stdcall  ; 平坦内存模型，stdcall调用约定
option casemap:none   ; 区分大小写

; 引入Windows API
include \masm32\include\kernel32.inc
includelib \masm32\lib\kernel32.lib
include \masm32\include\user32.inc
includelib \masm32\lib\user32.lib

.data
msg db 'Hello, 32-bit MASM!', 0  ; 以0结尾的字符串

.code
start:
    ; 调用MessageBoxA显示消息框
    push 0          ; MB_OK
    push offset msg ; 标题
    push offset msg ; 内容
    push 0          ; 父窗口句柄
    call MessageBoxA

    ; 退出程序
    push 0
    call ExitProcess
end start
```


### 十、调试工具
- **debug.exe**：DOS下的简易调试器（支持单步、查看寄存器/内存）。  
- **OllyDbg**：可视化调试器（适合分析EXE，支持32位）。  
- **Visual Studio调试器**：配合VS项目，可断点、监视变量。


### 总结
MASM语法核心围绕“段-寄存器-指令-寻址”展开，需重点掌握：  
1. 数据定义与内存寻址方式；  
2. 寄存器的用途及指令对标志位的影响；  
3. 分支、循环、子程序的实现逻辑；  
4. 16位（DOS）与32位（Windows）程序的差异。  


# 寄存器
寄存器是CPU内部的高速存储单元，用来暂存数据、地址和控制信息。你可以把它们想象成CPU手边**有限的、但速度极快的记事本**。汇编编程，很大程度上就是在巧妙地使用这些“记事本”。

---

### 1. 通用寄存器：程序员的“主力工作区”

这8个寄存器是你的主要工具，大部分计算和数据搬运都通过它们完成。虽然从硬件上说，它们几乎可以互换使用，但长期形成了**约定俗成的“主要用途”**，遵守这些约定能让代码更清晰、更兼容。

#### **EAX (累加器) - “主计算器”**
*   **主要用途**：算术运算（加、减、乘、除）、函数返回值。
*   **如何使用**：
    1.  **算术运算**：很多算术指令的默认操作数和结果存放地。
    2.  **函数返回值**：在大多数调用约定中，函数的整型或指针返回值通过EAX传回。

*   **举例**：
    ```assembly
    ; 例子1: 做加法 5 + 3，结果存在EAX
    mov eax, 5   ; EAX = 5
    add eax, 3   ; EAX = 5 + 3 = 8
    
    ; 例子2: 做乘法 4 * 6，结果在 EDX:EAX
    mov eax, 4   ; EAX = 4
    mov ebx, 6   ; EBX = 6
    mul ebx      ; 结果 EDX:EAX = EAX * EBX。这里小，所以EAX=24, EDX=0
    
    ; 例子3: 函数返回一个值
    my_function:
        mov eax, 100  ; 设置返回值为100
        ret           ; 返回，调用方从EAX取得100
    ```

#### **ECX (计数器) - “循环控制器”**
*   **主要用途**：作为循环计数器，或在字符串操作中计数。
*   **如何使用**：用 `mov ecx, 循环次数` 初始化，然后用 `loop` 指令或 `dec ecx; jnz` 组合来控制循环。

*   **举例**：
    ```assembly
    ; 循环10次，在屏幕上打印10个'A'
    mov ecx, 10        ; 设置计数器为10
    print_loop:
        mov al, 'A'    ; 将要打印的字符放入AL
        call print_char ; 假设有一个打印字符的函数
        loop print_loop ; ECX自动减1，如果ECX不为0，则跳回print_loop
    ; 循环结束后，ECX = 0
    ```

#### **ESI (源索引) & EDI (目的索引) - “数据搬运工”**
*   **主要用途**：用于内存块操作（如复制字符串、数组）。ESI指向**源**数据地址，EDI指向**目标**地址。
*   **如何使用**：设置好源地址和目标地址后，使用 `movsb`、`movsw` 等指令。

*   **举例**：
    ```assembly
    ; 将 src_str 处的10个字节复制到 dest_str
    mov esi, offset src_str  ; ESI 指向源字符串开头
    mov edi, offset dest_str ; EDI 指向目标内存开头
    mov ecx, 10              ; 要复制10个字节
    cld                      ; 清除方向标志，让ESI/EDI每次增加
    rep movsb                ; 重复执行 MOVSB 指令，直到 ECX=0
    ; 执行后：src_str的10个字节被复制到dest_str
    ;         ESI 和 EDI 分别增加了10
    ```

#### **EBP (基址指针) & ESP (栈指针) - “栈管理员”**
*   **ESP**：永远指向**栈顶**（最后一个压入栈的数据所在位置）。`push` 和 `pop` 指令会自动修改它。
*   **EBP**：在函数中，通常用来**定位参数和局部变量**，是函数运行的“基准点”。

*   **如何使用（函数框架示例）**：
    ```assembly
    my_func:
        push ebp        ; 1. 保存旧的基址指针
        mov  ebp, esp   ; 2. 设置新的基址指针（指向当前栈顶）
        sub  esp, 8     ; 3. 在栈上分配8字节空间给局部变量
        
        ; 此时栈布局（从高地址到低地址）：
        ; ... 调用者的数据 ...
        ; 旧EBP的值   <-- EBP 指向这里
        ; 局部变量1
        ; 局部变量2   <-- ESP 指向这里（栈顶）
        
        ; 访问第一个参数（假设在 [EBP+8]）
        ; 访问局部变量（在 [EBP-4] 等位置）
        
        mov esp, ebp   ; 4. 恢复栈指针，释放局部变量空间
        pop ebp        ; 5. 恢复旧的基址指针
        ret            ; 6. 返回
    ```

#### **EBX, EDX - “多功能辅助”**
*   **EBX**：在保护模式编程中常用作**基址**，在32位Linux系统调用中，用于传递系统调用号。
*   **EDX**：在乘除法中作为EAX的扩展（存放结果的高位或余数）。也常用于存储数据。

*   **举例（除法）**：
    ```assembly
    ; 计算 100 / 3
    mov eax, 100  ; 被除数低32位 -> EAX
    mov edx, 0    ; 被除数高32位 -> EDX (因为我们是32位除32位，所以高位置0)
    mov ebx, 3    ; 除数 -> EBX
    div ebx       ; 执行无符号除法 EDX:EAX / EBX
    ; 结果：商在 EAX = 33, 余数在 EDX = 1
    ```

---

### 2. 段寄存器：内存的“分区标签”

在现代32/64位平展内存模型中，**你通常不需要直接操作它们**。操作系统已经为你设置好了。你可以简单理解：
*   **CS (代码段)**：告诉CPU去哪里找当前要执行的指令。`EIP`（指令指针）是偏移量，`CS:EIP`共同决定了下一条指令的地址。
*   **DS (数据段)**：告诉CPU大部分数据（比如你用 `mov eax, [myVar]` 访问的变量）默认存放在哪个内存区域。
*   **SS (堆栈段)**：告诉CPU栈空间（`push`, `pop` 操作的内存）在哪儿。`ESP` 是栈顶偏移量。

**重点**：在应用层编程，**`CS`, `DS`, `SS` 通常指向同一个大的内存段**，所以你直接用偏移地址（如 `[myVar]`）访问即可，段寄存器由系统管理。

---

### 3. 控制寄存器：CPU的“状态面板”

#### **EIP (指令指针) - “导游”**
*   **用途**：永远指向CPU**下一条将要执行**的指令的地址。**你不能像操作EAX那样直接用 `mov eip, 1234h` 修改它**。
*   **如何改变它**：通过**控制转移指令**间接改变。
    *   `jmp`, `jcc` (条件跳转)：实现`if`, `goto`, `loop`。
    *   `call`：调用函数。它会把 `call` 指令的**下一条指令地址**压栈，然后跳转。
    *   `ret`：从函数返回。它从栈顶弹出地址，并跳转回去。

*   **举例**：
    ```assembly
    start:
        mov eax, 1
        cmp eax, 2
        je  label_equal  ; 如果相等，则“跳”到label_equal，改变了EIP
        mov ebx, 3       ; 不相等，则执行这条
        jmp end          ; 无条件“跳”到end
    label_equal:
        mov ebx, 4
    end:
        ...
    ```

#### **EFLAGS (标志寄存器) - “状态指示灯”**
*   **用途**：里面的每一个标志位（Flag）就像一个小灯泡，记录上一次算术或逻辑运算结果的**状态**。后续的条件跳转指令（`jcc`）就是**看这些灯泡的状态来决定是否跳转**。
*   **关键标志位**：
    *   **ZF (零标志)**：结果为0时亮起（=1）。
    *   **CF (进位标志)**：无符号数运算发生进位或借位时亮起。
    *   **SF (符号标志)**：结果为负数时亮起（最高位为1）。
    *   **OF (溢出标志)**：有符号数运算发生溢出时亮起。

*   **举例 (结合EIP)**：
    ```assembly
    mov eax, 10
    sub eax, 10   ; 执行 10 - 10 = 0
                  ; 运算后，CPU自动设置标志位：ZF=1 (因为结果是0), CF=0, SF=0, OF=0
    jz  target    ; jz 指令检查 ZF 标志。如果 ZF==1，则跳转到 target
                   ; 因为上一条 sub 使得 ZF=1，所以这里会发生跳转！
    mov ebx, 5     ; 这条指令被跳过
    target:
        mov ebx, 10 ; 程序跳转到这里继续执行
    ```

### 🧩 总结与协同工作示例
一次简单的函数调用和计算，展示了寄存器如何协同：

```assembly
; 假设我们要计算 (a+b) * c，其中a=5, b=3, c=4
section .data
    a dd 5
    b dd 3
    c dd 4

section .text
    ; 1. 计算 a+b
    mov eax, [a]   ; EAX (“主计算器”) 从内存加载 a 的值 5
    add eax, [b]   ; EAX = 5 + 3 = 8。同时设置标志位（OF, SF, ZF, CF, AF, PF）

    ; 2. 计算 (a+b) * c
    mov ecx, [c]   ; ECX 可以用来暂存数据，这里存乘数4
    mul ecx        ; 执行 EDX:EAX = EAX * ECX。结果 8*4=32 在 EAX

    ; 此时，EAX 存有最终结果 32。
    ; 如果想用循环打印结果，可以用ECX做计数器。
    ; 如果想返回这个值，调用函数通过EAX获取。
    ; 所有的运算状态（是否溢出、是否为负等）都记录在EFLAGS中，可供后续条件判断使用。
```