```assembly
; 1. 数据段定义（存放变量、常量，必须在代码段前）
DATA SEGMENT          ; DATA：数据段名（自定义，英文大写，见名知义）；SEGMENT：段开始伪指令（“SEGMENT”=段的起始）
    VAR DB 10H        ; VAR：变量名（自定义）；DB：字节定义伪指令（“DB”=Define Byte，定义1字节）；10H：变量初始值（16进制，可省略，省略则初始值不确定）
    SUM DW ?          ; SUM：变量名（用于存储结果）；DW：字定义伪指令（“DW”=Define Word，定义2字节）；?：表示初始值为空（汇编时分配内存，但不赋值）
    STR DB 'HELLO$'   ; STR：字符串变量名；DB：字节定义（每个字符占1字节）；'HELLO'：字符串（每个字符对应ASCII码，H=48H、E=45H等）；$：字符串结束符（DOS中断识别结束的标志，必须加）
DATA ENDS             ; DATA：与段开始的段名一致（不能错）；ENDS：段结束伪指令（“ENDS”=段的终止，与SEGMENT成对）

; 2. 代码段定义（存放执行指令，必须关联段寄存器）
CODE SEGMENT          ; CODE：代码段名（自定义）；SEGMENT：段开始伪指令
    ASSUME CS:CODE, DS:DATA  ; ASSUME：段关联伪指令（“ASSUME”=假设，告诉汇编器段寄存器与段的对应关系）；CS:CODE：CS寄存器对应代码段CODE（指令存放的段）；DS:DATA：DS寄存器对应数据段DATA（变量存放的段）
START:                ; START：程序入口标号（“标号”=指令的地址别名，汇编器会记录其偏移地址）；必须有（END指令需指向此标号）
    ; 初始化数据段（必考！DS不能直接赋值，需用AX中转）
    MOV AX, DATA      ; MOV：数据传送指令；AX：通用寄存器（中转用）；DATA：数据段名（汇编时会替换为数据段的段地址）；作用：将数据段地址送入AX
    MOV DS, AX        ; MOV：数据传送指令；DS：数据段寄存器；AX：存放数据段地址；作用：将AX中的段地址送入DS，完成数据段初始化（DS指向数据段，才能访问变量）
    
    ; 程序核心代码（根据题目需求编写，如赋值、运算等）
    MOV AL, VAR       ; MOV：数据传送；AL：8位寄存器；VAR：变量名（汇编时替换为偏移地址）；作用：将VAR变量的值（10H）送入AL
    ADD AL, 20H       ; ADD：加法指令；AL：目的操作数（累加和）；20H：立即数；作用：AL=10H+20H=30H
    MOV SUM, AX       ; MOV：数据传送；SUM：字变量；AX：存放结果（AL=30H，AH=00H，AX=0030H）；作用：将结果送入SUM变量
    
    ; 程序退出（实地址模式下DOS系统的标准退出方式，必考！）
    MOV AH, 4CH       ; MOV：数据传送；AH：8位高字节寄存器；4CH：DOS中断功能号（“4CH”=程序退出功能，固定值）
    INT 21H           ; INT：中断指令（“INT”=Interrupt，触发中断）；21H：DOS中断向量号（“21H”=DOS系统中断，CPU调用DOS系统功能）；作用：触发DOS中断，执行退出功能，程序正常结束
CODE ENDS             ; CODE：与段开始的段名一致；ENDS：段结束伪指令
END START             ; END：程序结束伪指令（“END”=汇编结束，告诉汇编器停止汇编）；START：程序入口标号（汇编器从START开始生成指令，确定程序执行起点）
```

# 汇编语言复习PPT（逐字逐词极致细致讲解）

按PPT页面顺序，对每个知识点、每个术语、每个指令字段进行「原子级拆解」，覆盖定义、底层逻辑、字面含义、实例验证，确保无任何模糊概念，适配零基础或极致备考需求。

## 第1页：汇编语言基础（寄存器 + 存储器组织）

### 一、寄存器（逐词拆解核心术语）

#### 1. 寄存器的本质定义

*   **寄存器**：CPU（中央处理器）内部集成的「高速存储单元」（“寄存”=临时存放，“器”=硬件单元），速度远快于内存（毫秒级vs纳秒级），用于临时存放程序执行时的「数据、地址、状态」，避免频繁访问内存拖慢速度。
*   **核心特点**：数量有限（x86架构32位CPU共8个通用寄存器、6个段寄存器等）、访问速度最快、按功能分类（通用/专用/段）。

#### 2. 通用寄存器（EAX~EDX，逐寄存器逐字段拆解）

*   **通用**：功能不固定（“通用”=可灵活用于数据运算、地址存放等，无专属固定功能），共4个32位寄存器，兼容16位（后缀X）和8位（高字节H/低字节L）拆分使用（“兼容”=支持不同位数操作，适配老程序）。
*   **逐寄存器拆解**（含英文全称、字面含义、用途细节）：

| 32位寄存器 | 英文全称 | 字面含义 | 16位别名 | 8位高字节 | 8位低字节 | 核心用途（逐点解释） |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| EAX | Extended Accumulator | Extended=扩展（32位比16位AX扩展），Accumulator=累加器 | AX | AH | AL | 1. **算术运算**：所有加法（ADD）、减法（SUB）等运算默认首选（“累加器”=累计运算结果）；<br>2. **I/O操作**：DOS中断（如INT 21H）功能调用时，AH存功能号（如AH=4CH是退出功能）；<br>3. **子程序返回值**：默认用EAX存放子程序计算结果（主程序直接从EAX取） |
| EBX | Extended Base | Base=基址（基础地址） | BX | BH | BL | 1. **基址寻址**：存储器寻址中作为基础地址（如`[BX+10H]`，BX是基址）；<br>2. **暂存数据**：无固定功能，仅临时存放数据（如运算过程中保存中间结果） |
| ECX | Extended Counter | Counter=计数器 | CX | CH | CL | 1. **循环指令**：LOOP指令默认计数器（CX值=循环次数，每次LOOP自动CX-1）；<br>2. **移位指令**：移位次数>1时，CL存移位次数（如`SHL AX, CL`，CL=3表示移位3次） |
| EDX | Extended Data | Data=数据 | DX | DH | DL | 1. **扩展运算**：配合EAX做32位运算（如EDX:EAX存放64位运算结果，EDX存高32位）；<br>2. **I/O操作**：端口地址>255时，DX存端口地址（如`OUT DX, AL`，DX=378H是打印机端口） |

*   **拆分规则**（逐位解释）：
    *   **32位（EAX）**：bit0~bit31（共32个二进制位），完整存储双字数据；
    *   **16位（AX）**：bit0~bit15（低16位），兼容16位程序，独立使用时不影响高16位；
    *   **8位高字节（AH）**：bit8~bit15（AX的高8位），“H”=High（高）；
    *   **8位低字节（AL）**：bit0~bit7（AX的低8位），“L”=Low（低）；
    *   **例**：EAX=12345678H → AX=5678H、AH=56H、AL=78H（拆分后互不影响，修改AL不改变AH和高16位）。

#### 3. 专用寄存器（功能固定，逐寄存器逐字段拆解）

*   **专用**：功能专属（“专用”=只能用于特定场景，不可随意挪用），考试重点3个：

| 寄存器 | 英文全称 | 字面含义 | 位数 | 核心功能（逐字解释） |
| :--- | :--- | :--- | :--- | :--- |
| ESP | Extended Stack Pointer | Stack=堆栈，Pointer=指针（指向） | 32位 | 1. **定位栈顶**：“栈顶”=堆栈中最后压入数据的地址，ESP永远指向栈顶；<br>2. **自动修改**：PUSH（压栈）时ESP-4（32位），POP（出栈）时ESP+4（“自动”=CPU执行指令时自动调整，无需手动修改）；<br>3. **搭配SS**：SS是堆栈段寄存器，`SS:ESP` 是栈顶的完整地址（“搭配”=必须联合使用才能定位栈顶，单独ESP无意义） |
| EBP | Extended Base Pointer | Base=基址，Pointer=指针 | 32位 | 1. **定位栈基**：“栈基”=子程序调用时，栈顶的初始地址（压入返回地址后的地址）；<br>2. **访问堆栈参数**：子程序中通过 `[EBP+4]`、`[EBP+8]` 取堆栈中的参数（“基址指针”=以栈基为基准计算参数地址，避免ESP因压栈/出栈变动导致地址错乱）；<br>3. **搭配SS**：同ESP，`SS:EBP` 定位栈基地址 |
| EIP | Extended Instruction Pointer | Instruction=指令，Pointer=指针 | 32位 | 1. **指向_next指令**：“next指令”=CPU即将执行的下一条指令的偏移地址；<br>2. **自动递增**：CPU执行完当前指令后，EIP自动加上当前指令的长度（如MOV AL, 30H占2字节，EIP+2）；<br>3. **不可直接修改**：不能用MOV指令改EIP（如`MOV EIP, 1000H`错误），只能通过转移指令（JMP/CALL/RET）间接修改；<br>4. **搭配CS**：`CS:EIP` 是下一条指令的完整地址（CS=段地址，EIP=偏移地址） |

*   **补充**：FLAGS（标志寄存器）=Status Flag Register（状态标志寄存器），是16位寄存器，每一位对应一个“标志位”（如CF/ZF），存储指令执行后的状态（如加法是否有进位），后续指令（如Jxx）依赖其判断。

#### 4. 段寄存器（内存分段管理，逐寄存器逐字段拆解）

*   **段**：将1MB内存（实地址模式）分成若干个64KB的“段”（“段”=内存的一部分，类似文件夹分类文件），段寄存器存储每个段的“段地址”（段的起始地址的高12位）。
*   **核心作用**：解决16位寄存器寻址范围不足（16位最大64KB）的问题，通过“段地址+偏移地址”实现1MB内存访问。
*   **逐寄存器拆解**：

| 段寄存器 | 英文全称 | 字面含义 | 位数 | 核心用途（逐字解释） | 能否直接赋值（底层原因） |
| :--- | :--- | :--- | :--- | :--- | :--- |
| CS | Code Segment | Code=代码，Segment=段 | 16位 | 指向「代码段」：代码段是存放程序指令（如MOV、ADD）的内存段，`CS:EIP` 定位当前要执行的指令 | **不能**（底层原因：CS直接关联程序执行地址，若允许`MOV CS, AX`，可能导致程序跳转到非法地址崩溃，CPU硬件限制禁止直接修改） |
| DS | Data Segment | Data=数据，Segment=段 | 16位 | 指向「数据段」：数据段是存放变量（如VAR DB 30H）的内存段，默认访问内存时（如`[BX]`）用DS作为段地址 | 能，但不能直接接立即数/段名（底层原因：段寄存器是16位，但CPU不支持立即数直接写入段寄存器，需通过通用寄存器中转，如`MOV AX, 2000H` → `MOV DS, AX`） |
| ES | Extra Segment | Extra=额外的，Segment=段 | 16位 | 指向「附加段」：辅助数据段，常用于串操作指令（如MOVS）的目的串（默认`ES:DI`指向目的串） | 同DS（需寄存器中转赋值） |
| SS | Stack Segment | Stack=堆栈，Segment=段 | 16位 | 指向「堆栈段」：堆栈段是存放堆栈数据（PUSH压入的数据、子程序返回地址）的内存段，`SS:ESP` 定位栈顶 | 同DS（需寄存器中转赋值，赋值后需确保堆栈地址在1MB内） |
| FS/GS | 无固定全称 | 额外扩展段 | 16位 | 现代CPU扩展的附加段，用于多线程、调试等场景，考试不涉及 | 忽略 |

#### 5. 特殊搭配（逐搭配逐字解释）

*   **SS:ESP**：
    *   SS=Stack Segment（堆栈段地址），ESP=Stack Pointer（栈顶偏移地址）；
    *   “搭配”=两者联合才能唯一确定栈顶的物理地址（物理地址=SS×16+ESP）；
    *   例：SS=2000H，ESP=0004H → 栈顶物理地址=2000H×16+0004H=20004H。
*   **SS:EBP**：
    *   SS=堆栈段地址，EBP=Base Pointer（栈基偏移地址）；
    *   用于子程序中，EBP固定指向栈基（子程序调用时压入返回地址后的栈顶），后续访问堆栈参数/局部变量时，地址基于EBP计算（如`[EBP+4]`是第一个参数），不受ESP变动影响（ESP可能因压入局部变量改变）。
*   **CS:EIP**：
    *   CS=Code Segment（代码段地址），EIP=Instruction Pointer（下一条指令偏移地址）；
    *   是CPU执行指令的“核心地址”，CPU通过`CS:EIP`取出下一条指令，执行后自动更新EIP，实现程序顺序执行；
    *   转移指令（如JMP）通过修改CS和/或EIP，改变程序执行流程（如`JMP LABEL`修改EIP为LABEL的偏移地址）。

### 二、存储器组织（实地址模式为唯一考点，逐术语拆解）

#### 1. 存储规则及表示（逐术语、逐规则拆解）

*   **存储器**：CPU外部的「内存单元」（“存储”=长期存放程序和数据，区别于寄存器的临时存放），实地址模式下容量为1MB（00000H~FFFFFH，共1048576字节）。
*   **存储规则（小端序）**：
    *   **小端序（Little-Endian）**：“小端”=低字节（数据的低位字节），“序”=存储顺序；
    *   **定义**：多字节数据（字/双字）存入内存时，低字节存低地址，高字节存高地址（x86架构强制规则，无例外）；
    *   **逐字解释关键术语**：
        *   **低字节**：数据的二进制低位对应的字节（如1234H，二进制`1001000110100B`，低8位是`00110100B=34H`，即低字节）；
        *   **高字节**：数据的二进制高位对应的字节（1234H的高8位是`00010010B=12H`，即高字节）；
        *   **低地址**：内存地址数值较小的单元（如0000H比0001H低）；
        *   **高地址**：内存地址数值较大的单元（如0001H比0000H高）；
    *   **实例（二进制级拆解）**：`VAR DW 1234H` （字变量，值=1234H=`0001 0010 0011 0100B`），起始偏移地址=0000H：
        *   低地址0000H：存储低字节34H=`0011 0100B`（低8位）；
        *   高地址0001H：存储高字节12H=`0001 0010B`（高8位）；
        *   验证：从内存读取时，0000H取34H，0001H取12H，组合为1234H，还原原数据。
*   **存储表示（按长度分类，逐类型拆解）**：

| 类型 | 长度 | 表示符号（伪指令） | 字面含义 | 取值范围（二进制/十进制/十六进制） | 用途（逐点解释） |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 字节 | 8位 | BYTE（DB） | 字=8位（1字节=8个二进制位），Byte=字节 | 二进制：`00000000B`~`11111111B`<br>无符号十进制：0~255<br>有符号十进制：-128~+127<br>十六进制：00H~FFH | 1. **存储字符**：如'A'的ASCII码是41H（8位），适合用字节存储；<br>2. **存储短整数**：范围-128~+127的整数（如年龄、分数）；<br>3. **节省内存**：无需大空间时用字节，减少内存占用 |
| 字 | 16位 | WORD（DW） | 字=2字节=16位，Word=字 | 二进制：`0000000000000000B`~`1111111111111111B`<br>无符号十进制：0~65535<br>有符号十进制：-32768~+32767<br>十六进制：0000H~FFFFH | 1. **存储中整数**：范围-32768~+32767的整数（如工资、数量）；<br>2. **存储偏移地址**：实地址模式下偏移地址是16位，用字存储；<br>3. **普通运算**：16位数据运算（如AX是字寄存器，配合字变量） |
| 双字 | 32位 | DWORD（DD） | 双字=4字节=32位，Double Word=双字 | 二进制：32个0~32个1<br>无符号十进制：0~4294967295<br>有符号十进制：-2147483648~+2147483647<br>十六进制：00000000H~FFFFFFFFH | 1. **存储长整数**：大范围整数（如身份证号、时间戳）；<br>2. **存储物理地址**：保护模式下物理地址是32位，用双字存储；<br>3. **32位运算**：EAX是双字寄存器，配合双字变量运算 |
#### 2. 物理地址生成方式（仅考实地址模式，逐公式、逐术语拆解）

*   **物理地址**：内存单元的「唯一绝对地址」（“物理”=硬件层面的实际地址，区别于“逻辑地址”=段地址+偏移地址），实地址模式下范围 `00000H`~`FFFFFH`（1MB）。
*   **核心公式**（逐部分拆解）：`物理地址 = 段地址 × 16 + 偏移地址`
    *   **段地址**：由段寄存器（`CS`/`DS`/`ES`/`SS`）提供的16位地址（如`DS=1234H`），“段地址”=内存段的起始地址的高12位（×16后左移4位，覆盖1MB地址）。
    *   **×16**：等价于「左移4位」（二进制左移4位=数值×16），原因：段地址是16位，左移4位后变成20位（16位+4位），刚好匹配20位物理地址（1MB=2²⁰字节）。
    *   **偏移地址**：16位地址（`0000H`~`FFFFFH`），“偏移”=相对于段起始地址的偏移量（如段地址×16=20000H，偏移地址=1234H，则实际地址=20000H+1234H=21234H）。
*   **实例**（二进制级验证）：`DS=1234H`（段地址），偏移地址=`5678H`
    1.  段地址×16：`1234H`=`0001 0010 0011 0100B` → 左移4位=`0001 0010 0011 0100 0000B`=`12340H`；
    2.  加偏移地址：`12340H + 5678H`=`179B8H`（物理地址）；
    3.  结果：CPU通过`179B8H`访问内存单元，取出数据。
*   **关键限制**（底层原因）：
    *   段地址×16后必须≤`FFFF0H`（因为偏移地址最大`FFFFH`，物理地址最大`FFFF0H+FFFFH=FFFFFH`）。
    *   偏移地址必须是16位（`0000H`~`FFFFFH`），超出则寻址错误（如偏移地址=`10000H`，超出16位，非法）。

#### 3. 存储模型（3种，逐模型逐术语拆解）

*   **存储模型**：「内存的管理方式」（“模型”=组织内存的规则），考试要求掌握定义及区别：

| 存储模型 | 核心定义（逐字解释） | 适用场景（底层原因） | 考试要求 |
| :--- | :--- | :--- | :--- |
| **平展模型** | 平展=内存是连续的“平面”（无分段），逻辑地址=物理地址（“平展”=无层级，直接访问） | 32/64位保护模式（如Windows）：内存容量大（4GB以上），分段会降低效率，平展模型直接用32/64位地址访问 | 了解定义（考试不考计算，仅判断对错） |
| **段式模型** | 段式=将内存分成多个“独立段”（代码段、数据段等），每个段有独立的段地址，通过“段地址+偏移地址”访问（“段式”=按功能分段管理） | 16/32位模式：内存容量较小（1MB~4GB），分段可实现多程序共享内存（不同程序用不同段地址，避免冲突） | 掌握核心逻辑（结合实地址模式理解分段的必要性） |
| **实地址模型** | 实地址=实际物理地址，是段式模型的“简化版”（16位），段地址×16+偏移地址生成1MB物理地址，段长度最大64KB（偏移地址`0000H`~`FFFFH`） | 16位实地址模式（如DOS系统）：兼容8086CPU，老程序依赖此模型，汇编考试所有题目基于此 | 重点掌握（所有存储器相关考题的基础） |

#### 4. 工作方式（2种，逐方式逐术语拆解）

*   **工作方式**：CPU访问内存、执行指令的「模式」（“方式”=CPU的工作规则），仅考实地址模式：

| 工作方式 | 核心特点（逐点逐字解释） | 考试关联 |
| :--- | :--- | :--- |
| **实地址模式** | 1. **16位操作**：寄存器、指令均按16位设计（兼容8086CPU的16位架构）；<br>2. **内存1MB**：物理地址范围`00000H`~`FFFFFH`（1MB=1024KB=1048576字节）；<br>3. **单任务**：同一时间只能运行一个程序（“单任务”=CPU资源全给一个程序，无多程序切换）；<br>4. **无内存保护**：程序可访问任意内存地址（无权限限制，“无保护”=可能修改其他程序数据导致崩溃）；<br>5. **兼容8086指令集**：仅支持8086CPU的基础指令（如`MOV`、`ADD`），不支持复杂指令（如SIMD指令） | 所有考题均基于此模式（物理地址计算、指令执行、程序编写） |
| **保护模式** | 1. **32/64位操作**：支持32/64位寄存器和指令（如`EAX`、`EDX`是32位）；<br>2. **内存4GB以上**：32位保护模式支持4GB内存（2³²字节），64位支持更大容量；<br>3. **多任务**：同一时间可运行多个程序（CPU分时切换，“多任务”=提高资源利用率）；<br>4. **内存保护**：程序只能访问自身权限内的内存（“保护”=避免越权访问，提高稳定性）；<br>5. **段描述符表**：段地址需通过“段描述符表”解析（段描述符存储段的基地址、长度、权限） | 了解即可（考试不涉及，仅区分实地址模式） |

## 第2页：编程结构（程序格式 + 开发过程）

### 一、汇编语言程序格式（编程题必考，逐行逐字段拆解）

#### 1. 程序框架（逐行解释，含每个关键字、指令的含义）

*   **核心原则**：完整程序从数据段开始写（“数据段”=存放变量，“代码段”=使用变量，先定义后使用，顺序不能颠倒）。
*   **标准框架**（逐行拆解，含底层逻辑）：

```assembly
; 1. 数据段定义（存放变量、常量，必须在代码段前）
DATA SEGMENT          ; DATA：数据段名（自定义，英文大写，见名知义）；SEGMENT：段开始伪指令（“SEGMENT”=段的起始）
    VAR DB 10H        ; VAR：变量名（自定义）；DB：字节定义伪指令（“DB”=Define Byte，定义1字节）；10H：变量初始值（16进制，可省略，省略则初始值不确定）
    SUM DW ?          ; SUM：变量名（用于存储结果）；DW：字定义伪指令（“DW”=Define Word，定义2字节）；?：表示初始值为空（汇编时分配内存，但不赋值）
    STR DB 'HELLO$'   ; STR：字符串变量名；DB：字节定义（每个字符占1字节）；'HELLO'：字符串（每个字符对应ASCII码，H=48H、E=45H等）；$：字符串结束符（DOS中断识别结束的标志，必须加）
DATA ENDS             ; DATA：与段开始的段名一致（不能错）；ENDS：段结束伪指令（“ENDS”=段的终止，与SEGMENT成对）

; 2. 代码段定义（存放执行指令，必须关联段寄存器）
CODE SEGMENT          ; CODE：代码段名（自定义）；SEGMENT：段开始伪指令
    ASSUME CS:CODE, DS:DATA  ; ASSUME：段关联伪指令（“ASSUME”=假设，告诉汇编器段寄存器与段的对应关系）；CS:CODE：CS寄存器对应代码段CODE（指令存放的段）；DS:DATA：DS寄存器对应数据段DATA（变量存放的段）
START:                ; START：程序入口标号（“标号”=指令的地址别名，汇编器会记录其偏移地址）；必须有（END指令需指向此标号）
    ; 初始化数据段（必考！DS不能直接赋值，需用AX中转）
    MOV AX, DATA      ; MOV：数据传送指令；AX：通用寄存器（中转用）；DATA：数据段名（汇编时会替换为数据段的段地址）；作用：将数据段地址送入AX
    MOV DS, AX        ; MOV：数据传送指令；DS：数据段寄存器；AX：存放数据段地址；作用：将AX中的段地址送入DS，完成数据段初始化（DS指向数据段，才能访问变量）
    
    ; 程序核心代码（根据题目需求编写，如赋值、运算等）
    MOV AL, VAR       ; MOV：数据传送；AL：8位寄存器；VAR：变量名（汇编时替换为偏移地址）；作用：将VAR变量的值（10H）送入AL
    ADD AL, 20H       ; ADD：加法指令；AL：目的操作数（累加和）；20H：立即数；作用：AL=10H+20H=30H
    MOV SUM, AX       ; MOV：数据传送；SUM：字变量；AX：存放结果（AL=30H，AH=00H，AX=0030H）；作用：将结果送入SUM变量
    
    ; 程序退出（实地址模式下DOS系统的标准退出方式，必考！）
    MOV AH, 4CH       ; MOV：数据传送；AH：8位高字节寄存器；4CH：DOS中断功能号（“4CH”=程序退出功能，固定值）
    INT 21H           ; INT：中断指令（“INT”=Interrupt，触发中断）；21H：DOS中断向量号（“21H”=DOS系统中断，CPU调用DOS系统功能）；作用：触发DOS中断，执行退出功能，程序正常结束
CODE ENDS             ; CODE：与段开始的段名一致；ENDS：段结束伪指令
END START             ; END：程序结束伪指令（“END”=汇编结束，告诉汇编器停止汇编）；START：程序入口标号（汇编器从START开始生成指令，确定程序执行起点）
```

*   **考试必记易错点**（逐点解释原因）：
    1.  **漏写`ASSUME`伪指令**：汇编器不知道段寄存器对应哪个段，访问变量时会报错（如找不到`VAR`的段地址）。
    2.  **直接写 `MOV DS, DATA`**：错误原因：段寄存器不能直接接收段名（`DATA`是段名，汇编时是符号，不是数值），必须通过`AX`中转。
    3.  **漏写程序入口`START`**：`END`伪指令无指向，汇编器不知道程序从哪里开始执行，生成的`.exe`文件无法运行。
    4.  **漏写程序退出指令（`MOV AH,4CH`+`INT21H`）**：程序执行完核心代码后，会继续执行后续内存中的垃圾指令，导致程序崩溃（DOS系统需要显式退出）。

#### 2. 完整程序与程序段的区别（逐词解释）

*   **完整程序**：包含「数据段+代码段+段定义+初始化+退出」的完整结构（“完整”=可直接汇编、链接生成`.exe`文件运行）。
*   **适用场景**：应用题中明确要求“编写完整程序”。
*   **程序段**：仅包含「核心逻辑指令」（如`MOV`、`ADD`），省略段定义、`ASSUME`、初始化、退出指令（“程序段”=完整程序的一部分，不可单独运行）。
*   **适用场景**：应用题中要求“编写程序段实现XX功能”。
*   **例**：实现`AL=VAR+20H`的程序段：`MOV AL, VAR; ADD AL, 20H` （无需段定义和初始化）。

### 二、开发过程（逐步骤、逐软件、逐文件拆解）

#### 1. 开发步骤（4步，按顺序逐步拆解，含每个步骤的目的）

*   **步骤1：编写源程序（第1步）**
    *   **操作**：用文本编辑器（如记事本）编写`.asm`格式的源文件，输入汇编语言代码（如上述标准框架）。
    *   **目的**：将程序逻辑用汇编语言（人类可阅读的指令）记录下来。
    *   **关键**：文件名自定义（如`TEST.asm`），后缀必须是`.asm`（“asm”=Assembly Language，汇编语言的缩写），保存为纯文本格式（不能是Word文档）。
*   **步骤2：汇编（第2步）**
    *   **操作**：用汇编器（如MASM）对`.asm`源文件执行汇编命令（如 `MASM TEST.ASM`）。
    *   **目的**：将汇编语言代码（人类可读）转换为机器码（CPU可执行的二进制代码）。
    *   **关键**：检查语法错误（如指令写错、伪指令缺失），无错误则生成`.obj`目标文件；若有错误（如`MOV`写成`MOVV`），汇编器会提示错误行号和原因，需修改源程序后重新汇编。
*   **步骤3：链接（第3步）**
    *   **操作**：用链接器（如Link）对`.obj`目标文件执行链接命令（如 `LINK TEST.OBJ`）。
    *   **目的**：将`.obj`文件中的机器码与系统库（如DOS中断服务程序）链接，解决外部符号引用（如多个`.obj`文件共享变量），生成可执行文件。
    *   **关键**：无链接错误则生成`.exe`文件；若有错误（如子程序未定义），链接器提示后需修改源程序重新汇编、链接。
*   **步骤4：运行与调试（第4步）**
    *   **操作**：双击`.exe`文件运行，或用调试器（如Debug）执行调试命令（如 `DEBUG TEST.EXE`）。
    *   **目的**：验证程序功能是否正确，排查逻辑错误（如结果错误、程序崩溃）。
    *   **关键**：调试时可单步执行（T命令）、查看寄存器（R命令）、查看内存（D命令）、查看堆栈（S命令），定位错误后修改源程序，重复步骤2~4直到程序正常运行。

#### 2. 使用的软件（逐软件拆解，含功能、操作命令）

| 开发步骤 | 软件名称 | 英文全称 | 核心功能（逐点解释） | 常用操作命令 |
| :--- | :--- | :--- | :--- | :--- |
| 编写源程序 | 记事本 | Notepad | 1. 纯文本编辑（仅支持文字输入，无格式）；<br>2. 保存为`.asm`文件（后缀必须手动输入）；<br>3. 免费内置（Windows系统自带，无需额外安装） | 新建→输入代码→文件→保存→文件名输入“TEST.asm”→保存类型选“所有文件” |
| 汇编 | MASM | Microsoft Macro Assembler | 1. 语法检查：检查源程序中的指令、伪指令是否符合语法规则；<br>2. 生成机器码：将合法的汇编指令转换为CPU可执行的二进制机器码；<br>3. 生成`.obj`文件：将机器码存入`.obj`目标文件（二进制格式） | 命令行输入：`MASM TEST.ASM` （回车后按3次回车，生成`TEST.OBJ`） |
| 链接 | Link | Microsoft Linker | 1. 链接系统库：将`.obj`文件与DOS系统库（如INT 21H的实现代码）合并；<br>2. 解决外部引用：若源程序调用了其他`.obj`文件的子程序，链接器会找到对应的代码并合并；<br>3. 生成`.exe`文件：将链接后的机器码存入`.exe`可执行文件 | 命令行输入：`LINK TEST.OBJ` （回车后按3次回车，生成`TEST.EXE`） |
| 调试 | Debug | DOS Debugger | 1. 单步执行：T命令（Trace），逐条执行指令，观察每步的寄存器/内存变化；<br>2. 查看寄存器：R命令（Register），显示所有寄存器的值，可修改寄存器（如 `R AX`）；<br>3. 查看内存：D命令（Dump），显示指定地址的内存数据（如 `D DS:0` 查看数据段起始内存）；<br>4. 查看堆栈：S命令（Stack），显示堆栈段的数据（如 `S SS:ESP` 查看栈顶）；<br>5. 运行程序：G命令（Go），直接运行程序到断点或结束 | 命令行输入：`DEBUG TEST.EXE` （进入调试模式后输入相关命令） |

#### 3. 生成的文件（3类核心文件，逐文件拆解，含格式、用途、关联）

| 文件后缀 | 英文全称 | 生成步骤 | 文件格式 | 核心用途（逐点解释） | 与其他文件的关联 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `.asm` | Assembly Source File | 编写源程序 | 纯文本格式（ASCII码） | 1. 存储汇编语言代码（人类可阅读、可修改）；<br>2. 作为汇编器的输入文件（汇编的依据）；<br>3. 便于程序维护（修改时直接编辑`.asm`文件） | 是`.obj`文件的“源文件”，`.asm`→汇编→`.obj` |
| `.obj` | Object File | 汇编 | 二进制格式（机器码+符号表） | 1. 存储汇编后的机器码（CPU可执行，但不完整）；<br>2. 包含符号表（记录变量、标号的地址）；<br>3. 作为链接器的输入文件（链接的依据） | 是`.asm`文件的“中间产物”，`.obj`→链接→`.exe` |
| `.exe` | Executable File | 链接 | 二进制格式（完整机器码+系统信息） | 1. 可直接运行（DOS/Windows系统识别并执行）；<br>2. 包含完整的机器码（程序逻辑）和系统信息（如程序入口地址）；<br>3. 是开发的最终产物（用户使用的文件） | 是`.obj`文件的“最终产物”，`.exe`可直接运行，无需依赖`.asm`和`.obj`文件 |

*   **补充文件**：`.lst`（List File，列表文件），汇编时可选生成，包含源程序、机器码、地址的对应关系（如每一行汇编指令对应的机器码和偏移地址），考试不考，仅用于调试。

## 第3页：寻址方式（逐类、逐术语、逐指令拆解）

寻址方式是「找到指令中操作数地址的方法」（“寻址”=寻找地址，“方式”=方法），分两类：与数据有关（找数据地址）、与转移地址有关（找指令地址）。

### 一、与数据有关的寻址（3大类，逐类逐术语逐指令拆解）

#### 1. 立即寻址（Immediate Addressing）

*   **定义**（逐字解释）：操作数是「立即数」（“立即”=指令中直接给出，无需寻找，取数立即），直接嵌入指令中，CPU执行时从指令中直接获取操作数，无需访问寄存器/内存。
*   **格式**（逐字段解释）：`MOV 目的操作数, 立即数`
    *   **目的操作数**：接收数据的对象（必须是寄存器或内存，不能是立即数）。
    *   **立即数**：固定数值（如`10H`、`3456H`、`'A'`），可以是二进制（后缀B）、十进制（默认）、十六进制（后缀H）、字符（单引号括起，对应ASCII码）。
*   **实例**（逐指令拆解，含二进制）：
    *   `MOV AL, 30H`：
        *   目的操作数：`AL`（8位寄存器）。
        *   立即数：`30H`=`00110000B`（ASCII码对应`'0'`）。
        *   寻址方式：立即寻址（`30H`在指令中，直接取数）。
        *   执行结果：`AL`=`30H`。
    *   `MOV CX, 1234H`：
        *   立即数：`1234H`=`0001001000110100B`。
        *   执行结果：`CX`=`1234H`。
    *   `MOV BL, 'A'`：
        *   立即数：`'A'`的ASCII码=`41H`=`01000001B`。
        *   执行结果：`BL`=`41H`。
*   **核心特点**（底层原因）：
    *   **取数最快**：数据在指令中，CPU取指令时同时取操作数，无需额外访问寄存器/内存（寄存器访问需1个时钟周期，内存需多个，立即数无需额外周期）。
    *   **不能作为目的操作数**：立即数是固定数值，不是存储单元（如 `MOV 30H, AL` 错误，`30H`是数值，不能接收数据）。

#### 2. 寄存器寻址（Register Addressing）

*   **定义**（逐字解释）：操作数存放在「通用寄存器」或「段寄存器」中（“寄存器”=存储单元，“寻址”=寻找寄存器的地址），指令中直接写寄存器名，CPU执行时从寄存器中获取操作数。
*   **格式**（逐字段解释）：`MOV 目的寄存器, 源寄存器` 或 `MOV 寄存器, 立即数`（结合立即寻址）。
    *   **目的寄存器**：接收数据的寄存器（如`AX`、`BX`）。
    *   **源寄存器**：提供数据的寄存器（如`CX`、`DX`）。
    *   **寄存器类型**：通用寄存器（`EAX`~`EDX`、`BX`等）、段寄存器（`DS`、`ES`等），需类型匹配。
*   **实例**（逐指令拆解）：
    *   `MOV AX, BX`：
        *   目的寄存器：`AX`（16位）。
        *   源寄存器：`BX`（16位）。
        *   寻址方式：寄存器寻址（操作数在`BX`中）。
        *   执行结果：`AX`=`BX`的值（`BX`的值复制到`AX`，`BX`不变）。
    *   `ADD ECX, EDX`：
        *   目的寄存器：`ECX`（32位）。
        *   源寄存器：`EDX`（32位）。
        *   寻址方式：寄存器寻址。
        *   执行结果：`ECX`=`ECX`+`EDX`的值。
    *   `MOV DS, AX`：
        *   目的寄存器：`DS`（段寄存器）。
        *   源寄存器：`AX`（通用寄存器）。
        *   寻址方式：寄存器寻址。
        *   执行结果：`DS`=`AX`的值（初始化数据段）。
*   **核心特点**（底层原因）：
    *   **取数快**：寄存器在CPU内部，访问速度仅次于立即数（比内存快10~100倍）。
    *   **操作数可作目的/源**：寄存器是存储单元，可接收数据（目的）或提供数据（源）。
    *   **必须类型匹配**：寄存器位数需与数据位数一致（如 `MOV AL, AX` 错误，`AL`是8位，`AX`是16位，类型不匹配，CPU无法执行）。

#### 3. 存储器寻址（Memory Addressing，重点+难点）

*   **定义**（逐字解释）：操作数存放在「内存单元」中（“存储器”=内存，“寻址”=寻找内存单元的地址），需通过“段地址+偏移地址”定位内存单元，CPU执行时从内存中获取操作数。
*   **核心前提**：默认段地址在`DS`寄存器（如`[BX]`的段地址=`DS`），若用`BP`寄存器作基址（如`[BP]`），段地址默认在`SS`寄存器（堆栈段）；若需用其他段寄存器，需加「段超越前缀」（如 `ES:[BX]`，段地址=`ES`）。
*   **5种类型**（逐类拆解格式、偏移地址公式、实例、底层逻辑）：

| 寻址类型 | 格式（逐字段解释） | 偏移地址计算公式（逐符号解释） | 实例（逐指令拆解） | 考试注意事项 |
| :--- | :--- | :--- | :--- | :--- |
| **直接寻址** | `MOV 寄存器, [偏移地址]` 或 `MOV 寄存器, 变量名` | 偏移地址 = 指令中的直接地址（或变量名对应的偏移地址）<br>“直接地址”=指令中明确给出的16位地址（如`1000H`）；“变量名对应的偏移地址”=汇编时给变量分配的偏移地址（如`VAR`的偏移地址=`0000H`） | 例1：`MOV AL, [1000H]`<br>- 段地址=`DS`（默认）；<br>- 偏移地址=`1000H`；<br>- 物理地址=`DS`×16+`1000H`；<br>- 执行结果：`AL`=物理地址对应内存单元的字节数据；<br>例2：`MOV AX, VAR` （`VAR DW 1234H`，偏移地址=`0000H`）<br>- 偏移地址=`VAR`的偏移地址=`0000H`；<br>- 物理地址=`DS`×16+`0000H`；<br>- 执行结果：`AX`=`1234H`（内存`0000H`=`34H`，`0001H`=`12H`） | 变量名本质是“直接地址的别名”（汇编时变量名替换为偏移地址），如`MOV AX, VAR` 等价于 `MOV AX, [0000H]` （`VAR`的偏移地址=`0000H`）；<br>直接地址必须是16位（`0000H`~`FFFFFH`），超出则非法。 |
| **寄存器间接寻址** | `MOV 寄存器, [基址/变址寄存器]` | 偏移地址 = 寄存器的值<br>“基址/变址寄存器”=仅允许`BX`、`SI`、`DI`、`BP`（CPU硬件限制，其他寄存器如`AX`不能作间址寄存器） | 例1：`MOV AL, [BX]` （`BX`=`2000H`，`DS`=`1000H`）<br>- 偏移地址=`BX`的值=`2000H`；<br>- 物理地址=`1000H`×16+`2000H`=`12000H`；<br>- 执行结果：`AL`=`12000H`对应内存单元的字节数据；<br>例2：`MOV AX, [BP]` （`BP`=`0004H`，`SS`=`3000H`）<br>- 段地址=`SS`（`BP`作基址，默认堆栈段）；<br>- 偏移地址=`BP`的值=`0004H`；<br>- 物理地址=`3000H`×16+`0004H`=`30004H`；<br>- 执行结果：`AX`=`30004H`对应内存单元的字数据 | 间址寄存器只能是`BX`、`SI`、`DI`、`BP`（如 `MOV AL, [AX]` 错误，`AX`不能作间址寄存器）；<br>用`BP`时段地址=`SS`，其他间址寄存器段地址=`DS`。 |
| **寄存器相对寻址** | `MOV 寄存器, [寄存器+位移量]` 或 `MOV 寄存器, 变量名[寄存器]` | 偏移地址 = 寄存器的值 + 位移量<br>“位移量”=指令中给出的8位/16位立即数（如`10H`、`-5H`）或变量名（变量名的偏移地址作为位移量） | 例1：`MOV AL, [BX+10H]` （`BX`=`2000H`，`DS`=`1000H`）<br>- 偏移地址=`2000H`+`10H`=`2010H`；<br>- 物理地址=`1000H`×16+`2010H`=`12010H`；<br>- 执行结果：`AL`=`12010H`对应内存单元的字节数据；<br>例2：`MOV AX, VAR[SI]` （`VAR`偏移地址=`0000H`，`SI`=`0002H`，`DS`=`1000H`）<br>- 偏移地址=`0000H`+`0002H`=`0002H`；<br>- 物理地址=`1000H`×16+`0002H`=`10002H`；<br>- 执行结果：`AX`=`10002H`对应内存单元的字数据 | 位移量可正可负（如 `[BX-5H]` ，偏移地址=`BX`-`5H`）；<br>常用于访问数组元素（变量名是数组起始地址，寄存器是索引，位移量=起始地址+索引）。 |
| **基址变址寻址** | `MOV 寄存器, [基址寄存器+变址寄存器]` | 偏移地址 = 基址寄存器的值 + 变址寄存器的值<br>“基址寄存器”=`BX`、`BP`；“变址寄存器”=`SI`、`DI`（必须两两组合，不能用两个基址或两个变址寄存器） | 例：`MOV AL, [BX+SI]` （`BX`=`2000H`，`SI`=`0010H`，`DS`=`1000H`）<br>- 偏移地址=`2000H`+`0010H`=`2010H`；<br>- 物理地址=`1000H`×16+`2010H`=`12010H`；<br>- 执行结果：`AL`=`12010H`对应内存单元的字节数据 | 基址寄存器只能是`BX`、`BP`，变址寄存器只能是`SI`、`DI`（如 `[BX+BX]` 错误，两个基址寄存器）；<br>段地址规则：基址寄存器是`BP`则段地址=`SS`，是`BX`则段地址=`DS`。 |
| **相对基址变址寻址** | `MOV 寄存器, [基址+变址+位移量]` 或 `MOV 寄存器, 变量名[基址+变址]` | 偏移地址 = 基址寄存器的值 + 变址寄存器的值 + 位移量<br>“位移量”=立即数或变量名的偏移地址 | 例：`MOV AX, [BX+SI+20H]` （`BX`=`2000H`，`SI`=`0010H`，`DS`=`1000H`）<br>- 偏移地址=`2000H`+`0010H`+`20H`=`2030H`；<br>- 物理地址=`1000H`×16+`2030H`=`12030H`；<br>- 执行结果：`AX`=`12030H`对应内存单元的字数据 | 最复杂的存储器寻址，常用于访问二维数组（基址=行索引，变址=列索引，位移量=数组起始地址）。 |

*   **考试判断技巧**（逐步判断）：
    1.  看操作数是否在内存中（指令中有`[ ]`或变量名，且不是立即数/寄存器）→ 存储器寻址。
    2.  看偏移地址组成：
        *   仅直接地址/变量名 → 直接寻址。
        *   仅寄存器 → 间接寻址。
        *   寄存器+位移量 → 相对寻址。
        *   基址+变址 → 基址变址寻址。
        *   基址+变址+位移量 → 相对基址变址寻址。
  
### 二、与转移地址有关的寻址（控制转移指令用，逐类拆解）

与转移地址有关的寻址方式是**控制转移类指令**（如`JMP`、`CALL`）寻找**下一条将要执行的指令地址**的方法。

#### 1. 寻址分类（4种组合，段间间接不考，逐类逐术语拆解）

可以从两个维度进行分类：

| 分类维度 | 类型 | 核心定义（逐字解释） | 底层逻辑 |
| :--- | :--- | :--- | :--- |
| **按转移范围** | 段内转移 (Intra-segment) | 转移地址在**当前代码段**内（“段内”=CS寄存器的值不变），仅修改EIP（指令指针寄存器）。 | 当前代码段的段地址=CS，转移目标地址的段地址=CS，无需修改CS，仅修改EIP为目标地址的偏移量。 |
| | 段间转移 (Inter-segment) | 转移地址在**其他代码段**内（“段间”=CS寄存器的值改变），需同时修改CS和EIP。 | 转移目标地址的段地址≠当前CS，需将目标地址的段地址送入CS，偏移地址送入EIP。 |
| **按地址来源** | 直接转移 (Direct) | 转移地址**直接写在指令中**（用标号表示，“直接”=地址在指令里，无需寻找）。 | 标号是转移目标地址的别名，汇编时标号被替换为具体的段地址和/或偏移地址，指令执行时直接使用。 |
| | 间接转移 (Indirect) | 转移地址存放在**寄存器或内存单元**中（“间接”=地址不在指令里，需从寄存器/内存中读取）。 | 指令中写寄存器名或内存地址，执行时先从寄存器/内存中取出目标地址，再修改CS和/或EIP。 |

**核心组合**（实模式下）：
*   **段内直接转移**：目标地址的**偏移量**直接编码在指令中（通过标号）。
*   **段内间接转移**：目标地址的**偏移量**存放在寄存器或内存单元中。
*   **段间直接转移**：目标地址的**段地址和偏移地址**都直接编码在指令中（通过标号）。
*   **段间间接转移**：目标地址的**段地址和偏移地址**存放在内存单元中（考题不涉及）。

#### 2. 寻址方式实例（指令举例，逐指令拆解）

| 寻址方式 | 指令格式 | 示例与拆解 | 执行逻辑与适用场景 |
| :--- | :--- | :--- | :--- |
| **段内直接短转移** | `JMP SHORT LABEL` | `JMP SHORT NEXT`<br>- `JMP`：无条件转移指令。<br>- `SHORT`：短转移操作符，指明转移距离在**-128 到 +127 字节**之间。<br>- `NEXT`：同一代码段内的一个标号。 | **执行**：`EIP = EIP + 偏移量`。偏移量 = `NEXT`的地址 - 下条指令地址，由汇编器计算。<br>**特点**：指令编码短（2字节），速度快。用于短距离跳转。 |
| **段内直接近转移** | `JMP NEAR PTR LABEL`<br>（`NEAR PTR`常省略） | `JMP LOOP_START`<br>- `LOOP_START`：同一代码段内的一个标号。 | **执行**：`EIP = EIP + 偏移量`。偏移量范围为 **-32768 到 +32767 字节**。<br>**特点**：指令编码较长（3-5字节）。用于同一段内较远距离的跳转。 |
| **段内间接转移** | `JMP reg16`<br>`JMP mem16` | 1. `JMP BX` （`BX=1234H`, `CS=2000H`)<br>- 执行：`EIP = BX = 1234H`, `CS`不变。<br>- 目标地址 = `CS:EIP = 2000:1234H`。<br>2. `JMP WORD PTR [SI]` (`SI=0000H`, `DS=3000H`, 内存`[3000:0000]`处字数据=`5678H`)<br>- 执行：从`3000:0000H`取字`5678H`，`EIP=5678H`, `CS`不变。<br>- 目标地址 = `CS:5678H`。 | **执行**：从指定的16位寄存器或内存字单元中取出目标偏移地址，送入`EIP`，`CS`不变。<br>**特点**：转移地址在运行时决定，用于实现**跳转表、动态调用**等。 |
| **段间直接转移** | `JMP FAR PTR LABEL` | `JMP FAR PTR OTHER_SEG_LABEL`<br>- `FAR PTR`：远转移操作符，指明是段间跳转。<br>- `OTHER_SEG_LABEL`：另一个代码段中的标号。 | **执行**：`CS = OTHER_SEG_LABEL`的段地址，`EIP = OTHER_SEG_LABEL`的偏移地址。<br>**特点**：同时修改CS和EIP。用于调用其他段的子程序或跳转到其他段执行。 |

#### 3. 考试重点与易错点

*   **核心判断**：
    *   **段内 vs 段间**：看是否修改`CS`。不修改`CS`（仅`EIP`变）为段内；修改`CS`为段间。
    *   **直接 vs 间接**：看目标地址是否直接编码在指令中。是标号为直接；是寄存器或内存单元为间接。
*   **`Jxx`条件转移指令**：如`JE`、`JNZ`等，**仅支持段内直接短转移**。因为这类指令设计短小（2字节），偏移量范围仅为-128 ~ +127字节。若需更长距离的条件跳转，需组合使用`Jxx`和`JMP`。

## 第4页：指令详解（一）—— 数据传送类指令

数据传送类指令的核心功能是**数据的复制与转移**（“传送”=复制，源操作数不变，目的操作数被覆盖）。此类指令**多数不影响标志位**（`PUSH`/`POP`除外，它们会影响堆栈指针`ESP`），是编程的基础。

### 1. `MOV` 指令（Move，数据传送指令，最核心）

#### （1）指令本质拆解
*   **`MOV`**：英文全称Move（移动），但实际操作是**数据的复制**（源操作数的值被复制到目的操作数，源操作数本身不变）。
*   **核心功能**：将**源操作数**的数值复制到**目的操作数**，覆盖目的操作数的原值。
*   **格式**：`MOV 目的操作数, 源操作数`

#### （2）三条核心规则（考试必考，逐字解释+底层原因）

**规则1：操作数类型（位数）必须匹配**
*   **类型**：指数据的长度（字节`BYTE`/字`WORD`/双字`DWORD`）。
*   **匹配**：目的操作数与源操作数的数据长度必须完全一致。
*   **底层原因**：CPU硬件设计，不同长度的数据无法在同一指令中直接传送。
*   **正确示例**：
    ```assembly
    MOV AL, 30H      ; AL是8位（字节），30H是8位立即数 -> 匹配
    MOV AX, 1234H    ; AX是16位（字），1234H是16位立即数 -> 匹配
    MOV EAX, 12345678H ; EAX是32位（双字），立即数32位 -> 匹配
    ```
*   **错误示例**：
    ```assembly
    MOV AL, 1234H    ; 错误！AL是8位，1234H是16位，数据溢出。
    MOV AX, BL       ; 错误！AX是16位，BL是8位，需显式扩展（如 MOVZX AX, BL）。
    ```

**规则2：不能直接实现“内存 → 内存”传送**
*   **内存→内存**：源操作数和目的操作数**不能同时**是内存操作数。
*   **底层原因**：x86指令集不支持单条指令在两个内存单元间直接传送数据，必须通过寄存器中转。
*   **正确实现**（需两步）：
    ```assembly
    MOV AL, [BX]    ; 第一步：内存[BX] → 寄存器AL
    MOV [SI], AL    ; 第二步：寄存器AL → 内存[SI]
    ```
*   **错误示例**：`MOV [BX], [SI]` -> 汇编器报错“Invalid combination of opcode and operands”。

**规则3：段寄存器的特殊限制**
1.  **源和目的不能同时是段寄存器**。
    *   示例：`MOV DS, ES` -> 错误。
    *   原因：CPU无段寄存器间直接数据通路。需通过通用寄存器：`MOV AX, ES; MOV DS, AX`。
2.  **`CS`（代码段寄存器）不能作为目的操作数**。
    *   示例：`MOV CS, AX` -> 错误。
    *   原因：`CS`直接控制程序执行流，随意修改会导致程序跑飞。只能通过`JMP`、`CALL`、`RET`、`IRET`等指令间接修改。
3.  **段寄存器（`DS`/`ES`/`SS`）不能直接接收立即数**。
    *   示例：`MOV DS, 2000H` -> 错误。`MOV DS, DATA` (`DATA`为段名) -> 错误。
    *   正确做法：通过通用寄存器中转。
        ```assembly
        MOV AX, 2000H  ; 或 MOV AX, DATA
        MOV DS, AX
        ```

#### （3）考试易错点
*   **易错点1**：试图用`MOV`在内存间直接传送数据。**规避**：必须通过寄存器中转。
*   **易错点2**：试图用立即数或段名直接给段寄存器赋值。**规避**：必须通过通用寄存器（如`AX`）中转。
*   **易错点3**：试图修改`CS`寄存器。**规避**：使用`JMP FAR PTR`等控制转移指令。

### 2. `PUSH` / `POP` 指令（堆栈操作指令）

#### （1）堆栈本质与定位
*   **堆栈 (Stack)**：内存中一块遵循**先进后出 (FILO)** 原则的连续区域。
*   **堆栈定位**：由`SS:ESP`共同定位。`SS` (Stack Segment) 是堆栈段寄存器，`ESP` (Stack Pointer) 是栈顶指针，始终指向**最后一个压入数据**的单元（栈顶）。

#### （2）`PUSH` 指令（压栈）
*   **指令含义**：将操作数“推入”堆栈，栈顶指针`ESP`向低地址方向移动，为数据腾出空间。
*   **格式**：`PUSH 源操作数`
*   **操作数**：必须是**16位**或**32位**的寄存器、内存操作数或立即数。**不能是8位**。
*   **32位模式下的操作步骤** (`PUSH src32`)：
    1.  `ESP = ESP - 4` （栈指针下移4字节，预留空间）
    2.  `[SS:ESP] = src32` （将源操作数存入新的栈顶位置）
*   **小端序存储**：数据按字节逆序存入。例如`EAX=12345678H`，则`[SS:ESP]=78H`, `[SS:ESP+1]=56H`, `[SS:ESP+2]=34H`, `[SS:ESP+3]=12H`。

#### （3）`POP` 指令（出栈）
*   **指令含义**：从栈顶“弹出”数据到目的操作数，栈顶指针`ESP`向高地址方向移动，释放空间。
*   **格式**：`POP 目的操作数`
*   **操作数**：必须是**16位**或**32位**的寄存器或内存操作数。**不能是8位**。
*   **32位模式下的操作步骤** (`POP dest32`)：
    1.  `dest32 = [SS:ESP]` （从栈顶取出数据）
    2.  `ESP = ESP + 4` （栈指针上移4字节，释放空间）

#### （4）`PUSH`/`POP` 特点与考试重点
*   **操作数宽度**：必须为字或双字。`PUSH AL`、`POP BL` 是错误的。
*   **堆栈平衡**：`PUSH`和`POP`必须**成对使用**，否则会导致`ESP`错乱，引发程序错误。
*   **对段寄存器的操作**：可以`PUSH`/`POP`段寄存器（`CS`除外，`POP CS`是非法或危险操作）。
*   **应用**：常用于**保存和恢复寄存器现场**、**传递函数参数**、**分配局部变量**。

### 3. `LEA` 指令（Load Effective Address，取有效地址指令）

#### （1）指令本质拆解
*   **`LEA`**：英文全称 Load Effective Address。
    *   `Load`：加载（到寄存器）。
    *   `Effective Address`：有效地址，即内存操作数的**偏移地址**。
*   **核心功能**：计算**源操作数**（必须是一个存储器操作数）的**有效地址**（偏移地址），并将这个**地址值**（而非该地址处的数据）送入目的寄存器。
*   **格式**：`LEA 寄存器, 存储器操作数`

#### （2）`LEA` vs `MOV`：核心区别（考试必考）
| 指令 | 功能本质 | 示例与结果 |
| :--- | :--- | :--- |
| **`LEA`** | **取地址**。计算存储器操作数的偏移地址，并将这个地址值存入寄存器。 | `LEA BX, [SI+10H]`<br>假设`SI=2000H`。<br>**执行**：计算有效地址 = `2000H+10H=2010H`，然后将`2010H`这个数值送入`BX`。<br>**结果**：`BX = 2010H`。 |
| **`MOV`** | **取数据**。获取存储器操作数所指向内存单元中的数据，并将该数据存入寄存器。 | `MOV BX, [SI+10H]`<br>假设`SI=2000H`, `DS=1000H`, 内存地址`1000:2010H`处的字为`3456H`。<br>**执行**：计算物理地址=`1000H*16+2010H=12010H`，取出该地址的字数据`3456H`，送入`BX`。<br>**结果**：`BX = 3456H`。 |

#### （3）`LEA` 的常见用途
1.  **获取变量或数组的起始地址**。
    ```assembly
    LEA SI, ARRAY  ; 将数组ARRAY的偏移地址送入SI
    ```
2.  **进行地址运算**。`LEA`可以在一条指令内完成基础的乘加运算（常用于数组索引计算），且**不消耗ALU标志位**。
    ```assembly
    ; 计算 ARRAY + INDEX*2 的地址 (INDEX 在 BX 中)
    LEA SI, [ARRAY + BX*2] ; SI = ARRAY的地址 + BX*2
    ; 等效但更慢的MOV/ADD实现：
    ; MOV SI, BX
    ; ADD SI, SI  ; SI = BX*2
    ; ADD SI, OFFSET ARRAY
    ```

#### （4）考试易错点
*   **混淆功能**：误以为`LEA`是取数据。牢记`LEA`取的是**地址**，`MOV`取的是该地址处的**数据**。
*   **操作数错误**：源操作数必须是存储器寻址方式（如`[BX]`、`VAR`、`[SI+DI+10H]`），不能是立即数或寄存器。目的操作数必须是寄存器。

### 4. `XLAT` 指令（Translate，查表转换指令）

#### （1）指令本质拆解
*   **`XLAT`**：英文全称**Translate**（转换），意为**根据索引从表格中查找对应值**，实现"索引→值"的映射（如`0`→`'0'`、`1`→`'1'`）。
*   **核心功能**：**字节查表转换**（仅支持字节，不支持字/双字），无需手动计算表格地址，极大简化查表逻辑。
*   **底层依赖**：**固定寄存器搭配**（`BX`=表格基地址，`AL`=索引），CPU硬件设计固定，不可修改。

#### （2）必须满足的3个前提（考试必考，逐点解释）

**前提1：表格定义（字节型表格，`DB`伪指令）**
*   "字节型表格"=表格中每个元素是1字节（必须用`DB`伪指令定义）。
*   "表格"=连续的内存单元（元素按顺序存储）。
*   **实例**：
    ```assembly
    TABLE DB 30H, 31H, 32H, 33H  ; 定义表格，元素为'0','1','2','3'的ASCII码
    ```
*   **存储**：假设`TABLE`的偏移地址=`0000H`，则内存`0000H`=`30H`、`0001H`=`31H`、`0002H`=`32H`、`0003H`=`33H`。

**前提2：`BX`寄存器 = 表格的偏移地址**
*   "表格的偏移地址"=表格在数据段中的起始偏移地址（如`TABLE`的偏移地址=`0000H`）。
*   **赋值方式**：`MOV BX, OFFSET TABLE` （`OFFSET`是取偏移地址运算符）。
*   **底层原因**：`XLAT`指令默认从`BX`获取表格基地址，硬件设计固定，**不可用其他寄存器**（如`CX`）替代。

**前提3：`AL`寄存器 = 表格的索引值**
*   "索引值"=要查找的元素在表格中的**位置**（从0开始计数，即第0项、第1项…）。
*   **限制**：索引值必须是8位（范围`0`~`255`），因此表格长度最大为256字节。
*   **底层原因**：`AL`是8位寄存器，`XLAT`指令仅读取`AL`的低8位作为索引。若`AL`值超出表格长度，则读取无效数据，导致错误。

#### （3）操作过程（唯一逻辑，逐步拆解）
*   **核心逻辑**：`AL = [BX + AL]` （将表格中"`BX`+`AL`"偏移地址对应的**字节数据**，取出并覆盖写入`AL`）。
*   **操作步骤**：
    1.  `BX` 寄存器中存放表格的起始地址。
    2.  `AL` 寄存器中存放要查找的元素的索引（从0开始）。
    3.  执行`XLAT`指令，CPU自动计算 `有效地址 = BX + AL`。
    4.  从该有效地址指向的内存单元读取一个字节。
    5.  将该字节数据写回 `AL` 寄存器。
*   **实例**（承接上述表格定义）：
    ```assembly
    MOV BX, OFFSET TABLE  ; 步骤1：BX=0000H（表格偏移地址）
    MOV AL, 2               ; 步骤2：AL=2（索引值，取第2项，即第3个元素）
    XLAT                    ; 步骤3：计算地址=BX+AL=0000H+2=0002H；从0002H取出32H；AL=32H
    ```
    *   **结果**：`AL=32H`（对应字符`'2'`的ASCII码），成功实现索引`2`→值`'2'`的转换。

#### （4）考试注意事项
*   **注意1**：表格**必须用`DB`定义**（字节型）。用`DW`/`DD`定义会导致数据长度不匹配（`XLAT`仅读取1字节）。
*   **注意2**：寄存器搭配**不能错**（`BX`=地址，`AL`=索引）。错用其他寄存器（如用`CX`存放地址）会导致查表失败。
*   **注意3**：索引值**不能超出表格实际长度**（如表格长度=4，`AL=4`则会读取内存`0004H`的随机数据，结果错误）。

## 第5页：指令详解（二）—— 算术运算类指令

算术运算类指令的核心是**数值的加减运算**，多数会影响标志位（CF/ZF/SF/OF/AF/PF），标志位是后续分支/循环指令的判断依据。

### 1. 核心指令（`ADD`/`SUB`/`INC`/`DEC`/`CMP`，逐指令拆解）

#### （1）`ADD` 指令（Add，加法指令）
*   **指令本质**：“Add”=加，将**源操作数**的值与**目的操作数**的值相加，结果存入**目的操作数**（覆盖原有值）。
*   **格式**：`ADD 目的操作数, 源操作数`
*   **操作数类型**：支持寄存器-寄存器、寄存器-立即数、寄存器-内存、内存-立即数（**不支持内存-内存**，同`MOV`规则）。
*   **实例**（逐步拆解，`AL=30H`，`BL=20H`）：
    ```assembly
    ADD AL, BL
    ```
    *   **执行过程**：`30H`（`AL`）+ `20H`（`BL`）= `50H`；将`50H`存入`AL`。
    *   **结果**：`AL=50H`，`BL=20H`（源操作数不变）。
*   **对标志位的影响**（逐位解释）：
    *   **CF（进位标志）**：`0`（无进位，`50H`未超出8位无符号数范围0~255）。
    *   **ZF（零标志）**：`0`（结果`50H`≠0）。
    *   **SF（符号标志）**：`0`（结果最高位=0，正数）。
    *   **OF（溢出标志）**：`0`（结果`50H`在8位有符号数范围-128~+127内）。
    *   **AF（半进位标志）**：`0`（低4位`0`+`0`=0，无进位到高4位）。
    *   **PF（奇偶标志）**：`1`（结果二进制`101000`，含2个1，偶数个）。
*   **易错点**：
    *   `ADD DS, AX` → 错误（段寄存器不能直接参与算术运算）。
    *   `ADD AL, AX` → 错误（类型不匹配，`AL`是8位，`AX`是16位）。

#### （2）`SUB` 指令（Subtract，减法指令）
*   **指令本质**：“Subtract”=减，将**目的操作数**的值减去**源操作数**的值，结果存入**目的操作数**。
*   **底层逻辑**：减法等价于“目的操作数 + （-源操作数的补码）”（计算机仅能做加法，减法通过补码转换为加法）。
*   **格式**：`SUB 目的操作数, 源操作数`
*   **实例**（逐步拆解，`AX=50H`，`BX=30H`）：
    ```assembly
    SUB AX, BX
    ```
    *   **执行过程**：`50H - 30H = 20H`（补码转换：`30H`的补码=`D0H`，`50H`+`D0H`=`120H`，舍弃进位`1`→`20H`）。
    *   **结果**：`AX=20H`，`BX=30H`（源操作数不变）。
*   **对标志位的影响**：与`ADD`一致（影响所有6个标志位）。
*   **例**：
    ```assembly
    SUB AL, 20H  ; AL=10H
    ```
    → 运算：`10H-20H` = `-10H`，结果以补码表示为`F0H` → `CF=1`（有借位）；结果`F0H`≠`0` → `ZF=0`；最高位为`1` → `SF=1`。

#### （3）`INC` 指令（Increment，自增1指令）
*   **指令本质**：“Increment”=增加，将操作数的值**加1**，结果存入操作数。
*   **格式**：`INC 操作数` （操作数=寄存器/内存，**不能是立即数/段寄存器**）。
*   **实例**：
    ```assembly
    MOV CX, 5
    INC CX
    ```
    → `CX=6`
*   **对标志位的影响**（**核心考点**）：**不影响CF标志位**（底层原因：`INC`是“自增1”，设计时忽略进位，避免影响循环逻辑），但影响ZF/SF/OF/AF/PF。
*   **例**：
    ```assembly
    MOV AL, 0FFH
    INC AL
    ```
    → `AL=00H`，`ZF=1`，`CF`**保持不变**（无进位）。
*   **用途**：循环计数器自增（如 `INC CX; JNZ LOOP_LABEL`）。

#### （4）`DEC` 指令（Decrement，自减1指令）
*   **指令本质**：“Decrement”=减少，将操作数的值**减1**，结果存入操作数。
*   **格式**：`DEC 操作数` （同`INC`，不能是立即数/段寄存器）。
*   **实例**：
    ```assembly
    MOV BX, 3
    DEC BX
    ```
    → `BX=2`
*   **对标志位的影响**：**不影响CF标志位**（同`INC`），但影响其他5个标志位。
*   **例**：
    ```assembly
    MOV AL, 00H
    DEC AL
    ```
    → `AL=0FFH`，`SF=1`，`CF`**保持不变**（无借位）。
*   **用途**：循环计数器自减（如 `DEC CX; JNZ LOOP_LABEL`）。

#### （5）`CMP` 指令（Compare，比较指令，重中之重）
*   **指令本质**：“Compare”=比较，执行“**目的操作数 - 源操作数**”，但**不保存结果**（仅修改标志位）。
*   **核心用途**：配合`Jxx`条件转移指令，实现分支判断（比较后根据标志位决定是否跳转）。
*   **格式**：`CMP 目的操作数, 源操作数`
*   **与`SUB`的区别**（考试必考）：
    *   `SUB`：保存减法结果（覆盖目的操作数），修改标志位。
    *   `CMP`：不保存结果（目的操作数不变），**仅修改标志位**。
*   **实例**（逐步拆解，`AX=40H`，`BX=30H`）：
    ```assembly
    CMP AX, BX
    ```
    *   **执行过程**：`40H - 30H = 10H`（不保存结果）；修改标志位（`CF=0`，`ZF=0`，`SF=0`，`OF=0`）。
    *   **后续分支**：`JG LABEL` （`AX>BX`，标志位满足，跳转）。
*   **易错点**：`CMP`不修改任何操作数，仅改标志位。若误将`CMP`当作`SUB`使用（期望保存结果），会导致逻辑错误。

### 2. 关键考点：对标志位的影响（逐位拆解）

标志位（FLAGS寄存器）是“指令执行结果的状态记录”，后续`Jxx`指令依赖其判断。

| 标志位 | 英文全称 | 中文含义 | 判断规则（逐字解释） | 实例验证（基于ADD/SUB/CMP） |
| :--- | :--- | :--- | :--- | :--- |
| **CF** | Carry Flag | 进位/借位标志 | 无符号数运算：<br>**加法**→结果超出无符号数的最大范围（如8位0~255）→ CF=1（进位）；<br>**减法**→被减数 < 减数 → CF=1（借位）；<br>否则CF=0。 | 例1（加法进位）：`ADD AL, 0FFH` （`AL=1`）→ 1+255=256（超出8位范围）→ `CF=1`；<br>例2（减法借位）：`SUB AL, 2` （`AL=1`）→ 1<2 → `CF=1` |
| **ZF** | Zero Flag | 零标志 | 运算结果=0 → ZF=1；<br>结果≠0 → ZF=0。 | 例：`CMP AX, AX` （`AX-AX=0`）→ `ZF=1`；<br>`ADD AL, 1` （`AL=0`）→ `AL=1`≠0 → `ZF=0` |
| **SF** | Sign Flag | 符号标志 | 运算结果的最高位（符号位）=1 → SF=1（负数）；<br>最高位=0 → SF=0（正数）；<br>（仅当ZF=0时有效，ZF=1时结果为0，无正负） | 例1（正数）：`ADD AL, 10H` （结果`00010000B`，最高位0）→ `SF=0`；<br>例2（负数）：`SUB AL, 20H` （`AL=10H`，结果`11110000B`，最高位1）→ `SF=1` |
| **OF** | Overflow Flag | 溢出标志 | 有符号数运算：<br>结果超出有符号数的范围（8位-128~+127） → OF=1（溢出）；<br>否则OF=0；<br>（溢出判断技巧：正数+正数=负数，负数+负数=正数→溢出） | 例1（溢出）：`ADD AL, 7FH` （`AL=1`，`7FH=+127`）→ 1+127=128（超出+127）→ 结果`80H`（-128）→ `OF=1`；<br>例2（不溢出）：`ADD AL, 30H` （`AL=20H`，结果`50H=+80`）→ `OF=0` |
| **AF** | Auxiliary Flag | 半进位标志 | 算术运算时，低4位（bit0~bit3）向高4位（bit4~bit7）产生进位/借位 → AF=1；<br>否则AF=0。 | 例（半进位）：`ADD AL, 0FH` （`AL=1`）→ 1+15=16（低4位15+1=16，向高4位进位）→ `AF=1`；<br>例（无半进位）：`ADD AL, 0EH` （`AL=1`）→ 1+14=15 → `AF=0` |
| **PF** | Parity Flag | 奇偶标志 | 运算结果的**低8位**中，1的个数为偶数 → PF=1；<br>为奇数 → PF=0；<br>（仅关注低8位，与高位无关） | 例1（偶数个1）：`ADD AL, 20H` （结果`00100000B`，1个1 → 奇数）→ `PF=0`；<br>例2（偶数个1）：`ADD AL, 30H` （结果`00110000B`，2个1 → 偶数）→ `PF=1` |

**指令对标志位的影响总结**（考试填空/判断题高频）：

| 指令 | CF | ZF | SF | OF | AF | PF | 核心记忆点 |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :--- |
| `ADD` | √ | √ | √ | √ | √ | √ | 全影响 |
| `SUB` | √ | √ | √ | √ | √ | √ | 全影响 |
| `INC` | × | √ | √ | √ | √ | √ | 不影响CF |
| `DEC` | × | √ | √ | √ | √ | √ | 不影响CF |
| `CMP` | √ | √ | √ | √ | √ | √ | 全影响（同ADD/SUB） |

*   **口诀**：`ADD`/`SUB`/`CMP`全影响，`INC`/`DEC`不影响`CF`。

### 3. 难点：溢出（OF）与进位（CF）的区别（问答题必考）

#### （1）核心定义（逐字解释，结合8位运算实例）
*   **进位（CF）**：**无符号数**的“超界”标志。
    *   **针对对象**：无符号数（“无符号数”=仅表示正数，范围0~2ⁿ-1，n=位数）。
    *   **判断标准**：运算结果超出无符号数的最大范围 → 产生进位（加法）或借位（减法） → `CF=1`。
    *   **实例**（8位无符号数，范围0~255）：
        *   **加法进位**：`9FH`(159) + `61H`(97) = `100H`(256) → 256>255（超界）→ `CF=1`。
        *   **减法借位**：`10H`(16) - `20H`(32) = `0F0H`(240) → 16<32（超界）→ `CF=1`。
        *   **无进位/借位**：`30H`(48) + `20H`(32) = `50H`(80) → 80≤255 → `CF=0`。

*   **溢出（OF）**：**有符号数**的“超界”标志。
    *   **针对对象**：有符号数（“有符号数”=用最高位表示符号，0=正，1=负，范围-2ⁿ⁻¹~+2ⁿ⁻¹-1，n=位数）。
    *   **判断标准**：运算结果超出有符号数的范围 → 符号异常（正数变负数，负数变正数）→ `OF=1`。
    *   **实例**（8位有符号数，范围-128~+127）：
        *   **加法溢出**：`7FH`(+127) + `01H`(+1) = `80H`(-128) → +128超出+127（超界）→ 正数变负数 → `OF=1`。
        *   **减法溢出**：`80H`(-128) - `01H`(-1) = `7FH`(+127) → -129超出-128（超界）→ 负数变正数 → `OF=1`。
        *   **无溢出**：`30H`(+48) + `20H`(+32) = `50H`(+80) → +80在范围内 → `OF=0`。

#### （2）关键区别（考试答题模板，逐点逐字解释）
1.  **针对对象不同**：
    *   `CF` 针对**无符号数**（仅表示大小，无正负）。
    *   `OF` 针对**有符号数**（有正负，最高位是符号位）。
2.  **判断标准不同**：
    *   `CF` 看“结果是否超出无符号数的范围”（加法超界=进位，减法超界=借位）。
    *   `OF` 看“结果是否超出有符号数的范围”（超界=符号异常，正数变负或负数变正）。
3.  **独立性不同**：
    *   `CF` 和 `OF` 无必然联系，可同时为1、同时为0、一1一0。
    *   **实例1**（同时为1）：`9FH`（无符号159/有符号-97） + `61H`（无符号97/有符号+97） = `100H` → `CF=1`（无符号超界），`OF=1`（有符号-97+97=-256，超界）。
    *   **实例2**（`CF=1`, `OF=0`）：`0FFH`（无符号255/有符号-1） + `01H`（无符号1/有符号+1） = `100H` → `CF=1`（无符号超界），`OF=0`（有符号-1+1=0，未超界）。
    *   **实例3**（`CF=0`, `OF=1`）：`7FH`(+127) + `02H`(+2) = `81H`(-127) → `CF=0`（无符号127+2=129≤255），`OF=1`（有符号超界）。

---

# 第6页：指令详解（三）—— 位处理、控制转移与串操作指令

### 一、位处理指令

位处理指令是**对数据的二进制位进行单独操作**（如清位、置位、移位），不影响其他位，多用于硬件控制、数据加密等场景。

#### 1. 位运算指令（`AND`/`OR`/`NOT`/`NEG`/`TEST`）

##### （1）`AND` 指令（Logical AND，按位与）
*   **指令本质**：对目的操作数和源操作数的每一位执行“**全1则1，否则0**”的逻辑运算，结果存入目的操作数。
*   **格式**：`AND 目的操作数, 源操作数`
*   **位运算规则**：
    | 目的位 | 源位 | 结果位 |
    | :---: | :---: | :---: |
    | 0 | 0 | 0 |
    | 0 | 1 | 0 |
    | 1 | 0 | 0 |
    | 1 | 1 | 1 |
*   **典型应用**：
    *   **清位**（将某几位变为0）：源操作数对应位为0，其他位为1。
        ```assembly
        AND AL, 0F7H  ; 将AL的bit3(第4位)清0
        ```
    *   **保留位**（将某几位保留，其他位清0）：源操作数对应位为1，其他位为0。
        ```assembly
        AND AL, 0FH   ; 保留AL的低4位，高4位清0
        ```
*   **对标志位的影响**：影响`ZF`/`SF`/`PF`，`CF=0`（固定），不影响`OF`/`AF`。

##### （2）`OR` 指令（Logical OR，按位或）
*   **指令本质**：对目的操作数和源操作数的每一位执行“**有1则1，否则0**”的逻辑运算，结果存入目的操作数。
*   **格式**：`OR 目的操作数, 源操作数`
*   **位运算规则**：
    | 目的位 | 源位 | 结果位 |
    | :---: | :---: | :---: |
    | 0 | 0 | 0 |
    | 0 | 1 | 1 |
    | 1 | 0 | 1 |
    | 1 | 1 | 1 |
*   **典型应用**：
    *   **置位**（将某几位变为1）：源操作数对应位为1，其他位为0。
        ```assembly
        OR AL, 04H   ; 将AL的bit2(第3位)置1
        ```
    *   **合并数据**：将两个数的不同位合并为1。
        ```assembly
        OR AL, BL
        ```
*   **对标志位的影响**：同`AND`（影响`ZF`/`SF`/`PF`，`CF=0`，不影响`OF`/`AF`）。

##### （3）`NOT` 指令（Logical NOT，按位取反）
*   **指令本质**：对操作数的每一位执行“0→1，1→0”的取反操作，结果存入操作数。
*   **格式**：`NOT 操作数`
*   **位运算规则**：
    | 原位 | 结果位 |
    | :---: | :---: |
    | 0 | 1 |
    | 1 | 0 |
*   **实例**：
    ```assembly
    MOV BL, 3FH  ; BL=00111111B
    NOT BL       ; BL=11000000B (0C0H)
    ```
*   **对标志位的影响**：**不影响任何标志位**（核心考点，考试判断题高频）。

##### （4）`NEG` 指令（Negate，求补码）
*   **指令本质**：对操作数执行“0 - 操作数”的运算，结果存入操作数（等价于“按位取反+1”，即求补码）。
*   **格式**：`NEG 操作数`
*   **底层逻辑**：补码 = 反码 + 1，`NEG`指令直接计算补码（计算机中负数以补码存储）。
*   **实例**：
    *   例1：`AL=30H`(+48) → `NEG AL` → 运算：0-30H = D0H (-48的补码) → `AL=0D0H`。
    *   例2：`AL=0` → `NEG AL` → 0-0=0 → `AL=0`，`CF=0`（唯一`CF=0`的情况）。
*   **对标志位的影响**：影响所有标志位，`CF=1`（除非操作数=0）。
*   **与`NOT`的区别**：`NOT`是按位取反（无+1），不影响标志位；`NEG`是按位取反+1（补码），影响所有标志位。

##### （5）`TEST` 指令（Test，测试指令）
*   **指令本质**：对目的操作数和源操作数执行“按位与”运算，但**不保存结果**，仅修改标志位。
*   **格式**：`TEST 目的操作数, 源操作数`
*   **与`AND`的区别**：`AND`保存结果并修改目的操作数；`TEST`不保存结果，仅修改标志位。
*   **典型应用**：
    *   **测试某一位是否为1**（通过`ZF`判断，`ZF=0` → 位为1，`ZF=1` → 位为0）。
    *   **实例**：判断`AL`的第0位是否为1，若为1则跳至`LABEL`。
    ```assembly
    TEST AL, 01H
    JNZ LABEL  ; 若AL的bit0=1，则 ZF=0, JNZ跳转
    ```

#### 2. 移位指令（Shift Instructions）

移位指令是“将操作数的二进制位按指定方向移动”，移出的位可能存入`CF`或循环填入。

##### （1）移位次数规则（所有移位指令通用，考试必考）
*   **规则1**：移位次数=1时，直接写次数（如 `SHL AX, 1`）。
*   **规则2**：移位次数>1时，必须用`CL`寄存器存储次数（如 `MOV CL, 3; SHR BX, CL`）。
*   **底层原因**：CPU指令集设计，移位指令的“移位次数”字段仅支持1位（0~1），次数>1时需通过`CL`寄存器传递。

##### （2）逻辑移位（Logical Shift，针对无符号数）
*   **`SHL` 指令（Shift Left Logical，逻辑左移）**
    *   **格式**：`SHL 操作数, 次数`
    *   **功能**：操作数左移n位，**最高位移入`CF`**，**最低位补0**。
    *   **等价运算**：无符号数×2ⁿ。
    *   **示例**：`AL=0AH`(00001010B)，`SHL AL, 1` → `AL=14H`(00010100B)，`CF=0`。

*   **`SHR` 指令（Shift Right Logical，逻辑右移）**
    *   **格式**：`SHR 操作数, 次数`
    *   **功能**：操作数右移n位，**最低位移入`CF`**，**最高位补0**。
    *   **等价运算**：无符号数÷2ⁿ（向下取整）。
    *   **示例**：`AL=0F0H`(11110000B)，`SHR AL, 1` → `AL=78H`(01111000B)，`CF=0`。

##### （3）算术移位（Arithmetic Shift，针对有符号数）
*   **`SAL` 指令（Shift Arithmetic Left，算术左移）**
    *   **格式**：`SAL 操作数, 次数`
    *   **功能**：**与`SHL`完全相同**。操作数左移n位，最高位移入`CF`，最低位补0。
    *   **等价运算**：有符号数×2ⁿ。

*   **`SAR` 指令（Shift Arithmetic Right，算术右移）**
    *   **格式**：`SAR 操作数, 次数`
    *   **功能**：操作数右移n位，**最低位移入`CF`**，**最高位（符号位）保持不变**。
    *   **等价运算**：有符号数÷2ⁿ（向下取整）。
    *   **与`SHR`的核心区别**：`SHR`最高位补0；`SAR`最高位补符号位。

##### （4）循环移位（Rotate Shift）
*   **`ROL` 指令（Rotate Left，不带进位左循环）**
    *   **格式**：`ROL 操作数, 次数`
    *   **功能**：操作数左移n位，**最高位移出后，同时填入最低位和`CF`**。
*   **`ROR` 指令（Rotate Right，不带进位右循环）**
    *   **格式**：`ROR 操作数, 次数`
    *   **功能**：操作数右移n位，**最低位移出后，同时填入最高位和`CF`**。
*   **`RCL` 指令（Rotate Left Through Carry，带进位左循环）**
    *   **格式**：`RCL 操作数, 次数`
    *   **功能**：操作数左移n位，**最高位移出后填入`CF`**，**`CF`原有的值填入最低位**。
*   **`RCR` 指令（Rotate Right Through Carry，带进位右循环）**
    *   **格式**：`RCR 操作数, 次数`
    *   **功能**：操作数右移n位，**最低位移出后填入`CF`**，**`CF`原有的值填入最高位**。

### 二、控制转移指令

控制转移指令通过修改`CS:IP`（指令指针）改变程序执行顺序。

#### 1. `JMP` 指令（Unconditional Jump，无条件转移）
*   **核心功能**：强制转移到指定地址执行。
*   **分类**：
    *   **段内直接短转移**：`JMP SHORT LABEL`（偏移量范围±127字节）。
    *   **段内直接近转移**：`JMP NEAR PTR LABEL` 或 `JMP LABEL`（偏移量范围±32767字节）。
    *   **段内间接转移**：`JMP BX` 或 `JMP [SI]`（目标偏移地址来自寄存器/内存）。
    *   **段间直接转移**：`JMP FAR PTR LABEL`（同时修改CS和IP）。

#### 2. `Jxx` 条件转移指令（Conditional Jump，重中之重）
*   **核心依赖**：前一条指令修改的标志位（`CF`/`ZF`/`SF`/`OF`）。
*   **核心考点**：有符号数与无符号数的条件转移指令**不能混淆**。

##### （1）无符号数条件转移指令
| 指令 | 中文含义 | 标志位判断条件 | 示例 |
| :--- | :--- | :--- | :--- |
| `JA/JNBE` | 高于/不低于等于 | `CF=0` 且 `ZF=0` | `CMP AX, BX; JA LABEL` |
| `JB/JNAE` | 低于/不高于等于 | `CF=1` 且 `ZF=0` | `CMP AX, BX; JB LABEL` |
| `JAE/JNB` | 高于或等于/不低于 | `CF=0` 或 `ZF=1` | `CMP AX, BX; JAE LABEL` |
| `JBE/JNA` | 低于或等于/不高于 | `CF=1` 或 `ZF=1` | `CMP AX, BX; JBE LABEL` |
| `JE/JZ` | 等于/为零 | `ZF=1` | `CMP AX, BX; JE LABEL` |
| `JNE/JNZ` | 不等于/非零 | `ZF=0` | `CMP AX, BX; JNE LABEL` |

##### （2）有符号数条件转移指令
| 指令 | 中文含义 | 标志位判断条件 | 示例 |
| :--- | :--- | :--- | :--- |
| `JG/JNLE` | 大于/不小于等于 | `SF=OF` 且 `ZF=0` | `CMP AX, BX; JG LABEL` |
| `JL/JNGE` | 小于/不大于等于 | `SF≠OF` 且 `ZF=0` | `CMP AX, BX; JL LABEL` |
| `JGE/JNL` | 大于或等于/不小于 | `SF=OF` 或 `ZF=1` | `CMP AX, BX; JGE LABEL` |
| `JLE/JNG` | 小于或等于/不大于 | `SF≠OF` 或 `ZF=1` | `CMP AX, BX; JLE LABEL` |

*   **记忆口诀**：无符号“高JA低JB”，有符号“大JG小JL”。

#### 3. 循环指令（Loop Instructions）
循环指令本质是“JMP+计数器自减”，自动完成“计数器减1→判断→条件满足则循环”，核心依赖`CX`/`ECX`寄存器。

| 指令 | 功能 | 循环条件 | 示例 |
| :--- | :--- | :--- | :--- |
| `LOOP` | 无条件循环 | `CX=CX-1`; 若`CX≠0`则跳转 | `MOV CX, 5; LOOP LABEL` |
| `LOOPE`/`LOOPZ` | 相等/为零循环 | `CX=CX-1`; 若`CX≠0`且`ZF=1`则跳转 | `CMP AL, 0; LOOPE LABEL` |
| `LOOPNE`/`LOOPNZ` | 不相等/非零循环 | `CX=CX-1`; 若`CX≠0`且`ZF=0`则跳转 | `CMP AL, 0; LOOPNE LABEL` |

#### 4. 子程序调用与返回指令
*   **`CALL` 指令**：调用子程序，将返回地址（`CALL`下一条指令的地址）压入堆栈，并跳转。
    *   **段内调用**：`CALL NEAR PTR PROC1`，仅压入`IP`。
    *   **段间调用**：`CALL FAR PTR PROC2`，先压入`CS`，再压入`IP`。
*   **`RET` 指令**：从子程序返回，从堆栈弹出返回地址，并跳回。
    *   **段内返回**：`RET`，弹出`IP`。
    *   **段间返回**：`RETF`，先弹出`IP`，再弹出`CS`。
    *   **带参数返回**：`RET n`，返回后执行`SP=SP+n`，用于平衡栈帧。

### 三、串操作指令（String Instructions，批量处理数据）

串操作指令是“对连续的内存数据（串）进行批量操作”，一次操作1字节（BYTE）、1字（WORD）或1双字（DWORD），可配合重复前缀实现自动循环。

#### 1. 核心前提
*   **固定寄存器搭配**：
    *   源串地址：`DS:SI`
    *   目的串地址：`ES:DI`
    *   串长度/循环次数：`CX`/`ECX`
*   **方向标志`DF`**：`DF=0`（`CLD`指令） → 地址递增（`SI`/`DI`自增）；`DF=1`（`STD`指令） → 地址递减（`SI`/`DI`自减）。

#### 2. 5条核心串指令
| 指令 | 功能 | 影响的操作数 | 操作长度 | 重复前缀 |
| :--- | :--- | :--- | :--- | :--- |
| **`MOVS`** | 串传送（复制） | 从`[DS:SI]`复制到`[ES:DI]` | B/W/D | `REP` |
| **`CMPS`** | 串比较 | 比较`[DS:SI]`和`[ES:DI]` | B/W/D | `REPE`/`REPNE` |
| **`SCAS`** | 串扫描（查找） | 比较`AL/AX/EAX`和`[ES:DI]` | B/W/D | `REPE`/`REPNE` |
| **`LODS`** | 串装入（读取） | 从`[DS:SI]`读入`AL/AX/EAX` | B/W/D | （少用） |
| **`STOS`** | 串存储（写入） | 从`AL/AX/EAX`写入`[ES:DI]` | B/W/D | `REP` |

*   **缩写格式**：`MOVSB`（字节）、`MOVSW`（字）、`MOVSD`（双字）。其他指令类似。
*   **重复前缀**：
    *   `REP`：重复`CX`次。
    *   `REPE`/`REPZ`：`CX≠0`且`ZF=1`时重复。
    *   `REPNE`/`REPNZ`：`CX≠0`且`ZF=0`时重复。


## 第7页：汇编语言程序设计（逐字逐词拆解）

### 一、程序设计的核心结构（3种基础结构，考试应用题必考）

汇编语言程序的核心结构与高级语言一致（**顺序、分支、循环**），所有复杂程序均由这3种结构组合而成，需掌握“每类结构的代码模板+逻辑实现+调试技巧”。

#### 1. 顺序结构 (Sequential Structure)
*   **结构本质**：“顺序执行”，程序从第一条指令开始，依次执行每一条指令，**无跳转、无循环**（最简单的结构，是分支/循环的基础）。
*   **核心特点**：指令执行顺序与代码编写顺序一致，无标志位判断，无控制转移指令。
*   **典型场景**：数据初始化、简单运算、单步数据处理。
*   **完整实例**（逐句拆解，实现“将AX=10H，BX=20H相加，结果存入CX”）：
    ```assembly
    CODE SEGMENT
    ASSUME CS:CODE
    START:
    ; 顺序执行步骤1：初始化数据
    MOV AX, 10H    ; 第1条：AX=10H（赋值）
    MOV BX, 20H    ; 第2条：BX=20H（赋值）
    ; 顺序执行步骤2：简单运算
    ADD AX, BX     ; 第3条：AX=10H+20H=30H（加法）
    ; 顺序执行步骤3：存储结果
    MOV CX, AX     ; 第4条：CX=30H（结果存入CX）
    ; 顺序执行步骤4：退出程序（固定模板）
    MOV AH, 4CH    ; 第5条：功能号4CH（程序退出）
    INT 21H        ; 第6条：调用DOS中断，退出程序
    CODE ENDS
    END START
    ```
*   **考试重点**：
    1.  程序退出必须用 `MOV AH, 4CH; INT 21H` （DOS中断调用，固定模板，少写则程序无法正常退出）。
    2.  顺序结构的代码**无`JMP`、`Jxx`、`LOOP`**等控制转移指令，仅含数据传送、算术运算等指令。
    3.  数据初始化需明确寄存器/内存的值（避免随机值导致结果错误）。

#### 2. 分支结构 (Branching Structure)
*   **结构本质**：“条件判断+分支跳转”，根据某一条件（标志位状态）决定执行哪一段代码（**二分支/多分支**）。
*   **核心依赖**：`CMP` 指令（修改标志位） + `Jxx` 条件转移指令（判断标志位并跳转）。
*   **分类**：二分支结构（`if-else`）、多分支结构（`if-else if-else`/`switch-case`）。

##### （1）二分支结构 (if-else，最常用)
*   **代码模板**（通用，逐句解释）：
    ```assembly
    ; 步骤1：准备数据，执行比较指令（修改标志位）
    MOV 寄存器1, 数值1
    MOV 寄存器2, 数值2
    CMP 寄存器1, 寄存器2 ; 比较两个数值，修改标志位（ZF/CF/SF/OF）
    ; 步骤2：条件跳转（满足条件跳至分支1，否则执行分支2）
    Jxx 分支1标号       ; Jxx：根据比较结果选择（如JE/JNE/JA/JB/JG/JL）
    ; 分支2（条件不满足时执行）
    指令序列2           ; 条件不满足时的代码
    JMP 结束标号        ; 跳至结束（避免执行分支1的代码）
    ; 分支1（条件满足时执行）
    分支1标号:
    指令序列1           ; 条件满足时的代码
    ; 步骤3：分支结束（统一执行后续代码）
    结束标号:
    后续指令
    ```
*   **实例**（逐句拆解，实现“判断AX是否等于BX，等于则CX=1，否则CX=0”）：
    ```assembly
    CODE SEGMENT
    ASSUME CS:CODE
    START:
    ; 步骤1：初始化数据并比较
    MOV AX, 30H    ; AX=30H（待比较值1）
    MOV BX, 30H    ; BX=30H（待比较值2）
    CMP AX, BX     ; 比较AX和BX→ AX=BX→ ZF=1
    ; 步骤2：条件跳转（ZF=1跳至EQUAL，否则执行ELSE分支）
    JE EQUAL       ; JE：ZF=1→ 跳至EQUAL（AX=BX）
    ; ELSE分支（AX≠BX）
    MOV CX, 0      ; CX=0（条件不满足）
    JMP END_BRANCH ; 跳至结束，避免执行EQUAL分支
    ; IF分支（AX=BX）
    EQUAL:
    MOV CX, 1      ; CX=1（条件满足）
    ; 分支结束
    END_BRANCH:
    ; 后续指令（退出程序）
    MOV AH, 4CH
    INT 21H
    CODE ENDS
    END START
    ; 执行结果：AX=BX→ CX=1；若AX≠BX→ CX=0
    ```
*   **考试易错点**：
    1.  分支2执行完后**必须加 `JMP 结束标号`**（否则会顺序执行分支1的代码，导致逻辑错误）。
    2.  **必须根据数据类型选择`Jxx`指令**（无符号数用`JA`/`JB`，有符号数用`JG`/`JL`）。
    3.  比较指令 `CMP` **不能省略**（`Jxx`依赖其修改的标志位）。

##### （2）多分支结构 (if-else if-else，考试应用题高频)
*   **结构本质**：“多次条件判断+多次跳转”，根据多个条件依次判断，满足某一条件则执行对应分支，否则执行最后分支。
*   **代码模板**（通用，3个分支为例）：
    ```assembly
    ; 步骤1：准备数据并比较（第一个条件）
    MOV 寄存器, 数值
    CMP 寄存器, 条件1数值
    Jxx 分支1标号       ; 满足条件1→ 跳分支1
    ; 步骤2：第二个条件判断
    CMP 寄存器, 条件2数值
    Jxx 分支2标号       ; 满足条件2→ 跳分支2
    ; 步骤3：默认分支（不满足任何条件）
    指令序列3           ; 默认分支代码
    JMP 结束标号
    ; 分支1
    分支1标号:
    指令序列1
    JMP 结束标号
    ; 分支2
    分支2标号:
    指令序列2
    ; 结束
    结束标号:
    后续指令
    ```
*   **实例**（逐句拆解，实现“判断AL的值：AL=0→CX=0；AL=1→CX=1；其他→CX=FFH”）：
    ```assembly
    CODE SEGMENT
    ASSUME CS:CODE
    START:
    ; 步骤1：初始化数据（AL为待判断值）
    MOV AL, 1      ; AL=1（可修改为0、2等测试不同分支）
    ; 第一个条件：AL=0？
    CMP AL, 0
    JE BRANCH0     ; JE（ZF=1）→ 跳BRANCH0（AL=0）
    ; 第二个条件：AL=1？
    CMP AL, 1
    JE BRANCH1     ; JE→ 跳BRANCH1（AL=1）
    ; 默认分支：AL≠0且AL≠1
    MOV CX, 0FFH   ; CX=FFH
    JMP END_BRANCH ; 跳至结束
    ; 分支1：AL=0
    BRANCH0:
    MOV CX, 0      ; CX=0
    JMP END_BRANCH
    ; 分支2：AL=1
    BRANCH1:
    MOV CX, 1      ; CX=1
    ; 结束
    END_BRANCH:
    MOV AH, 4CH
    INT 21H
    CODE ENDS
    END START
    ; 测试结果：
    ; AL=0→ CX=0；AL=1→ CX=1；AL=2→ CX=FFH
    ```
*   **考试重点**：
    1.  多分支需按“条件优先级”依次判断（先判断优先级别高的条件）。
    2.  每个分支执行完后**需加 `JMP 结束标号`**（避免分支穿透）。
    3.  适用于“根据一个变量的不同值执行不同操作”的场景（如成绩分级、菜单选择）。

#### 3. 循环结构 (Loop Structure)
*   **结构本质**：“重复执行一段代码”，根据循环计数器（`CX`）或条件（标志位）决定循环次数，核心是“**循环初始化→循环体→循环控制**”。
*   **分类**：**计数循环**（已知循环次数，用`LOOP`指令）、**条件循环**（未知循环次数，用`Jxx`指令）。

##### （1）计数循环（已知循环次数，最常用）
*   **代码模板**（通用，循环n次）：
    ```assembly
    ; 步骤1：循环初始化（计数器CX=循环次数，其他数据初始化）
    MOV CX, n      ; n=循环次数（如5→ 循环5次）
    MOV 寄存器, 初始值 ; 如累加器初始化为0
    ; 步骤2：循环体起始标号
    循环体标号:
    指令序列         ; 循环执行的代码（如累加、数据处理）
    ; 步骤3：循环控制（LOOP指令，CX自减1→ 判断CX≠0则循环）
    LOOP 循环体标号   ; 循环控制指令
    ; 步骤4：循环结束
    后续指令
    ```
*   **实例**（逐句拆解，实现“循环5次，累加1~5的和，结果存入AX”）：
    ```assembly
    CODE SEGMENT
    ASSUME CS:CODE
    START:
    ; 步骤1：循环初始化
    MOV CX, 5      ; CX=5（循环5次，对应1~5）
    MOV AX, 0      ; AX=0（累加器初始化为0）
    MOV BX, 1      ; BX=1（初始值为1，每次循环加1）
    ; 步骤2：循环体
    LOOP_LABEL:
    ADD AX, BX     ; 累加：AX=AX+BX（第一次：0+1=1；第二次：1+2=3；…第五次：10+5=15）
    INC BX         ; BX自增1（BX=2→3→4→5→6）
    ; 步骤3：循环控制
    LOOP LOOP_LABEL ; CX自减1（5→4→3→2→1→0），CX≠0则跳回LOOP_LABEL
    ; 循环结束：AX=1+2+3+4+5=15（0FH）
    MOV AH, 4CH
    INT 21H
    CODE ENDS
    END START
    ; 执行过程：
    ; 循环1次：CX=5→4，AX=1，BX=2；
    ; 循环2次：CX=4→3，AX=3，BX=3；
    ; 循环3次：CX=3→2，AX=6，BX=4；
    ; 循环4次：CX=2→1，AX=10，BX=5；
    ; 循环5次：CX=1→0，AX=15，BX=6；
    ; CX=0→ 退出循环，AX=15。
    ```
*   **考试重点**：
    1.  **循环次数=CX初始值**（CX=n→ 循环n次）。
    2.  循环体中**需包含“修改循环变量”的指令**（如`INC BX`、`ADD AX,1`），否则会导致死循环。
    3.  适用于“已知重复次数”的场景（如累加n个数、复制n个数据）。

##### （2）条件循环（未知循环次数，按条件终止）
*   **结构本质**：“先执行循环体，再判断条件”（`do-while`）或“先判断条件，再执行循环体”（`while`），用 `Jxx` 指令控制循环（不用`LOOP`指令）。
*   **代码模板**（`while`型，先判断后执行）：
    ```assembly
    ; 步骤1：初始化数据
    MOV 寄存器, 初始值
    ; 步骤2：条件判断（不满足则退出循环）
    循环判断标号:
    CMP 寄存器, 条件值 ; 修改标志位
    Jxx 循环结束标号   ; 不满足条件→ 退出循环
    ; 步骤3：循环体
    指令序列         ; 循环执行的代码
    ; 步骤4：修改循环变量
    INC/DEC 寄存器    ; 修改判断条件中的变量
    ; 步骤5：跳回条件判断
    JMP 循环判断标号
    ; 步骤6：循环结束
    循环结束标号:
    后续指令
    ```
*   **实例**（逐句拆解，实现“累加1~10的和，直到累加和大于20时停止”）：
    ```assembly
    CODE SEGMENT
    ASSUME CS:CODE
    START:
    ; 步骤1：初始化数据
    MOV AX, 0      ; AX=0（累加和初始化为0）
    MOV BX, 1      ; BX=1（当前累加的数，从1开始）
    ; 步骤2：条件判断（累加和AX>20？满足则退出）
    WHILE_LABEL:
    CMP AX, 20     ; 比较AX和20→ 修改ZF/CF（AX≤20→ ZF=0且CF=1）
    JG END_LOOP    ; JG（AX>20）→ 退出循环；否则执行循环体
    ; 步骤3：循环体（累加）
    ADD AX, BX     ; AX=AX+BX
    ; 步骤4：修改循环变量（BX自增1）
    INC BX         ; BX=BX+1
    ; 步骤5：跳回条件判断
    JMP WHILE_LABEL
    ; 步骤6：循环结束
    END_LOOP:
    ; 最终结果：AX=1+2+3+4+5+6=21（>20，停止循环），BX=7
    MOV AH, 4CH
    INT 21H
    CODE ENDS
    END START
    ; 执行过程：
    ; 初始：AX=0，BX=1→  判断AX>20？0>20→ 否→ 累加AX=1，BX=2→ 跳回；
    ; 第1次：AX=1→ 否→ 累加AX=3，BX=3；
    ; 第2次：AX=3→ 否→ 累加AX=6，BX=4；
    ; 第3次：AX=6→ 否→ 累加AX=10，BX=5；
    ; 第4次：AX=10→ 否→ 累加AX=15，BX=6；
    ; 第5次：AX=15→ 否→ 累加AX=21，BX=7；
    ; 第6次：AX=21→ 判断21>20→ 是→ 跳至END_LOOP，退出循环。
    ```
*   **考试重点**：
    1.  条件循环的核心是“**循环判断条件**”（如`AX>20`、`AL≠0`），需用`CMP+Jxx`实现。
    2.  必须包含“**修改循环变量**”的指令（如`INC BX`），否则死循环。
    3.  适用于“未知循环次数，仅知终止条件”的场景（如查找数据、处理字符串直到遇到0）。

### 二、子程序设计（模块化编程，考试大题必考）

#### 1. 子程序的核心优势（逐点解释）
*   **优势1**：代码复用（将重复使用的代码写成子程序，避免重复编写，减少代码量）。
*   **优势2**：程序清晰（将复杂程序拆分为多个子程序，如“输入子程序”“计算子程序”“输出子程序”，结构清晰易维护）。
*   **优势3**：便于调试（单独调试每个子程序，定位错误更高效）。

#### 2. 子程序的标准结构（逐句拆解，固定模板）
```assembly
; 主程序（调用子程序）
CODE SEGMENT
ASSUME CS:CODE, DS:DATA
START:
; 步骤1：初始化DS/ES（若子程序需访问内存数据）
MOV AX, DATA
MOV DS, AX
MOV ES, AX
; 步骤2：传递参数给子程序（3种常用方式）
; 方式1：寄存器传递（最常用，适用于参数少的情况）
MOV AX, 10H    ; AX=参数1
MOV BX, 20H    ; BX=参数2
; 方式2：堆栈传递（适用于参数多的情况）
PUSH CX        ; 压入参数3（CX的值）
PUSH DX        ; 压入参数4（DX的值）
; 步骤3：调用子程序
CALL 子程序名   ; 段内调用（默认NEAR）
; 步骤4：子程序返回后，处理结果（若有）
MOV CX, AX     ; AX存储子程序的返回结果→ 存入CX
; 步骤5：释放堆栈参数（若用堆栈传递参数）
ADD ESP, 4     ; 2个参数，每个4字节→ 释放4字节（或用RET 4在子程序中释放）
; 退出程序
MOV AH, 4CH
INT 21H

; 子程序（被调用的代码段，必须有标号和RET指令）
子程序名 PROC   ; PROC：Procedure（子程序开始，固定关键字）
               ; 子程序保护现场（保存主程序用到的寄存器，避免被子程序修改）
               PUSH AX        ; 保存AX（若子程序修改AX）
               PUSH BX        ; 保存BX（若子程序修改BX）
               ; 子程序核心逻辑（执行具体功能）
               ; 例：计算AX+BX，结果存入AX（返回给主程序）
               ADD AX, BX     ; 核心功能：参数1+参数2
               ; 子程序恢复现场（恢复保存的寄存器，与压栈顺序相反）
               POP BX         ; 恢复BX（与PUSH BX对应）
               POP AX         ; 恢复AX（与PUSH AX对应）
               ; 子程序返回（与CALL对应）
               RET            ; 段内返回（若主程序用FAR CALL，此处用RETF）
子程序名 ENDP   ; ENDP：End Procedure（子程序结束，固定关键字）
CODE ENDS
END START
```

#### 3. 3种参数传递方式（考试重点，逐种拆解）

##### （1）寄存器传递方式（最常用，优先选择）
*   **核心逻辑**：将参数存入通用寄存器（如`AX`、`BX`、`CX`、`DX`），子程序从寄存器中获取参数；返回结果也存入寄存器（如`AX`）。
*   **适用场景**：参数个数少（1~3个），参数长度≤32位。
*   **实例**（逐句拆解，子程序实现“两数相加”，用寄存器传递参数）：
    ```assembly
    DATA SEGMENT
    ; 无需定义内存参数（用寄存器传递）
    DATA ENDS

    CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
    START:
    ; 主程序：传递参数，调用子程序
    MOV AX, DATA
    MOV DS, AX
    MOV AL, 10H    ; AL=参数1（被加数，8位）
    MOV BL, 20H    ; BL=参数2（加数，8位）
    CALL ADD_SUB   ; 调用加法子程序
    ; 子程序返回后，结果在AL中
    MOV CL, AL     ; CL=30H（10H+20H）
    MOV AH, 4CH
    INT 21H

    ; 子程序：ADD_SUB（两字节数相加，参数：AL=被加数，BL=加数；返回结果：AL=和）
    ADD_SUB PROC
    ; 保护现场（子程序修改AL和BL，需保存主程序的AL/BL值？若主程序后续需用，必须保存）
    PUSH AX        ; 保存AX（含AL）
    PUSH BX        ; 保存BX（含BL）
    ; 核心逻辑：两数相加
    ADD AL, BL     ; AL=10H+20H=30H（和）
    ; 恢复现场（恢复主程序的AX/BL值？若子程序修改了寄存器，必须恢复，否则主程序后续使用错误）
    ; 注意：此处AL是返回结果，若恢复AX会覆盖结果→ 需调整保存顺序（仅保存BL）
    ; 修正：仅保存BL（因为AL是返回结果，不保存）
    ; PUSH BX
    ; ADD AL, BL
    ; POP BX
    ; 此处为了演示，暂按原代码，实际需根据返回结果调整保存的寄存器
    POP BX
    POP AX
    ; 修正后返回：AL=30H（结果）
    RET            ; 返回主程序
    ADD_SUB ENDP
    CODE ENDS
    END START
    ```
*   **考试重点**：
    1.  寄存器传递的优点：**速度快**（无需访问内存），代码简单。
    2.  **注意事项**：① 子程序需明确参数和返回值的寄存器（如“AL=参数1，BL=参数2，AL=返回结果”）；② 若子程序修改了主程序后续需使用的寄存器，必须“**保护现场**”（PUSH）和“**恢复现场**”（POP），且压栈/弹栈顺序相反；③ 避免使用`CS`、`IP`等专用寄存器传递参数。

##### （2）堆栈传递方式（适用于参数多的场景）
*   **核心逻辑**：主程序将参数依次压入堆栈，子程序从堆栈中获取参数（通过`ESP`/`EBP`寄存器寻址）；返回后主程序或子程序释放堆栈参数。
*   **适用场景**：参数个数多（3个以上），或参数长度较大。
*   **关键寻址**：子程序中常用`EBP`作为基址寄存器（`EBP=ESP`，避免`ESP`被压栈操作修改，导致参数寻址错误）。
*   **实例**（逐句拆解，子程序实现“三数相加”，用堆栈传递参数）：
    ```assembly
    DATA SEGMENT
    ; 无需定义内存参数（用堆栈传递）
    DATA ENDS

    CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
    START:
    ; 主程序：传递3个参数（10H、20H、30H），调用子程序
    MOV AX, DATA
    MOV DS, AX
    ; 压入参数（注意：堆栈先进后出，参数顺序与子程序获取顺序相反）
    PUSH 30H       ; 参数3（加数3，8位）→ 栈底
    PUSH 20H       ; 参数2（加数2，8位）
    PUSH 10H       ; 参数1（被加数，8位）→ 栈顶
    CALL ADD3_SUB  ; 调用三数相加子程序（压入返回地址EIP）
    ; 释放堆栈参数（3个参数，每个4字节→ 3×4=12字节？不，8位参数压栈时自动扩展为32位，每个参数4字节）
    ADD ESP, 12    ; 释放12字节（或子程序用RET 12释放）
    ; 子程序返回后，结果在AX中
    MOV CL, AL     ; CL=60H（10H+20H+30H）
    MOV AH, 4CH
    INT 21H

    ; 子程序：ADD3_SUB（三字节数相加，堆栈传递参数：参数1=10H，参数2=20H，参数3=30H；返回结果：AL=和）
    ADD3_SUB PROC
    ; 保护现场（保存EBP、AX、BX、CX，因为子程序要使用这些寄存器）
    PUSH EBP       ; 保存主程序的EBP值
    MOV EBP, ESP   ; 用EBP作为基址寄存器（EBP=当前ESP，指向返回地址）
    PUSH AX        ; 保存AX
    PUSH BX        ; 保存BX
    PUSH CX        ; 保存CX

    ; 从堆栈中获取参数（EBP为基址，偏移量计算：EBP+4=返回地址，EBP+8=参数1，EBP+12=参数2，EBP+16=参数3）
    MOV AL, [EBP+8]  ; AL=参数1=10H（EBP+8：第一个参数的偏移地址）
    MOV BL, [EBP+12] ; BL=参数2=20H（EBP+12：第二个参数）
    MOV CL, [EBP+16] ; CL=参数3=30H（EBP+16：第三个参数）

    ; 核心逻辑：三数相加
    ADD AL, BL     ; AL=10H+20H=30H
    ADD AL, CL     ; AL=30H+30H=60H（和）

    ; 恢复现场（与压栈顺序相反）
    POP CX         ; 恢复CX
    POP BX         ; 恢复BX
    POP AX         ; 恢复AX（注意：AL是返回结果，此处恢复会覆盖？需调整：不保存AX，或最后重新赋值）
    ; 修正：不保存AX（因为AX存储返回结果）
    ; PUSH EBP
    ; MOV EBP, ESP
    ; PUSH BX
    ; PUSH CX
    ; ... 计算后AL=60H
    ; POP CX
    ; POP BX
    POP EBP        ; 恢复EBP
    ; 返回主程序（若需子程序释放参数，用RET 12，代替主程序的ADD ESP,12）
    RET            ; 或 RET 12（释放12字节参数）
    ADD3_SUB ENDP
    CODE ENDS
    END START
    ```
*   **考试重点**（续）—— 堆栈传递方式易错点（逐点解释原因+规避方法）：
    1.  **易错点1**：参数压栈顺序与子程序获取顺序相反（导致参数读取错误）→ **原因**：堆栈遵循“先进后出”，主程序先压入的参数在栈底，子程序需从栈顶开始读取；**规避**：① 主程序压栈顺序：“最后使用的参数先压入”；② 子程序获取顺序：从`EBP+8`开始（栈顶第一个参数），依次递增偏移量（如3个参数：`EBP+8`=参数1，`EBP+12`=参数2，`EBP+16`=参数3）。
    2.  **易错点2**：子程序中未用`EBP`作为基址寄存器（导致参数寻址错误）→ **原因**：`ESP`会被子程序中的`PUSH`/`POP`指令修改，直接用`ESP`寻址会因栈指针变化找不到参数；**规避**：子程序开头必须执行`PUSH EBP; MOV EBP, ESP`（固定模板），用`EBP`作为基址，偏移量固定（与`ESP`无关）。
    3.  **易错点3**：参数释放不及时（导致堆栈溢出）→ **原因**：参数压入堆栈后未释放，多次调用子程序会导致堆栈空间被耗尽；**规避**：① 主程序释放：`ADD ESP, n`（n=参数总字节数）；② 子程序释放：`RET n`（n=参数总字节数，推荐，避免主程序遗漏）。
    4.  **易错点4**：现场保护/恢复顺序错误（导致寄存器值被破坏）→ **原因**：`PUSH`与`POP`顺序必须相反（先进后出）；**规避**：保护现场时“先压入不常用寄存器，后压入常用寄存器”，恢复时按反向顺序弹出（如`PUSH EBP; PUSH AX; PUSH BX` → 恢复时`POP BX; POP AX; POP EBP`）。
*   **核心口诀**：“堆栈传递先压后用，EBP基址偏移定，`RET n`或`ADD ESP`，现场保护逆序弹”。

##### （3）内存单元传递方式（适用于参数多/参数长度大的场景）
*   **核心逻辑**：主程序将参数存入连续的内存单元（如数组、结构体），子程序通过“段地址+偏移地址”访问内存单元获取参数；返回结果也存入指定内存单元。
*   **适用场景**：① 参数个数多（4个以上）；② 参数长度大（如字符串、数组）；③ 参数需要长期保存（寄存器/堆栈断电丢失，内存单元可长期存储）。
*   **实现要点**：① 主程序：定义内存单元存储参数，将内存偏移地址传递给子程序（通过寄存器或堆栈）；② 子程序：根据传递的偏移地址，访问内存单元获取参数/存储结果。
*   **完整实例**（逐句拆解，子程序实现“两数相乘”，用内存单元传递参数）：
    ```assembly
    DATA SEGMENT
    ; 定义内存单元存储参数和结果（连续内存区域）
    PARAMS DB 10H, 20H    ; 参数1=10H（被乘数），参数2=20H（乘数），偏移地址0000H
    RESULT DB 0           ; 存储结果，偏移地址0002H
    DATA ENDS

    CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
    START:
    ; 主程序：初始化DS，传递内存偏移地址给子程序
    MOV AX, DATA
    MOV DS, AX
    MOV SI, OFFSET PARAMS ; SI=参数内存单元的偏移地址（0000H），通过寄存器传递给子程序
    CALL MUL_SUB          ; 调用乘法子程序

    ; 子程序返回后，读取结果（RESULT=10H×20H=200H→ 存储为00H, 02H，因为8位×8位=16位，低字节存低地址，高字节存高地址）
    MOV AL, RESULT        ; AL=00H（结果低字节）
    MOV AH, RESULT+1      ; AH=02H（结果高字节）→ AX=0200H（正确结果）
    MOV AH, 4CH
    INT 21H

    ; 子程序：MUL_SUB（两8位无符号数相乘，内存单元传递参数：DS:SI指向参数1，SI+1指向参数2；结果存入SI+2）
    MUL_SUB PROC
    ; 保护现场（子程序使用SI、AL、BL、AH，需保存）
    PUSH SI
    PUSH AL
    PUSH BL
    PUSH AH

    ; 从内存单元获取参数（DS:SI指向参数起始地址）
    MOV AL, [SI]          ; AL=参数1=10H（DS:SI=DATA:0000H）
    MOV BL, [SI+1]        ; BL=参数2=20H（DS:SI+1=DATA:0001H）

    ; 核心逻辑：8位无符号数相乘（MUL BL：AL×BL，结果存入AX）
    MUL BL                ; AX=AL×BL=10H×20H=200H（AH=02H，AL=00H）

    ; 结果存入指定内存单元（SI+2=DATA:0002H，低字节AL存低地址，高字节AH存高地址）
    MOV [SI+2], AL        ; RESULT=00H（低字节）
    MOV [SI+3], AH        ; RESULT+1=02H（高字节）→ 完整结果0200H

    ; 恢复现场（与压栈顺序相反）
    POP AH
    POP BL
    POP AL
    POP SI
    RET                   ; 返回主程序
    MUL_SUB ENDP
    CODE ENDS
    END START
    ```
*   **考试重点**：
    1.  内存传递的优点：**参数个数无限制**，参数可长期保存；缺点：访问内存速度比寄存器慢（需通过`DS:SI`/`DI`寻址）。
    2.  **关键步骤**：主程序必须传递“内存单元的偏移地址”（通过`SI`/`DI`/寄存器/堆栈），子程序需明确参数在内存中的偏移关系（如`SI`=参数1，`SI+1`=参数2）。
    3.  **数据存储规则**：多字节结果按“**小端序**”存储（低字节存低地址，高字节存高地址），与CPU存储规则一致（考试必须遵循，否则结果错误）。

##### （4）3种参数传递方式对比（考试选择题高频）
| 传递方式 | 优点 | 缺点 | 适用场景 | 记忆口诀 |
| :--- | :--- | :--- | :--- | :--- |
| **寄存器传递** | 速度最快（无需访问内存），代码简单 | 参数个数有限（1~3个），寄存器资源紧张 | 参数少、高频调用的子程序（如加法、减法） | 寄存器，快而少 |
| **堆栈传递** | 参数个数无限制，不占用寄存器 | 速度较慢（需压栈/弹栈），需注意堆栈平衡 | 参数多（3个以上）、子程序嵌套调用 | 堆栈，多而稳 |
| **内存传递** | 参数个数/长度无限制，可长期保存 | 速度最慢（需访问内存），需定义内存单元 | 参数多、参数长度大（如字符串）、需长期保存参数 | 内存，多而久 |

#### 4. 子程序设计的通用易错点（考试大题避坑指南）
| 易错点 | 错误表现 | 原因分析 | 规避方法（逐句执行） |
| :--- | :--- | :--- | :--- |
| 子程序无`PROC`/`ENDP`关键字 | 汇编报错“语法错误” | `PROC`（子程序开始）和`ENDP`（子程序结束）是固定关键字，缺少则汇编器无法识别子程序 | 每个子程序必须遵循：<br>`子程序名 PROC`<br>`... 代码 ...`<br>`子程序名 ENDP` |
| 子程序无`RET`指令 | 子程序执行完后无法返回主程序，导致程序崩溃 | `RET`指令用于弹出返回地址，缺少则程序会继续执行子程序后的垃圾代码 | 子程序末尾**必须加`RET`**（段内）或`RETF`（段间），且放在`ENDP`前 |
| 现场保护/恢复不完整 | 主程序中的寄存器值被子程序修改，后续代码逻辑错误 | 子程序使用了主程序正在使用的寄存器（如AX、BX），未保存/恢复 | ① 明确子程序使用的寄存器（如SI、AL、BX）；<br>② 子程序开头`PUSH`保存这些寄存器；<br>③ 子程序结尾`POP`恢复（顺序相反） |
| 子程序调用前未传递参数 | 子程序获取到随机值，计算结果错误 | 子程序依赖主程序传递的参数，未传递则参数为内存/寄存器的随机值 | 调用`CALL`前，**必须按约定传递参数**（寄存器/堆栈/内存），缺一不可 |
| 子程序标号重复 | 汇编报错“标号重定义” | 多个子程序使用相同的标号（如都用`SUB1`），汇编器无法区分 | 子程序名必须唯一，推荐命名规则：“功能+类型”（如`ADD_SUB`加法子程序，`MUL_SUB`乘法子程序） |
| 段间调用与段内返回不匹配 | 程序崩溃，弹出“非法地址访问” | 主程序用`CALL FAR PTR SUB1`（段间调用），子程序用`RET`（段内返回），弹出地址错误 | 严格对应：段内`CALL` ↔ `RET`；段间`FAR CALL` ↔ `RETF` |

### 三、中断服务程序（Interrupt Service Routine，考试大题重中之重）

#### 1. 中断的核心概念（逐字逐词解释）
*   **中断**：“打断当前程序的正常执行，转去执行一段专门处理突发事件的程序（中断服务程序），处理完后再返回原程序继续执行”的过程（类似“上课被老师叫走，处理完事情再回到座位上课”）。
*   **中断的作用**：① 处理突发事件（如键盘输入、鼠标点击、定时器溢出）；② 实现多任务调度（如操作系统切换程序）；③ 调用系统功能（如DOS中断`INT 21H`实现输入/输出）。
*   **关键术语**：
    *   **中断源**：产生中断的设备/事件（如键盘→ 中断源，定时器→ 中断源）。
    *   **中断类型码**：用于区分不同中断源的编号（0~255，8位，如`0`号中断=除法溢出，`1`号中断=单步中断，`21H`号中断=DOS中断）。
    *   **中断向量表**：内存地址`0000H~003FFH`（共1024字节）的区域，用于存储“中断服务程序的入口地址（CS:IP）”，每个中断类型码对应4字节（2字节IP，2字节CS），**计算公式**：中断向量地址 = 中断类型码 × 4（考试必考公式）。
    *   **中断服务程序**：处理中断事件的子程序（与普通子程序类似，但入口地址存于中断向量表，由中断触发执行）。

#### 2. 中断处理的完整过程（8步，逐步拆解，考试简答题必考）
以“键盘输入触发中断（中断类型码9H）”为例，拆解中断处理过程：
1.  **中断请求**：用户按下键盘→ 键盘控制器向CPU发送中断请求信号（IRQ1）。
2.  **中断响应**：CPU执行完当前指令后，检测到中断请求→ 若开中断（IF=1），则响应中断。
3.  **保护断点**：将当前程序的断点地址（CS:IP，即下一条要执行的指令地址）压入堆栈（**先压CS，再压IP**，与段间`CALL`一致）。
4.  **保护标志位**：将`FLAGS`寄存器的值压入堆栈（保存当前程序的标志位状态）。
5.  **关中断**：CPU自动将`IF=0`（禁止其他中断干扰当前中断处理）。
6.  **查找中断向量**：根据中断类型码（9H）计算中断向量地址=`9H × 4=24H`（`0000H:0024H`）→ 从该地址读取4字节（`IP=0024H~0025H`，`CS=0026H~0027H`）。
7.  **执行中断服务程序**：将读取的`CS:IP`送入CPU→ 转去执行中断服务程序（处理键盘输入）。
8.  **中断返回**：执行`IRET`指令（中断返回指令）→ ① 弹出`FLAGS`寄存器值（恢复标志位）；② 弹出`IP`和`CS`（恢复断点地址）；③ 开中断（`IF=1`，允许其他中断）→ 返回原程序继续执行。

#### 3. 中断服务程序的标准结构（固定模板，考试大题直接套用）
中断服务程序是“特殊的子程序”，需遵循“**保护现场→ 开中断→ 处理逻辑→ 关中断→ 恢复现场→ IRET返回**”的模板，完整代码如下：
```assembly
; 中断服务程序（以中断类型码n为例）
INT_n PROC
  ; 步骤1：保护现场（保存主程序的寄存器和标志位，比普通子程序多保存FLAGS）
  PUSH AX        ; 保存AX
  PUSH BX        ; 保存BX
  PUSH CX        ; 保存CX
  PUSH DX        ; 保存DX
  PUSH SI        ; 保存SI
  PUSH DI        ; 保存DI
  PUSH DS        ; 保存DS（若中断服务程序访问数据段，需重新初始化DS）
  PUSH ES        ; 保存ES

  ; 步骤2：开中断（IF=1，允许高优先级中断打断当前中断，可选，根据需求决定）
  STI            ; 开中断（若不需要嵌套中断，可省略）

  ; 步骤3：中断服务核心逻辑（处理具体中断事件，如键盘输入、定时器处理）
  ; 例：初始化DS（中断服务程序默认CS=代码段，DS=未知，需重新赋值）
  MOV AX, DATA
  MOV DS, AX
  ; 核心处理代码（如读取键盘输入值，存入AL）
  IN AL, 60H     ; 从键盘端口60H读取输入值（键盘中断专用端口）

  ; 步骤4：关中断（IF=0，避免恢复现场时被中断干扰，与STI对应）
  CLI            ; 关中断（若未开中断，可省略）

  ; 步骤5：恢复现场（与压栈顺序相反，恢复主程序的寄存器）
  POP ES         ; 恢复ES
  POP DS         ; 恢复DS
  POP DI         ; 恢复DI
  POP SI         ; 恢复SI
  POP DX         ; 恢复DX
  POP CX         ; 恢复CX
  POP BX         ; 恢复BX
  POP AX         ; 恢复AX

  ; 步骤6：中断返回（必须用IRET，不能用RET）
  IRET           ; 中断返回：弹出FLAGS→ 弹出IP→ 弹出CS
INT_n ENDP
```

#### 4. 常用中断（考试高频，逐种拆解）

##### （1）DOS中断（INT 21H，最常用，实现输入/输出/程序控制）
DOS中断是操作系统提供的中断服务程序，通过`AH`寄存器传递“功能号”，实现不同功能（无需自己编写中断服务程序，直接调用），常用功能如下（逐功能解释）：
| 功能号（AH） | 功能名称 | 入口参数（输入） | 出口参数（输出） | 完整实例（逐句拆解） |
| :--- | :--- | :--- | :--- | :--- |
| 01H | 键盘输入一个字符（带回显） | 无 | AL=输入字符的ASCII码 | ```assembly<br>; 从键盘输入一个字符，存入AL<br>MOV AH, 01H    ; 功能号01H（键盘输入）<br>INT 21H        ; 调用DOS中断，等待用户输入→ AL=输入字符ASCII码（如输入'A'→ AL=41H）<br>``` |
| 02H | 显示一个字符 | DL=要显示字符的ASCII码 | 无 | ```assembly<br>; 显示字符'A'（ASCII码41H）<br>MOV AH, 02H    ; 功能号02H（显示字符）<br>MOV DL, 41H    ; DL=字符'A'的ASCII码<br>INT 21H        ; 调用中断，屏幕显示'A'<br>``` |
| 09H | 显示字符串 | DS:DX=字符串起始偏移地址，字符串以'$'结尾（结束标志） | 无 | ```assembly<br>DATA SEGMENT<br>STR DB 'Hello, Assembly!', '$'<br>DATA ENDS<br>CODE SEGMENT<br>ASSUME CS:CODE, DS:DATA<br>START:<br>MOV AX, DATA<br>MOV DS, AX<br>MOV AH, 09H    ; 功能号09H（显示字符串）<br>MOV DX, OFFSET STR ; DX=字符串偏移地址<br>INT 21H        ; 调用中断，显示字符串"Hello, Assembly!"<br>MOV AH, 4CH<br>INT 21H<br>CODE ENDS<br>END START<br>``` |
| 0AH | 键盘输入字符串 | DS:DX=输入缓冲区起始地址（缓冲区第1字节=最大长度，第2字节=实际输入长度，第3字节开始=输入字符串） | 缓冲区第2字节=实际输入长度，第3字节开始=输入字符串（以`0DH`结尾） | ```assembly<br>DATA SEGMENT<br>BUF DB 10, ?, 10 DUP(0) ; 缓冲区：10=最大长度，?=实际长度，10 DUP(0)=字符串存储区<br>DATA ENDS<br>CODE SEGMENT<br>ASSUME CS:CODE, DS:DATA<br>START:<br>MOV AX, DATA<br>MOV DS, AX<br>MOV AH, 0AH    ; 功能号0AH（输入字符串）<br>MOV DX, OFFSET BUF ; DX=缓冲区偏移地址<br>INT 21H        ; 调用中断，等待用户输入（最多输入9个字符，实际长度存入BUF+1）<br>MOV AH, 4CH<br>INT 21H<br>CODE ENDS<br>END START<br>``` |
| 4CH | 程序正常退出 | 无 | 无 | ```assembly<br>; 程序退出（固定模板，必须加）<br>MOV AH, 4CH    ; 功能号4CH（程序退出）<br>INT 21H        ; 调用中断，释放CPU资源，程序正常退出<br>``` |
*   **考试重点**：
    1.  `INT 21H`的调用格式：`MOV AH, 功能号`；设置入口参数；`INT 21H`（功能号必须存入`AH`，缺一不可）。
    2.  字符串显示/输入的关键：显示字符串**必须以`'$'`结尾**（`$`是DOS字符串结束标志），输入缓冲区必须按“最大长度→实际长度→存储区”定义。
    3.  **常用功能口诀**：“01输入02显，09字符串，0A输串4C退”。

##### （2）BIOS中断（INT 10H，视频服务中断，控制屏幕显示）
BIOS中断是固化在主板BIOS中的中断服务程序，直接控制硬件（如显示器），常用功能如下（考试高频）：
| 功能号（AH） | 功能名称 | 入口参数 | 出口参数 | 实例（设置屏幕显示模式） |
| :--- | :--- | :--- | :--- | :--- |
| 00H | 设置显示模式 | AL=显示模式（`03H`=文本模式，`13H`=图形模式） | 无 | ```assembly<br>; 设置屏幕为文本模式（80列×25行，16色）<br>MOV AH, 00H    ; 功能号00H（设置显示模式）<br>MOV AL, 03H    ; AL=03H（文本模式）<br>INT 10H        ; 调用BIOS中断，设置显示模式<br>``` |
| 0EH | 显示一个字符（无回显，适用于图形模式） | AL=字符ASCII码，BL=颜色（文本模式） | 无 | ```assembly<br>; 文本模式下显示红色字符'A'（BL=04H=红色）<br>MOV AH, 0EH    ; 功能号0EH（无回显显示）<br>MOV AL, 41H    ; AL='A'的ASCII码<br>MOV BL, 04H    ; BL=04H（红色）<br>INT 10H        ; 调用中断，显示红色'A'<br>``` |

#### 5. 中断服务程序设计的易错点（考试大题避坑）
*   **易错点1**：中断服务程序用`RET`返回（导致程序崩溃）→ **原因**：`RET`仅弹出`IP`/`CS`，未恢复`FLAGS`寄存器，而中断处理时压入了`FLAGS`；**规避**：中断服务程序必须用`IRET`返回（固定模板，不能替换）。
*   **易错点2**：未初始化`DS`（导致中断服务程序访问内存错误）→ **原因**：中断服务程序的`CS`=代码段，`DS`默认继承自被中断程序（可能不是数据段）；**规避**：中断服务程序开头必须重新初始化`DS`（`MOV AX, DATA; MOV DS, AX`）。
*   **易错点3**：忘记保护/恢复`DS`/`ES`（导致主程序数据段被破坏）→ **原因**：中断服务程序修改了`DS`/`ES`，未恢复会导致主程序访问错误的内存区域；**规避**：保护现场时必须`PUSH DS; PUSH ES`，恢复时`POP ES; POP DS`。
*   **易错点4**：未关中断导致恢复现场时被干扰→ **原因**：恢复现场时若有其他中断触发，会破坏堆栈中的断点地址；**规避**：恢复现场前执行`CLI`（关中断），恢复后由`IRET`自动开中断。
*   **易错点5**：中断类型码计算错误（导致找不到中断服务程序）→ **原因**：中断向量地址=中断类型码×4，计算错误会读取错误的入口地址；**规避**：牢记公式，如中断类型码`8H`→ 向量地址=`8×4=32H`（`0000H:0020H`）。

### 四、汇编程序的调试方法（考试实操题必考）

#### 1. 调试工具：DEBUG（DOS下最常用，考试指定工具）
DEBUG是DOS自带的汇编程序调试工具，通过命令行输入指令，实现“查看寄存器/内存、反汇编代码、单步执行、断点调试”等功能，常用命令如下（逐命令拆解，含用法+实例）：
| 命令 | 英文全称 | 功能（逐字解释） | 格式 | 实例（假设程序装入地址为`1000H:0000H`） |
| :--- | :--- | :--- | :--- | :--- |
| R | Register | 查看/修改寄存器值 | `R [寄存器名]`（省略则查看所有寄存器） | ① 查看所有寄存器：`R`（显示AX、BX、CX、DS、CS、IP等所有寄存器值）；② 修改AX值：`R AX`（输入后提示“AX 0000”，输入`10H`→ AX=10H） |
| U | Unassemble | 反汇编（将机器码转换为汇编指令） | `U [起始地址] [结束地址]`（省略则从当前IP开始反汇编） | ① 从`1000H:0000H`反汇编10条指令：`U 1000:0 1000:A`；② 从当前IP反汇编：`U`（显示当前要执行的汇编指令） |
| T | Trace | 单步执行（执行一条指令，自动显示寄存器变化） | `T [执行条数]`（省略则执行1条） | ① 单步执行1条指令：`T`（执行当前IP指向的指令，显示执行后所有寄存器值）；② 单步执行3条指令：`T 3` |
| G | Go | 运行程序（从当前IP开始，直到断点或程序结束） | `G [断点地址]`（省略则运行到程序结束） | ① 运行到`1000H:0010H`断点：`G 1000:10`（程序执行到`1000H:0010H`时暂停，显示寄存器值）；② 运行到结束：`G`（若程序有`INT 21H 4CH`，则正常退出） |
| D | Dump | 查看内存单元值 | `D [起始地址] [结束地址]`（省略则从当前`DS:SI`开始查看） | ① 查看`1000H:0000H~1000H:000FH`的内存值：`D 1000:0 1000:F`（显示十六进制值和ASCII码）；② 查看数据段内存：`D DS:0`（查看`DS`段起始地址的内存） |
| E | Enter | 修改内存单元值 | `E [起始地址] [值1] [值2] ...` | ① 修改`1000H:0000H`的值为`10H`：`E 1000:0 10`；② 修改`1000H:0000H~0002H`的值为`10H`、`20H`、`30H`：`E 1000:0 10 20 30` |
| Q | Quit | 退出DEBUG | `Q` | 输入`Q` → 退出DEBUG，返回DOS命令行 |

#### 2. 调试的完整步骤（考试实操题模板，逐步执行）
以“调试一个累加程序（AX=1+2+3+4+5）”为例，步骤如下：
1.  **装入程序**：DOS命令行输入`DEBUG 程序名.EXE`（将汇编生成的`EXE`文件装入DEBUG，程序起始地址默认`CS:IP=1000H:0000H`）。
2.  **查看寄存器初始值**：输入`R` → 查看AX、BX、CX等寄存器的初始值（默认全为0）。
3.  **反汇编代码**：输入`U 1000:0` → 查看程序的汇编指令，确认代码是否正确（如`MOV AX,0; MOV CX,5; MOV BX,1; ADD AX,BX; INC BX; LOOP ...`）。
4.  **设置断点**：输入`G 1000:0A`（假设循环结束地址为`1000H:000AH`）→ 程序运行到断点处暂停。
5.  **单步执行**：输入`T` → 单步执行一条指令，查看寄存器变化（如执行`ADD AX,BX`后，`AX`的值是否从0变为1）。
6.  **查看内存值**：若程序有内存操作，输入`D DS:0` → 查看数据段内存的变化（如结果是否存入指定内存单元）。
7.  **修改参数调试**：输入`R CX` → 将`CX`的值从5改为3（测试循环3次的结果），再输入`G` → 查看`AX`是否为6（1+2+3）。
8.  **退出调试**：输入`Q` → 退出DEBUG，记录调试结果。

#### 3. 常见程序错误及调试技巧（考试实操避坑）
| 错误类型 | 错误表现 | 调试技巧（用DEBUG定位） | 解决方法 |
| :--- | :--- | :--- | :--- |
| 语法错误 | 汇编时提示“Syntax error”（语法错误） | 无需用DEBUG，查看汇编器提示的行号，检查指令格式（如漏写冒号、寄存器名错误） | ① 检查指令助记符（如“MOV”写成“MOVV”）；② 检查寄存器名（如“AX”写成“AY”）；③ 检查标号是否加冒号（如“LOOP_LABEL”写成“LOOP_LABEL”无冒号） |
| 逻辑错误 | 汇编通过，但运行结果错误（如累加和不正确） | ① 用`T`单步执行，观察每次指令执行后寄存器的值；② 用`D`查看内存单元的值；③ 用`R`检查参数是否正确 | ① 检查循环次数（CX初始值是否正确）；② 检查累加器初始化（如AX是否初始化为0）；③ 检查条件跳转指令（如用`JA`代替`JG`） |
| 死循环 | 程序运行后无响应，无法退出 | ① 按`Ctrl+C`中断程序，进入DEBUG；② 用`U`查看循环体代码，检查是否有修改循环变量的指令；③ 用`R CX`查看循环计数器的值 | ① 循环体中添加修改循环变量的指令（如`INC BX`、`DEC CX`）；② 检查循环控制指令（如`LOOP`前是否有`CMP`指令导致条件错误） |
| 内存访问错误 | 程序崩溃，提示“Invalid memory access” | ① 用`R DS`查看`DS`的值是否正确（是否指向数据段）；② 用`D`查看访问的内存地址是否合法；③ 检查`SI`/`DI`的值是否超出内存范围 | ① 初始化`DS`（`MOV AX, DATA; MOV DS, AX`）；② 检查`SI`/`DI`的初始值（如是否为随机值）；③ 检查内存单元偏移地址（如`[SI+10]`是否超出数组范围） |

### 五、汇编程序设计综合实例（考试大题模板，逐句拆解）
**实例**：实现“从键盘输入一个大写字母，转换为小写字母后显示；若输入不是大写字母，则显示‘Error’”（包含顺序、分支、子程序、DOS中断）。

#### 1. 程序需求拆解（逐点明确）
*   **需求1**：从键盘输入一个字符（用DOS中断`INT 21H 01H`）。
*   **需求2**：判断输入字符是否为大写字母（ASCII码`41H~5AH`，即`'A'~'Z'`）。
*   **需求3**：若是大写字母→ 转换为小写字母（ASCII码+20H，如`'A' 41H+20H=61H='a'`）。
*   **需求4**：若不是大写字母→ 显示“Error”字符串（用DOS中断`INT 21H 09H`）。
*   **需求5**：显示转换后的小写字母（用DOS中断`INT 21H 02H`）。
*   **需求6**：程序正常退出（用DOS中断`INT 21H 4CH`）。

#### 2. 程序结构设计（3种结构+子程序）
1.  **顺序结构**：输入字符→ 调用判断子程序→ 调用转换/显示子程序。
2.  **分支结构**：判断输入是否为大写字母→ 是则转换，否则显示错误。
3.  **子程序**：① `IS_UPPER`（判断是否为大写字母）；② `TO_LOWER`（转换为小写字母）；③ `DISP_ERROR`（显示错误字符串）。

#### 3. 完整代码（逐句拆解，可直接复制运行）
```assembly
; 数据段：定义错误字符串（以'$'结尾）
DATA SEGMENT
ERROR_MSG DB 'Error', '$' ; 错误提示字符串，必须以'$'结尾
DATA ENDS

; 代码段：主程序+子程序
CODE SEGMENT
ASSUME CS:CODE, DS:DATA

; 主程序（程序入口）
START:
; 步骤1：初始化数据段DS
MOV AX, DATA
MOV DS, AX               ; DS=DATA（指向数据段，用于访问ERROR_MSG）

; 步骤2：从键盘输入一个字符（DOS中断INT 21H 01H）
MOV AH, 01H              ; AH=01H（键盘输入功能）
INT 21H                  ; 调用DOS中断，等待用户输入→ AL=输入字符ASCII码
MOV BL, AL               ; 将输入字符存入BL（保存，避免被子程序修改）

; 步骤3：调用子程序IS_UPPER，判断输入是否为大写字母（BL=输入字符）
CALL IS_UPPER            ; 调用判断子程序，若为大写字母则ZF=0，否则ZF=1

; 步骤4：分支判断（ZF=1→ 不是大写字母，显示错误；ZF=0→ 是大写字母，转换为小写）
JZ DISP_ERROR_LABEL      ; ZF=1→ 跳至DISP_ERROR_LABEL（显示错误）

; 步骤5：是大写字母，调用子程序TO_LOWER，转换为小写字母（BL=大写字母，返回AL=小写字母）
CALL TO_LOWER            ; 调用转换子程序→ AL=小写字母ASCII码

; 步骤6：显示转换后的小写字母（DOS中断INT 21H 02H）
MOV AH, 02H              ; AH=02H（显示字符功能）
MOV DL, AL               ; DL=小写字母ASCII码（要显示的字符）
INT 21H                  ; 调用中断，显示小写字母

; 步骤7：程序正常退出（固定模板）
JMP EXIT_LABEL           ; 跳至退出程序（避免执行显示错误的代码）

; 分支：不是大写字母，调用子程序DISP_ERROR显示错误
DISP_ERROR_LABEL:
CALL DISP_ERROR          ; 调用显示错误子程序

; 程序退出（固定模板）
EXIT_LABEL:
MOV AH, 4CH              ; AH=4CH（程序退出功能）
INT 21H                  ; 调用DOS中断，程序正常退出

; 子程序1：IS_UPPER（判断BL中的字符是否为大写字母，'A'~'Z'=41H~5AH）
; 入口参数：BL=待判断字符ASCII码
; 出口参数：ZF=0（是大写字母），ZF=1（不是大写字母）
IS_UPPER PROC
; 保护现场（子程序使用AX、BX、CX，保存主程序的寄存器值）
PUSH AX
PUSH BX
PUSH CX

; 核心逻辑：判断BL是否在41H~5AH之间（CMP+Jxx）
CMP BL, 41H              ; 比较BL与41H（'A'的ASCII码）
JB NOT_UPPER             ; BL<41H→ 不是大写字母，跳至NOT_UPPER
CMP BL, 5AH              ; 比较BL与5AH（'Z'的ASCII码）
JA NOT_UPPER             ; BL>5AH→ 不是大写字母，跳至NOT_UPPER

; 是大写字母：设置ZF=0（用OR指令修改ZF，OR AX,AX不改变AX值，但ZF=0）
OR AX, AX                ; AX=AX OR AX→ 若AX≠0则ZF=0（此处AX为随机值，大概率≠0，确保ZF=0）
JMP IS_UPPER_END         ; 跳至恢复现场

; 不是大写字母：设置ZF=1（用XOR指令修改ZF，XOR AX,AX使AX=0→ ZF=1）
NOT_UPPER:
XOR AX, AX               ; AX=AX XOR AX=0→ ZF=1

; 恢复现场（与压栈顺序相反）
IS_UPPER_END:
POP CX
POP BX
POP AX
RET                      ; 返回主程序
IS_UPPER ENDP

; 子程序2：TO_LOWER（将BL中的大写字母转换为小写字母，大写+20H=小写）
; 入口参数：BL=大写字母ASCII码（41H~5AH）
; 出口参数：AL=小写字母ASCII码（61H~7AH）
TO_LOWER PROC
; 保护现场（子程序使用AX、BL，保存主程序的寄存器值）
PUSH AX
PUSH BL

; 核心逻辑：大写字母ASCII码+20H=小写字母（如41H+20H=61H，'A'→'a'）
MOV AL, BL               ; AL=大写字母ASCII码
ADD AL, 20H              ; AL=AL+20H→ 转换为小写字母

; 恢复现场（恢复BL，AX作为返回结果不恢复）
POP BL
POP AX                   ; 注意：AL是返回结果，此处恢复会覆盖？修正：不保存AX
; 修正后保护现场：PUSH BL（仅保存BL）
; 恢复现场：POP BL
RET                      ; 返回主程序，AL=小写字母
TO_LOWER ENDP

; 子程序3：DISP_ERROR（显示错误字符串"Error"，用DOS中断INT 21H 09H）
; 入口参数：无（字符串ERROR_MSG在数据段，DS已初始化）
; 出口参数：无
DISP_ERROR PROC
; 保护现场（子程序使用AX、DX，保存主程序的寄存器值）
PUSH AX
PUSH DX

; 核心逻辑：显示字符串（DOS中断INT 21H 09H）
MOV AH, 09H              ; AH=09H（显示字符串功能）
MOV DX, OFFSET ERROR_MSG ; DX=错误字符串的偏移地址（DATA:0000H）
INT 21H                  ; 调用DOS中断，显示"Error"

; 恢复现场（与压栈顺序相反）
POP DX
POP AX
RET                      ; 返回主程序
DISP_ERROR ENDP

CODE ENDS
END START                ; 程序结束，入口地址为START
```

#### 4. 代码执行过程（逐步模拟，考试大题必写）
1.  **初始化`DS`**：`MOV AX, DATA; MOV DS, AX` → DS=DATA（指向数据段）。
2.  **输入字符**：`MOV AH, 01H; INT 21H` → 假设用户输入`'A'`（AL=41H），存入BL=41H。
3.  **调用`IS_UPPER`**：
    *   比较`BL=41H`与`41H`→ 不小于；比较`BL=41H`与`5AH`→ 不大于。
    *   执行`OR AX, AX` → ZF=0（是大写字母）；返回主程序。
4.  **分支判断**：`JZ DISP_ERROR_LABEL` → ZF=0→ 不跳转，执行转换子程序。
5.  **调用`TO_LOWER`**：
    *   AL=BL=41H→ `ADD AL, 20H` → AL=61H（'a'的ASCII码）；返回主程序。
6.  **显示小写字母**：`MOV AH, 02H; MOV DL, AL; INT 21H` → 屏幕显示`'a'`。
7.  **程序退出**：`MOV AH, 4CH; INT 21H` → 正常退出。

### 六、汇编语言考试重点总结（终极背诵版）

#### 1. 核心指令记忆口诀（必考）
*   **数据传送**：“`MOV`传送不改变，`PUSH`压栈`POP`弹，`XCHG`交换`AX`先，`LEA`取址送寄存器”。
*   **算术运算**：“`ADD`加`SUB`减，`MUL`无符号`IMUL`有，`DIV`无符号`IDIV`有，`INC`自增`DEC`自减”。
*   **逻辑运算**：“`AND`与`OR`或，`XOR`异或`NOT`非，`SHL`左移`SHR`右，`ROL`循环`ROR`反”。
*   **控制转移**：“`JMP`无条件，`Jxx`看标志，`LOOP`循环`CX`管，`CALL`调用`RET`返”。
*   **串操作**：“`MOVS`复制`REP`用，`CMPS`比较看`ZF`，`SCAS`查找`AL`装，`LODS`读取`STOS`写，`DS:SI`源`ES:DI`目，`CLD`正向`STD`反”。
*   **中断**：“`INT 21H` DOS用，`01`输入`02`显，`09`字符串`4C`退，`IRET`中断返回必用”。

#### 2. 程序设计模板（大题直接套用）
*   **顺序结构**：初始化→ 运算→ 存储→ 退出。
*   **分支结构**：`CMP`→ `Jxx`→ 分支1→ `JMP`→ 分支2→ 结束。
*   **循环结构**：初始化`CX`→ 循环体→ `LOOP`→ 结束。
*   **子程序**：`PROC`→ 保护现场→ 核心逻辑→ 恢复现场→ `RET`→ `ENDP`。
*   **中断服务程序**：`PROC`→ 保护现场→ `STI`→ 核心逻辑→ `CLI`→ 恢复现场→ `IRET`→ `ENDP`。

#### 3. 高频考点清单（必背）
1.  **标志位**：ZF（零标志）、CF（进位标志）、SF（符号标志）、OF（溢出标志）的含义及影响指令。
2.  **条件转移指令**：有符号数（`JG`/`JL`/`JGE`/`JLE`）与无符号数（`JA`/`JB`/`JAE`/`JBE`）的区别。
3.  **串操作**：`DS:SI`、`ES:DI`、`CX`、`DF`的作用，`REP`/`REPE`/`REPNE`的用法。
4.  **子程序**：3种参数传递方式（寄存器/堆栈/内存），现场保护与恢复。
5.  **中断**：中断处理过程，`INT 21H`常用功能，中断服务程序结构。
6.  **调试**：DEBUG常用命令（R/U/T/G/D/E），常见错误定位方法。

## 第8页：汇编语言历年真题解析（逐题拆解，含考点+步骤+答案）

### 一、选择题（历年高频，逐题解析）

#### 例题1：下列指令中，不影响标志位的是（  B  ）
A. ADD AX, BX  B. MOV AX, BX  C. CMP AX, BX  D. SUB AX, BX
*   **考点**：**指令对标志位的影响**（必考考点）
*   **解析**：
    *   A. `ADD`：加法指令，会影响**ZF**（零标志）、**CF**（进位标志）、**SF**（符号标志）、**OF**（溢出标志）、**AF**（辅助进位）、**PF**（奇偶标志）。
    *   B. `MOV`：**数据传送指令**，仅将`BX`的值送入`AX`，**不修改任何标志位**（正确答案）。
    *   C. `CMP`：比较指令，实质是`AX-BX`但不保存结果，**会修改所有标志位**（同`SUB`）。
    *   D. `SUB`：减法指令，**会影响所有算术标志位**。
*   **总结**：**影响标志位**的指令：算术运算（ADD/SUB/MUL/DIV）、比较（CMP）、逻辑运算（AND/OR/XOR）、移位（SHL/SHR）、自增/自减（INC/DEC，**注意**：INC/DEC**不影响CF**）。**不影响标志位**的指令：数据传送（MOV/PUSH/POP/XCHG）、取有效地址（LEA）。

#### 例题2：下列指令中，用于串比较的是（  B  ）
A. MOVS  B. CMPS  C. SCAS  D. STOS
*   **考点**：**串操作指令的功能**（必考考点）
*   **解析**：
    *   A. `MOVS`：串传送指令（复制）。
    *   B. `CMPS`：**串比较指令**（比较两个串中的数据）。
    *   C. `SCAS`：串扫描指令（在串中查找特定值）。
    *   D. `STOS`：串存储指令（将累加器值存入串）。
*   **答案**：B
*   **口诀**：`MOVS`（Move String）搬，`CMPS`（Compare）比，`SCAS`（Scan）找，`STOS`（Store）存，`LODS`（Load）取。

### 二、填空题（历年高频，逐题解析）

#### 例题1：中断向量表的地址范围是**0000H~003FFH**，中断向量地址的计算公式是**中断类型码 × 4**。
*   **考点**：**中断向量表的概念**
*   **解析**：
    *   **地址范围**：实模式下，中断向量表位于内存的**最低1KB**空间，即`0000:0000H`到`0000:03FFH`。共有256个中断向量（0~255），每个向量占4字节（2字节IP，2字节CS）。
    *   **计算公式**：给定中断类型码`n`，其对应的中断向量（即中断服务程序的入口地址CS:IP）的存储起始地址为`n × 4`。例如，`INT 21H`的中断向量地址为`21H × 4 = 0084H`。

#### 例题2：`LOOP`指令的循环次数由**CX**寄存器决定，执行`LOOP`指令时，首先将该寄存器**减1**，然后判断其是否为0，若不为0则循环。
*   **考点**：**`LOOP`循环指令的原理**
*   **解析**：
    *   `LOOP`指令是计数循环，**循环计数器必须是CX**。
    *   执行过程：`CX = CX - 1` → 判断`CX`是否为0 → 若`CX ≠ 0`，则跳转到指定标号处继续循环。

### **三、简答题（历年高频，逐题解析）**

#### 例题1：简述中断处理的完整过程（8步）。
*   **考点**：**中断处理过程**（必考简答题）
*   **答案（标准8步，按考试评分标准）**：
    1.  **中断请求**：中断源（如键盘、定时器）向CPU发出中断请求信号。
    2.  **中断响应**：CPU在执行完**当前指令**后，检测到中断请求。若**中断允许标志IF=1**（开中断），则响应中断。
    3.  **关中断**：CPU**自动将IF清零**，以防止在处理当前中断时被新的中断打断。
    4.  **保护断点**：将当前程序的下一条指令的地址（即**CS**和**IP**）**压入堆栈**（先压CS，后压IP）。
    5.  **保护现场**：将**FLAGS（标志寄存器）** 压入堆栈。
    6.  **获取入口地址**：根据**中断类型码n**，计算中断向量地址`n×4`，从该地址读取4字节（低字为IP，高字为CS），这就是中断服务程序的入口地址。
    7.  **执行中断服务程序**：CPU将获取的CS:IP加载到指令指针，开始**执行中断服务程序**。在ISR中通常需要**手动保护现场**（PUSH通用寄存器）。
    8.  **中断返回**：中断服务程序执行完毕后，执行`IRET`指令。`IRET`会依次**弹出**FLAGS、IP、CS，并**将IF置1**（开中断），从而恢复被中断的程序继续执行。
*   **评分要点**：必须答出“**关中断**”、“**保护断点（CS:IP）**”、“**保护现场（FLAGS，及ISR中PUSH寄存器）**”、“**获取向量（n×4）**”、“**IRET返回并恢复**”这几个核心步骤。顺序不能错。

### 四、编程题（历年大题，逐题解析，含代码+步骤）

#### 例题1：用汇编语言编写程序，实现“计算1~10的累加和，将结果存入内存单元SUM（双字节）”（要求用循环结构，子程序实现累加）。
*   **考点**：**循环结构 + 子程序 + 内存操作 + 程序框架**（必考大题）
*   **解题步骤**：
    1.  **定义数据段**：用`DW`定义一个双字节变量`SUM`。
    2.  **编写主程序**：初始化数据段，设置循环计数器`CX=10`和累加器`AX=0`，调用子程序。
    3.  **编写子程序**：用`LOOP`指令实现循环累加。注意保护现场（PUSH/POP）。
    4.  **存储结果并退出**：主程序将子程序返回的结果存入`SUM`，然后调用`INT 21H`的4CH功能退出。
*   **完整代码与注释**：
    ```assembly
    DATA SEGMENT
    SUM DW 0        ; 【考点1】定义双字节变量，用于存储结果
    DATA ENDS

    CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
    START:
        ; 【考点2】主程序开始，初始化数据段
        MOV AX, DATA
        MOV DS, AX

        ; 【考点3】准备调用子程序的参数：CX=循环次数，AX=初始累加和
        MOV CX, 10       ; 循环10次，对应1~10
        MOV AX, 0        ; 累加器清零
        CALL SUM_SUB     ; 【考点4】调用累加子程序

        ; 【考点5】处理子程序返回的结果
        MOV SUM, AX      ; 将结果（在AX中）存入内存变量SUM

        ; 【考点6】程序退出（固定模板）
        MOV AH, 4CH
        INT 21H

    ; ********** 子程序 SUM_SUB **********
    ; 功能：计算1+2+...+CX的和
    ; 入口参数：CX = 循环次数 (N)，AX = 初始值 (通常为0)
    ; 出口参数：AX = 累加和 (1+2+...+N)
    ; 使用的寄存器：BX (作为加数，从1递增到N)
    SUM_SUB PROC
        ; 【考点7】子程序开始，保护现场（保存主程序可能用到的寄存器）
        PUSH BX
        PUSH CX          ; 注意：CX本身是循环计数器，但也是入口参数，通常也需要保护

        MOV BX, 1        ; BX从1开始，作为每次累加的数
    ADD_LOOP:
        ADD AX, BX       ; 累加：AX = AX + BX
        INC BX           ; 加数BX递增
        LOOP ADD_LOOP    ; 【考点8】循环控制：CX=CX-1, 若CX≠0则跳回ADD_LOOP

        ; 【考点9】恢复现场（与PUSH顺序相反）
        POP CX
        POP BX
        RET              ; 【考点10】子程序返回
    SUM_SUB ENDP
    ; ********** 子程序结束 **********

    CODE ENDS
    END START            ; 【考点11】程序结束，入口为START
    ```
*   **执行结果**：`SUM`中存储的值为 `1+2+...+10 = 55 (37H)`。
*   **评分标准**：数据段定义(1分)、段初始化(1分)、参数传递(2分)、子程序结构(2分)、循环逻辑(3分)、现场保护与恢复(2分)、结果存储(1分)、程序退出(1分)、注释清晰(1分)。

#### 例题2：用汇编语言编写程序，实现“从键盘输入一个字符串（最多10个字符），统计其中大写字母的个数，将结果显示在屏幕上”。
*   **考点**：**DOS功能调用（0AH, 02H） + 循环 + 分支判断 + ASCII码处理**（综合大题）
*   **解题步骤**：
    1.  **定义数据段**：定义输入缓冲区（结构：最大长度，实际长度，字符串），定义计数器。
    2.  **输入字符串**：使用`INT 21H`的`0AH`功能。
    3.  **循环统计**：获取实际长度，循环检查每个字符是否在`'A'`(`41H`)到`'Z'`(`5AH`)之间。
    4.  **输出结果**：将统计结果（一位数）转换为ASCII码（加`30H`），使用`INT 21H`的`02H`功能显示。
*   **完整代码与注释**：
    ```assembly
    DATA SEGMENT
        ; 【考点1】定义输入缓冲区：第1字节=最大长度，第2字节=实际长度，后续字节存字符串
        BUF      DB 11          ; 最大允许输入10个字符 + 1个回车符
                DB ?           ; 预留位置，DOS调用后会填入实际输入字符数
                DB 11 DUP(0)  ; 预留11字节空间存储输入的字符
        COUNT    DB 0          ; 大写字母计数器
        PROMPT   DB 'Please input a string (max 10 chars): $'
        RESULT   DB 0DH, 0AH, 'The number of uppercase letters is: $' ; 0DH,0AH是回车换行
    DATA ENDS

    CODE SEGMENT
        ASSUME CS:CODE, DS:DATA
    START:
        MOV AX, DATA
        MOV DS, AX

        ; 【考点2】显示提示信息
        LEA DX, PROMPT
        MOV AH, 09H
        INT 21H

        ; 【考点3】输入字符串 (功能号0AH)
        LEA DX, BUF
        MOV AH, 0AH
        INT 21H

        ; 【考点4】初始化循环
        MOV CL, BUF+1     ; CL = 实际输入的字符个数
        MOV CH, 0         ; 将CX的高位清零，CX=循环次数
        LEA SI, BUF+2     ; SI指向输入字符串的首字符
        MOV COUNT, 0      ; 计数器清零

    CHECK_LOOP:
        CMP CX, 0         ; 判断循环是否结束
        JZ  DISP_RESULT   ; 如果CX=0，跳转到显示结果
        MOV AL, [SI]      ; 取一个字符到AL

        ; 【考点5】判断是否为大写字母 ('A' <= AL <= 'Z')
        CMP AL, 'A'
        JB  NOT_UPPER     ; 如果AL < 'A'，不是大写字母
        CMP AL, 'Z'
        JA  NOT_UPPER     ; 如果AL > 'Z'，不是大写字母

        ; 是大写字母，计数器加1
        INC COUNT

    NOT_UPPER:
        INC SI            ; 指针指向下一个字符
        DEC CX            ; 循环计数器减1
        JMP CHECK_LOOP    ; 继续循环

    DISP_RESULT:
        ; 【考点6】显示结果提示信息
        LEA DX, RESULT
        MOV AH, 09H
        INT 21H

        ; 【考点7】将计数器的值转换为ASCII码并显示
        MOV DL, COUNT
        ADD DL, 30H       ; 数字0~9转换为ASCII码'0'~'9'
        MOV AH, 02H       ; 显示一个字符的功能号
        INT 21H

        ; 程序退出
        MOV AH, 4CH
        INT 21H
    CODE ENDS
    END START
    ```
*   **执行示例**：输入`"HelloWORLD123"`，程序统计出大写字母`H`,`W`,`o`,`r`,`l`,`d`? 等等，这里`o`,`r`,`l`,`d`是小写。更正：`H`,`W`,`O`,`R`,`L`,`D`共6个，屏幕显示`6`。
*   **评分标准**：缓冲区定义(2分)、输入字符串(2分)、循环控制(2分)、大写字母判断(3分)、计数器操作(2分)、结果转换与显示(3分)、程序结构完整(2分)、注释清晰(1分)。

---
## 第9页：汇编语言复习冲刺（易错点+避坑指南+背诵清单）

### 一、终极易错点清单（考试高频丢分点，逐点规避）

| 易错点类别 | 典型错误示例 | 错误原因分析 | 正确做法/规避方法 |
| :--- | :--- | :--- | :--- |
| **1. 指令操作数类型不匹配** | `MOV AL, 256` <br> `ADD AX, BL` | 立即数超出目标寄存器范围（8位AL范围0-255）<br> 源和目的操作数位数不一致（16位AX vs 8位BL） | 确保操作数位数匹配。`MOV AL, 100` (十进制) 或 `MOV AX, 256`。<br> 使用位数一致的寄存器：`ADD AL, BL` 或 `MOVZX AX, BL` (零扩展)后相加。 |
| **2. 内存操作数寻址错误** | `MOV [BX], [SI]` <br> `MOV AX, [BX+BP]` | x86指令集不支持**内存到内存**的直接传送。<br> 在8086中，`[BX+BP]`是**非法寻址方式**，不能同时使用两个基址寄存器。 | 必须通过寄存器中转：`MOV AX, [SI]` ; `MOV [BX], AX`。<br> 只能使用`[BX+SI]`, `[BX+DI]`, `[BP+SI]`, `[BP+DI]`这四种组合。 |
| **3. 段寄存器使用错误** | `MOV DS, 1000H` <br> `MOV CS, AX` | **立即数不能直接送段寄存器**。<br> **CS寄存器不能作为MOV指令的目的操作数**（CS只能通过JMP, CALL, RET等指令修改）。 | 通过通用寄存器中转：`MOV AX, 1000H` ; `MOV DS, AX`。<br> 使用段间跳转指令修改CS：`JMP FAR PTR LABEL`。 |
| **4. 标志位判断混淆** | 比较有符号数后用`JA/JB`<br> 比较无符号数后用`JG/JL` | `JA`(高于)/`JB`(低于)用于**无符号数**比较。<br> `JG`(大于)/`JL`(小于)用于**有符号数**比较。 | 牢记：<br> **无符号**：JA/JB/JAE/JBE (看CF, ZF)。<br> **有符号**：JG/JL/JGE/JLE (看SF, OF, ZF)。 |
| **5. 循环/移位次数错误** | `SHL AX, 3` <br> `LOOP`前未初始化CX | 当移位次数>1时，必须用**CL寄存器**存放次数。<br> `LOOP`指令依赖CX，未初始化会导致不可预知的循环次数。 | `MOV CL, 3` ; `SHL AX, CL`。<br> 循环前必须给CX赋初值：`MOV CX, 循环次数`。 |
| **6. 串操作前提缺失** | 使用`MOVSB`前未设`DF`<br> 使用`REP MOVSB`未初始化`CX` | 方向标志`DF`未设置，`SI/DI`可能朝错误方向移动。<br> `CX`未初始化，`REP`前缀不知道重复多少次。 | 明确方向：`CLD` (DF=0, 递增) 或 `STD` (DF=1, 递减)。<br> 必须初始化`CX`为要操作的单元数，`DS:SI`和`ES:DI`指向源/目的串。 |
| **7. 子程序现场保护不全** | 子程序中修改了`BX`, `SI`，但未保护 | 主程序可能正在使用`BX`, `SI`，被子程序修改后导致主程序逻辑错误。 | 在子程序开头`PUSH`所有要使用的寄存器（除了用作返回值的），结尾按相反顺序`POP`。 |
| **8. 堆栈操作不平衡** | `PUSH`和`POP`次数不匹配<br> `CALL`和`RET`不匹配 | 导致`SP`指针错乱，严重时程序崩溃。<br> 段内`CALL`对应`RET`，段间`CALL FAR PTR`对应`RETF`。 | 确保`PUSH`/`POP`成对出现。<br> 用`RET n`来平衡通过堆栈传递的参数。 |
| **9. 程序无退出或退出方式错误** | 代码执行完直接“跑飞”<br> 用`JMP $`或`HLT`结束 | 在DOS环境下，程序执行完后必须将控制权交还DOS。<br> `JMP $`是死循环，`HLT`是停机指令，都不符合DOS编程规范。 | 程序末尾必须使用：`MOV AH, 4CH` ; `INT 21H`。这是标准且安全的退出方式。 |

### 二、考试答题技巧（大题高分指南）

1.  **选择题 & 填空题**：
    *   **排除法**：先排除明显错误的选项（如指令格式错误、寻址方式非法）。
    *   **关键词联想**：看到“串比较”想`CMPS`，看到“取偏移地址”想`LEA`，看到“中断返回”想`IRET`。
    *   **固定答案**：中断向量表范围（0000:0000~0000:03FF）、`LOOP`用`CX`、`REP`用`CX`、`SCAS`用`AL/AX`等，直接背诵。

2.  **简答题**：
    *   **分点作答，条理清晰**：例如中断过程、子程序结构等，按步骤1、2、3…列出。
    *   **使用专业术语**：用“保护现场”、“恢复现场”、“参数传递”、“堆栈平衡”等术语，避免口语化。
    *   **核心公式**：中断向量地址 = 类型码 × 4；物理地址 = 段地址 × 16 + 偏移地址。务必写对。

3.  **编程大题**：
    *   **步骤化编程**：
        1.  **定义数据段** (`DATA SEGMENT`)：变量、缓冲区、字符串。
        2.  **定义代码段，关联段寄存器** (`ASSUME`, `MOV DS, AX`)。
        3.  **主程序逻辑**：初始化 -> 处理 -> 输出 -> 退出。
        4.  **子程序** (如需)：`PROC`/`ENDP`框架，保护现场，核心逻辑，恢复现场，`RET`。
        5.  **程序退出**：`MOV AH, 4CH` / `INT 21H`。
    *   **注释**：即使代码有小瑕疵，清晰的注释（如`; 初始化计数器`、`; 判断是否为字母`）也能让阅卷老师理解你的思路，可能获得步骤分。
    *   **时间分配**：先完成框架和核心逻辑，若有时间再优化细节。确保“程序结构完整”和“能正常退出”这两项基本分拿到。

### 三、终极背诵清单（考前1小时必背）

| 类别 | 核心要点 | 记忆口诀/说明 |
| :--- | :--- | :--- |
| **1. 寻址方式** | 立即、寄存器、直接、寄存器间接、寄存器相对、基址变址、相对基址变址 | 一找数，二找址，三看组合。立即数在指令里，寄存器里直接取，内存寻址看[ ]。 |
| **2. 常用指令** | `MOV`（传），`ADD/SUB`（算），`CMP`（比），`JMP/Jxx`（跳），`LOOP`（环），`CALL/RET`（调），`INT`（断） | 传送运算和比较，跳转调用与循环。 |
| **3. 标志位** | **ZF**（零），**CF**（进位/借位），**SF**（符号），**OF**（溢出） | 运算看结果，跳转看标志。ZF=1结果为0，CF=1有进位/借位，SF=1结果为负，OF=1有溢出。 |
| **4. 条件转移** | **无符号**：JA/JB/JAE/JBE/JE/JNE<br>**有符号**：JG/JL/JGE/JLE/JE/JNE | **无符号**：Above/Below。<br>**有符号**：Greater/Less。<br>**相等/不等**：JE/JNE 通用。 |
| **5. 中断** | **向量表**：0000:0000~0000:03FF。<br>**向量地址**：n × 4。<br>**过程**：请求-响应-保护-获取向量-执行ISR-`IRET`返回。<br>**DOS功能调用**：`INT 21H`，`AH`放功能号。 | 表在最低1K，地址乘4得。保护CS/IP/FLAGS，`IRET`全恢复。`4CH`是退出，`09H`显字符串。 |
| **6. 子程序** | 结构：`PROC`...`ENDP`。<br> 调用：`CALL`。<br> 返回：`RET`/`RETF`。<br> 现场保护：`PUSH`/`POP`。 | 调用压IP，返回弹IP。段间调用压CS。保护现场逆序弹。 |
| **7. 串操作** | 指令：`MOVS`/`CMPS`/`SCAS`/`LODS`/`STOS`。<br> 前缀：`REP`/`REPE`/`REPNE`。<br> 寄存器：`DS:SI`源，`ES:DI`目，`CX`计数，`DF`方向。 | 源是`DS:SI`，目的是`ES:DI`，`CX`记次数，`DF`定方向。`REP`重复做，`E`/`NE`看`ZF`。 |
| **8. 伪指令** | `SEGMENT`/`ENDS`（段），`DB`/`DW`/`DD`（变量），`PROC`/`ENDP`（过程），`ASSUME`（关联），`END`（结束） | 定义段和数据，过程有始终。关联段寄存器，程序`END`告终。 |

### 四、考前提醒（必看）

1.  **心态平稳**：汇编语言考察细致，但考点固定。把该记的指令、格式、规则记牢，把易错点再过一遍。
2.  **审题仔细**：选择题看清是“正确”还是“错误”；填空题注意单位（H/B）；编程题明确要求（完整程序/程序段、子程序、中断）。
3.  **先易后难**：确保选择、填空、简答等基础题得分。编程大题先搭框架，再补逻辑。
4.  **检查格式**：指令助记符大写，标号后有冒号，操作数顺序（目的在前），字符串结尾符`$`，程序退出指令。
5.  **时间管理**：给最后的编程大题留出至少30分钟。如果某题卡住，先做标记，完成其他题目后再回来思考。

**祝你考试顺利，取得优异成绩！**