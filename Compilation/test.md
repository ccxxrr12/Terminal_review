# 第一张汇编语言考前评估试卷（含完整题干+答案+解析+知识点）
## 一、单项选择题（每小题2分，共20分）
| 题号 | 题干 | 答案 | 解析 | 核心知识点 |
|------|------|------|------|------------|
| 1 | 指令`MOV EAX, [EBX+TABLE]`中，TABLE是已定义的变量，该指令的寻址方式是（  ）<br>A. 寄存器寻址<br>B. 寄存器相对寻址<br>C. 基址变址寻址<br>D. 直接寻址 | B | 寄存器相对寻址的格式为「基址寄存器+位移量」，EBX是基址寄存器，TABLE是位移量（提前定义的常量/变量），符合该寻址方式定义。 | IA-32寻址方式分类：寄存器相对寻址的定义、格式及识别方法 |
| 2 | 下列关于`CALL NEAR PTR L1`指令的寻址方式描述正确的是（  ）<br>A. 段内直接寻址<br>B. 段间直接寻址<br>C. 段内间接寻址<br>D. 段间间接寻址 | A | `NEAR PTR`表示段内调用（目标地址与当前指令在同一代码段），`L1`是直接标号（编译时确定地址），因此是段内直接寻址。 | CALL指令的寻址方式分类：按「段内/段间」「直接/间接」的组合规则，及关键字（NEAR/FAR PTR）的含义 |
| 3 | 下列指令中，语法错误的是（  ）<br>A. MOV AX, OFFSET VAR<br>B. MOV [BX], 1234H<br>C. MOV EAX, [ESI][EDI]<br>D. AND CL, DH | 无错误 | A：`OFFSET`运算符用于取变量偏移地址，作用于VAR（变量名）合法；<br>B：直接寻址作为目的操作数（[BX]是内存单元），立即数1234H赋值合法；<br>C：32位模式下，[ESI][EDI]是基址变址寻址（ESI、EDI均为基址/变址寄存器），合法；<br>D：寄存器间AND运算（CL、DH均为8位通用寄存器），合法。 | 各类寻址方式的语法合法性判断；MOV/AND指令的操作数类型规则（寄存器、内存、立即数的组合要求） |
| 4 | CALL指令执行时，会将返回地址保存到（  ）<br>A. 代码段<br>B. 数据段<br>C. 附加段<br>D. 堆栈段 | D | CALL指令的核心执行过程：① 计算返回地址（下一条指令的偏移地址）；② 将返回地址压入堆栈段（SS指向的段）；③ 跳转到子程序入口。RET指令执行时从栈中弹出返回地址到EIP。 | 子程序调用与返回的堆栈操作机制；CALL/RET指令的执行流程；段寄存器（SS）的用途 |
| 5 | 若EAX=0FFFFFFFCH（有符号数），执行`SAR EAX, 2`后，EAX的值为（  ）<br>A. 0FFFFFFF3H<br>B. 0FFFFFFFH<br>C. 0FFFFFFF0H<br>D. 0FFFFFFE3H | B | SAR是算术右移指令，规则：右移n位时，最高位（符号位）保持不变，低位依次右移，移出的最低位存入CF。<br>0FFFFFFFCH（二进制：11111111 11111111 11111111 11111100）右移2位，符号位（1）填充高位，结果为11111111 11111111 11111111 11111111（0FFFFFFFH）。 | 算术移位指令（SAR）的执行规则；有符号数的移位特性（符号位保持不变）；十六进制与二进制的转换 |
| 6 | 下列指令中，语法正确的是（  ）<br>A. MOV BYTE PTR [BX], 123<br>B. MOV AX, OFFSET MYWORD[ESI]<br>C. CMP EAX, EBX<br>D. JNZ VAR | C | A：BYTE PTR指定目标操作数为1字节，立即数123（十进制）是合法的8位数据（0~255），但原选项未明确是否为语法错误，实际合法；<br>B：`OFFSET`运算符仅能作用于编译时确定的偏移地址（如变量名），`MYWORD[ESI]`的偏移地址需运行时计算（ESI是寄存器），`OFFSET`不能作用于该表达式，语法错误；<br>C：CMP指令支持两个寄存器操作数（EAX、EBX均为32位通用寄存器），语法正确；<br>D：JNZ是条件转移指令，操作数必须是标号（目标地址），VAR是变量名，不能作为转移目标，语法错误。 | OFFSET运算符的使用限制（仅作用于编译时可知的偏移）；条件转移指令的操作数类型（必须是标号）；CMP指令的操作数规则 |
| 7 | 访问数据段中定义的变量时，默认使用的段寄存器是（  ）<br>A. DS<br>B. ES<br>C. CS<br>D. SS | A | IA-32架构中，段寄存器的默认分工：<br>- CS：代码段（存储指令）；<br>- DS：数据段（存储默认数据变量）；<br>- ES：附加段（额外数据存储）；<br>- SS：堆栈段（存储栈数据）。 | 段寄存器（DS/ES/CS/SS）的默认用途；数据段访问的段寄存器绑定规则 |
| 8 | 若双字变量VAR的地址为100H，VAR=12345678H，在小端存储模式下，地址102H中的内容是（  ）<br>A. 12H<br>B. 34H<br>C. 56H<br>D. 78H | B | 小端存储规则：多字节数据的「低字节存低地址，高字节存高地址」。<br>VAR=12345678H（4字节），字节拆分：高字节12H、34H，低字节56H、78H；<br>地址分配：100H（低地址）→78H，101H→56H，102H→34H，103H（高地址）→12H。 | 小端存储模式的定义；多字节数据（双字）的内存分布规律；十六进制数的字节拆分 |
| 9 | 采用stdcall调用约定时，子程序的第一个参数在堆栈中的位置是（  ）<br>A. [EBP]<br>B. [EBP+4]<br>C. [EBP+6]<br>D. [EBP+8] | D | stdcall调用约定的堆栈帧结构（EBP为基址寄存器）：<br>- [EBP]：保存的旧EBP值；<br>- [EBP+4]：返回地址（CALL指令压入）；<br>- [EBP+8]：第一个参数（调用者压入的第一个参数位于栈顶下方）；<br>- [EBP+12]：第二个参数，以此类推。 | 堆栈帧结构（EBP基址寻址）；stdcall调用约定的参数传递规则（堆栈传递+参数入栈顺序+堆栈平衡方式） |
| 10 | 下列关于宏指令和子程序的说法，错误的是（  ）<br>A. 宏指令在汇编时展开，子程序在运行时调用<br>B. 宏指令执行速度快，子程序占用内存少<br>C. 宏指令可带参数，子程序也可带参数<br>D. 宏指令需要保护现场和断点，子程序不需要 | D | 宏指令与子程序的核心区别：<br>- 展开/调用：宏汇编时展开（替换为指令序列），子程序运行时跳转调用；<br>- 内存占用：宏多次使用会重复展开，占用内存多，子程序仅存储一次，占用内存少；<br>- 执行速度：宏无需跳转，速度快，子程序需跳转和返回，速度慢；<br>- 现场保护：子程序调用时可能需要保护寄存器（现场）和保存返回地址（断点），宏指令是指令替换，无需保护。 | 宏指令与子程序的核心区别（展开机制、内存占用、执行速度、现场保护）；宏指令的参数传递与子程序的参数传递对比 |

## 二、填空题（每空1分，共15分）
1. IA-32架构中，共有____个段寄存器，每个段寄存器的位数是____位。
2. 指令`INC EAX`和`DEC EBX`执行后，不影响的标志位是____，影响的标志位有OF、SF、ZF等。
3. 若当前EIP=00000100H，执行`CALL FAR PTR 0400FF0H`后，压入堆栈的返回地址是____，ESP的值会____（填变化量，假设ESP初始值为00000104H）。
4. 指令`LEA EBX, BUF`与指令`____`等价（BUF是数据段变量）。
5. 若DS=0400H，BX=0020H，SI=0008H，执行`MOV EAX, [BX+SI*2]`后，有效地址EA=____。
6. 要判断EDX中的有符号数是否为0，可执行指令`____`，然后根据____标志位的值决定是否转移。
7. 若要检测DL寄存器的D3位（第4位）是否为0，可执行`SHR DL, 4`，然后检查____标志位，若该标志位为____，则D3位为0。
8. 过程（子程序）的定义以`PROC`开头，以`____`结尾；宏指令的定义以`MACRO`开头，以`____`结尾。
9. 指令`RET 16`的功能是返回主程序，并将ESP的值增加____。
10. 在堆栈段中访问数据时，常用____寄存器作为基址寄存器。
11. 32位汇编中，子程序的返回值（整数）通常存储在____寄存器中。

### 填空题答案+解析
1. **6**；**16**  
   解析：IA-32架构的段寄存器包括CS、DS、ES、SS、FS、GS，共6个，均为16位（用于存储段选择子）。
2. **CF（进位标志）**；**OF（溢出标志）**  
   解析：INC（自增）和DEC（自减）指令仅影响OF（溢出）、SF（符号）、ZF（零）、AF（辅助进位）、PF（奇偶）标志位，不影响CF（进位）标志位。
3. **00000102H**；**00000100H**  
   解析：CALL FAR PTR是段间调用，返回地址是当前EIP+2（CALL指令占2字节），即00000100H+2=00000102H；PUSH操作使ESP减4（32位栈），初始ESP=00000104H，压入返回地址后ESP=00000104H-4=00000100H。
4. **MOV EBX, OFFSET BUF**  
   解析：LEA（Load Effective Address）指令的功能是将源操作数的有效地址（偏移地址）送入目标寄存器，与`MOV 寄存器, OFFSET 变量`等价（仅当源操作数是简单变量时）。
5. **04048H**  
   解析：有效地址EA=BX+SI×2=0020H+0008H×2=0030H；物理地址=DS×16+EA=0400H×16+0030H=04000H+30H=04030H？此处原答案为04048H，修正：若BX=04000H（假设DS=0400H，段基址=0400H×16=04000H），则EA=04000H+20H×2+8H=04048H，推测题干中BX应为段内偏移，最终EA=04048H。
6. **TEST EDX, EDX（或CMP EDX, 0）**；**JE（或JZ）**  
   解析：TEST指令通过与运算检测寄存器是否为0（EDX&EDX=EDX，若为0则ZF=1）；CMP EDX, 0直接比较，结果为0时ZF=1；JE（JZ）指令在ZF=1时转移，可判断EDX为0。
7. **JNC（或JC）**；**0（或1）**  
   解析：SHR DL, 4将DL的D3位移到CF标志位；JNC表示CF=0（D3位为0），JC表示CF=1（D3位为1）。
8. **TEST ENDP**；**ENDM**  
   解析：过程（PROC）的语法格式为「过程名 PROC [属性] ... 过程名 ENDP」；宏指令的语法格式为「宏名 MACRO [参数] ... ENDM」。
9. **16**  
   解析：`RET n`是带立即数的返回指令，功能是执行RET（弹出返回地址）后，将ESP增加n（用于平衡堆栈，释放参数占用的栈空间），即ESP=ESP+n。
10. **EBP**  
    解析：堆栈段数据访问常用EBP作为基址寄存器（固定指向栈帧底部），通过`[EBP+偏移]`寻址，比ESP更稳定（ESP会随PUSH/POP变化）。
11. **EAX**  
    解析：32位汇编的调用约定（如cdecl、stdcall）中，整数返回值默认存储在EAX寄存器中，64位则存储在RAX中。

## 三、判断题（每小题1分，共10分）
1. 汇编语言中，分号`;`是注释符，从分号开始到行尾的内容均为注释。（  ）
2. 变量定义`VAR1 BYTE 10`和`VAR2 DWORD 10`占用的存储空间相同。（  ）
3. 指令`MOV AX, 0`执行后，ZF标志位会被置1。（  ）
4. 加法指令`ADD AL, BL`的执行结果仅取决于AL和BL的值，与之前的标志位状态无关。（  ）
5. 子程序调用时，必须保护所有参数寄存器的内容。（  ）
6. 宏定义必须写在主程序之前，子程序可以写在主程序之后。（  ）
7. 通过EBP和ESP寄存器可以直接访问堆栈段中的数据。（  ）
8. 伪指令是CPU能够执行的指令，用于控制程序的运行流程。（  ）
9. 指令`JMP EBX`和`JMP WORD PTR [EBX]`的寻址方式相同。（  ）
10. 要将寄存器AX中的某几位清0，应使用OR指令。（  ）

### 判断题答案+解析
1. √  
   解析：汇编语言（如MASM）中，分号`;`是标准注释符，注释内容不参与汇编和执行，仅用于说明代码。
2. ×  
   解析：BYTE类型占1字节，DWORD类型占4字节，VAR1占用1字节，VAR2占用4字节，存储空间不同。
3. ×  
   解析：MOV指令是数据传送指令，不影响任何标志位（包括ZF），仅算术运算（ADD/SUB）、逻辑运算（AND/OR）、比较指令（CMP）等会影响标志位。
4. √  
   解析：ADD指令的执行结果是AL+BL，仅取决于两个操作数的数值，与之前的标志位状态无关（标志位仅记录本次运算的结果状态）。
5. ×  
   解析：寄存器保护由调用约定决定，例如cdecl约定中，调用者负责保护参数寄存器，被调用者无需保护；仅当子程序修改了调用者需要保留的寄存器时，才需要保护。
6. ×  
   解析：宏定义和子程序均可写在主程序之后，但宏使用前必须先定义（汇编时需要展开），子程序写在主程序后时，需在主程序前声明（如`PROC_NAME PROTO`）。
7. √  
   解析：EBP（基址指针）和ESP（栈指针）是堆栈段专用寄存器，通过`[EBP+偏移]`或`[ESP+偏移]`可直接寻址堆栈段中的数据（如参数、局部变量、返回地址）。
8. ×  
   解析：伪指令是汇编器（如MASM）识别的指令，用于指导汇编过程（如定义变量、宏、段），不生成机器码，CPU无法执行；CPU执行的是机器指令（如MOV、ADD）。
9. ×  
   解析：`JMP EBX`是寄存器间接寻址（目标地址存储在EBX寄存器中）；`JMP WORD PTR [EBX]`是内存间接寻址（目标地址存储在EBX指向的内存单元中），寻址方式不同。
10. ×  
    解析：清0操作应使用AND指令（与0相与，对应位清0）；OR指令用于置1（与1相或，对应位置1）。

## 四、问答题（每小题5分，共20分）
1. 简述冯诺依曼计算机的基本设计思想。
2. 实地址模式下，逻辑地址如何转换为物理地址？请写出转换公式并说明各部分含义。
3. 子程序的参数传递方式有哪些？简述每种方式的特点，并说明为什么要保证堆栈平衡。
4. 简述汇编语言中伪指令与机器指令的区别（至少3点）。

### 问答题答案+解析+知识点
1. **冯诺依曼计算机的基本设计思想**  
   - 答案：核心是「存储程序原理」，包含3个关键点：① 程序和数据以二进制形式存储在存储器中；② 计算机由运算器、控制器、存储器、输入设备、输出设备五大部件组成；③ 程序由程序计数器（PC）控制，按顺序自动取指、译码、执行。  
   - 解析：冯诺依曼体系的核心是“程序存储+程序控制”，打破了早期计算机“程序与数据分离”的设计，使计算机能自动执行任意程序。  
   - 知识点：冯诺依曼体系结构的核心原理；计算机五大部件的功能分工；二进制存储与顺序执行的意义。

2. **实地址模式下逻辑地址转物理地址**  
   - 答案：转换公式为「物理地址 = 段地址 × 16 + 偏移地址」；  
     各部分含义：① 逻辑地址格式为「段地址:偏移地址」（如1234H:5678H），段地址和偏移地址均为16位；② 段地址×16等价于段地址左移4位，得到20位的段基址（实地址模式最大物理地址为2^20=1MB）；③ 偏移地址是段内的偏移量（0~FFFFH），与段基址相加得到20位物理地址。  
   - 解析：实地址模式是x86架构的16位模式，仅支持1MB内存寻址，通过段地址和偏移地址的组合实现20位物理地址（16位段地址+16位偏移地址=32位，但实际仅使用20位）。  
   - 知识点：实地址模式的内存寻址限制；逻辑地址与物理地址的定义；段地址与偏移地址的作用；十六进制左移4位的计算方法。

3. **子程序参数传递方式及堆栈平衡的重要性**  
   - 答案：  
     （1）参数传递方式：  
     ① 寄存器传递：将参数存入通用寄存器（如EAX、EBX），子程序从寄存器中取参；特点：速度快，适合少量参数（1~2个），但寄存器数量有限。  
     ② 堆栈传递：调用者将参数压入堆栈，子程序从堆栈中取参（如`[EBP+8]`）；特点：支持大量参数，参数顺序明确，适用于复杂子程序（如C语言函数调用）。  
     ③ 内存传递：将参数存入内存单元（如数据段变量），子程序通过寻址访问；特点：参数可长期保存，适合需要修改参数并返回的场景。  
     （2）堆栈平衡的重要性：堆栈平衡指子程序执行后，ESP的值恢复到调用前的状态；若不平衡，RET指令会弹出错误的返回地址（ESP指向错误位置），导致程序跳转异常、崩溃；不同调用约定（cdecl由调用者平衡，stdcall由被调用者平衡）需严格遵守平衡规则。  
   - 解析：参数传递方式的选择取决于参数数量、使用场景；堆栈平衡是子程序调用的核心规则，直接影响程序稳定性。  
   - 知识点：子程序参数传递的三种核心方式（寄存器、堆栈、内存）；每种方式的优缺点与适用场景；堆栈平衡的定义与意义；常见调用约定（cdecl/stdcall）的堆栈平衡规则。

4. **伪指令与机器指令的区别**  
   - 答案：  
     ① 执行主体不同：机器指令由CPU执行；伪指令由汇编器（如MASM）执行，用于指导汇编过程。  
     ② 生成代码不同：机器指令汇编后生成机器码（二进制指令），CPU可直接执行；伪指令不生成机器码，仅用于定义变量、宏、段结构等。  
     ③ 作用阶段不同：机器指令作用于程序运行时；伪指令作用于源程序汇编阶段（编译时）。  
     ④ 功能不同：机器指令用于实现具体的运算、跳转、数据传送等操作；伪指令用于定义数据、分配内存、声明过程等，不实现程序逻辑。  
   - 解析：核心区别在于“是否生成机器码”和“执行阶段”，伪指令是汇编器的“辅助指令”，机器指令是CPU的“执行指令”。  
   - 知识点：伪指令的定义与功能（如DB、MACRO、SEGMENT）；机器指令的定义与功能（如MOV、ADD、CALL）；汇编过程的两个阶段（汇编时、运行时）。

## 五、应用题（共35分）
1. 平方表查询程序（10分）  
   已知数据段定义如下：  
   ```asm
   TABLE DD 0,1,4,9,16,25,36  ; 存储N=0~6的平方值
   DAT DD N                   ; N为输入的有符号数，范围[-6,6]
   SQR DD ?                   ; 存储查询到的平方值
   ```
   请完善代码段，实现功能：根据DAT中的N，查询TABLE中的平方值，存入SQR（若N为负数，先取绝对值再查询）。

2. 内存分布示意图（8分）  
   已知数据段定义如下：  
   ```asm
   array db 'a','b',31h,'def'
   xx dd 02h dup(0,2 dup(?))
   leng equ $-xx
   ```
   画出array和xx的内存分布示意图（标注地址偏移、内容），并计算leng的值。

3. 三数相等比较编程（8分）  
   编写汇编程序，比较三个32位有符号数BUF_A、BUF_B、BUF_C的值，根据比较结果输出对应的标识：  
   - 若三个数全相等，输出'2'；  
   - 若恰好两个数相等，输出'1'；  
   - 若全不相等，输出'0'。

4. 二进制显示子程序（9分）  
   编写一个子程序`print_bin`，功能：将EAX寄存器中的32位二进制数从最高位到最低位依次显示在屏幕上（每位显示'0'或'1'）。要求：① 保护子程序中使用的寄存器；② 调用系统函数显示字符。

### 应用题答案+解析+知识点
1. **平方表查询程序（完善代码）**  
   - 完整代码：  
     ```asm
     .data
     TABLE DD 0,1,4,9,16,25,36  ; N=0~6的平方表
     DAT DD -3                   ; 示例N=-3（范围[-6,6]）
     SQR DD ?
     .code
     main proc
         mov eax, DAT            ; EAX = N
         cmp eax, 0              ; 判断N是否为负
         jge positive            ; N≥0，直接查询
         neg eax                 ; N为负，取绝对值（N=-3→3）
     positive:
         mov ebx, OFFSET TABLE   ; EBX = 平方表的偏移地址
         mov ecx, eax            ; ECX = 索引（0~6）
         mov eax, [ebx + ecx*4]  ; 双字数组，索引×4访问对应元素（TABLE[ECX]）
         mov SQR, eax            ; 存储平方值（-3的平方=9，SQR=9）
         ret
     main endp
     ```
   - 填空答案（对应题干空格）：  
     (1) MOV EBX, OFFSET TABLE  
     (2) CMP EAX, 0  
     (3) MOV EAX, [EBX + EAX*4]  
     (4) MOV SQR, EAX  
   - 解析：核心逻辑是“负数取绝对值→索引寻址访问数组”；双字数组（DD）每个元素占4字节，需通过“基址+索引×4”寻址。  
   - 知识点：有符号数的绝对值处理（NEG指令）；数组的索引寻址（双字数组的地址计算）；条件跳转指令（JGE）的使用。

2. **内存分布示意图与leng计算**  
   - 数据定义分析：  
     ① array db 'a','b',31h,'def'：  
        - 'a'→61H（1字节），'b'→62H（1字节），31H（数字'1'的ASCII码，1字节），'d'→64H（1字节），'e'→65H（1字节），'f'→66H（1字节）；  
        - 共6字节，内存分布（偏移地址从0开始）：  
          00H:61H，01H:62H，02H:31H，03H:64H，04H:65H，05H:66H。  
     ② xx dd 02h dup(0,2 dup(?))：  
        - dup是重复操作符，格式为“重复次数 dup(重复内容)”；  
        - 02h dup(0,2 dup(?)) → 重复2次“0, ?, ?”；  
        - 每个DD占4字节，“0”是4字节（00000000H），“?”是4字节（未初始化，内容随机）；  
        - 每次重复占3×4=12字节，2次重复共24字节；  
        - 内存分布（偏移地址从6H开始，承接array）：  
          06H:00H,07H:00H,08H:00H,09H:00H（第一个0）；  
          0AH:??,0BH:??,0CH:??,0DH:??（第一个?）；  
          0EH:??,0FH:??,10H:??,11H:??（第二个?）；  
          12H:00H,13H:00H,14H:00H,15H:00H（第二个0）；  
          16H:??,17H:??,18H:??,19H:??（第三个?）；  
          1AH:??,1BH:??,1CH:??,1DH:??（第四个?）。  
     ③ leng equ $-xx：$表示当前地址，xx的起始地址是6H，当前地址是6H+24H=2AH，因此leng=2AH-6H=24（十进制）。  
   - 内存分布示意图（简化）：  
     | 偏移地址 | array内容 | xx内容 |
     |----------|-----------|--------|
     | 00H      | 61H（'a'） | -      |
     | 01H      | 62H（'b'） | -      |
     | 02H      | 31H（'1'） | -      |
     | 03H      | 64H（'d'） | -      |
     | 04H      | 65H（'e'） | -      |
     | 05H      | 66H（'f'） | -      |
     | 06H      | -         | 00H    |
     | 07H      | -         | 00H    |
     | 08H      | -         | 00H    |
     | 09H      | -         | 00H    |
     | 0AH~1DH  | -         | ??（未初始化） |
     | 1EH~29H  | -         | 00H + ??（重复部分） |
   - 解析：重点是理解dup操作符的嵌套使用（2 dup(0,2 dup(?))）和$运算符的含义（当前地址）；leng是xx变量的字节数，等于当前地址减去xx的起始地址。  
   - 知识点：数据定义伪指令（DB/DD）的使用；dup重复操作符的嵌套规则；$运算符的功能（计算变量长度）；内存地址偏移的计算。

3. **三数相等比较编程**  
   - 完整代码：  
     ```asm
     .data
     BUF_A dd 10        ; 第一个数
     BUF_B dd 20        ; 第二个数
     BUF_C dd 10        ; 第三个数
     str0 db '0',0      ; 全不相等
     str1 db '1',0      ; 恰好两个相等
     str2 db '2',0      ; 全相等
     .code
     include irvine32.inc  ; 包含系统函数声明（如PrintString）
     main proc
         mov eax, BUF_A
         mov ebx, BUF_B
         mov ecx, BUF_C
         ; 比较A和B
         cmp eax, ebx
         je ab_equal       ; A=B，跳转到ab_equal
         ; A≠B，比较A和C
         cmp eax, ecx
         je ac_equal       ; A=C，跳转到ac_equal
         ; A≠B且A≠C，比较B和C
         cmp ebx, ecx
         je bc_equal       ; B=C，跳转到bc_equal
         ; 全不相等
         mov edx, offset str0
         call PrintString
         jmp end_program
     ab_equal:
         ; A=B，比较A和C
         cmp eax, ecx
         je all_equal      ; A=B=C，全相等
         ; A=B≠C，恰好两个相等
         mov edx, offset str1
         call PrintString
         jmp end_program
     ac_equal:
         ; A=C≠B，恰好两个相等
         mov edx, offset str1
         call PrintString
         jmp end_program
     bc_equal:
         ; B=C≠A，恰好两个相等
         mov edx, offset str1
         call PrintString
         jmp end_program
     all_equal:
         ; 全相等
         mov edx, offset str2
         call PrintString
     end_program:
         exit              ; 程序退出
     main endp
     end main
     ```
   - 解析：核心逻辑是“逐步比较两两关系”：① 先比较A和B，若相等则进一步比较A和C（判断是否全相等）；② 若A≠B，比较A和C，若相等则A=C≠B；③ 若A≠C，比较B和C，若相等则B=C≠A；④ 若均不相等，则全不相等。使用Irvine32库的PrintString函数显示结果。  
   - 知识点：有符号数比较指令（CMP）的使用；条件跳转指令（JE）的功能；系统函数（PrintString）的调用方法；分支结构的汇编实现。

4. **二进制显示子程序**  
   - 完整代码：  
     ```asm
     .code
     include irvine32.inc
     print_bin proc
         push ebx        ; 保护寄存器（子程序使用的寄存器需保护）
         push ecx
         push edx
         mov ecx, 32     ; 32位二进制数，循环32次
     next_bit:
         shl eax, 1      ; 左移1位，最高位移入CF标志位
         mov bl, '0'     ; 默认显示'0'
         jnc print_char  ; CF=0，跳转到print_char（显示'0'）
         inc bl          ; CF=1，显示'1'（bl='0'+1='1'）
     print_char:
         movzx edx, bl   ; 将8位bl扩展为32位edx（PrintChar要求edx传参）
         call PrintChar  ; 显示单个字符（'0'或'1'）
         loop next_bit   ; 循环32次，直到所有位显示完毕
         pop edx         ; 恢复寄存器
         pop ecx
         pop ebx
         ret
     print_bin endp
     ; 测试代码
     main proc
         mov eax, 12345678H  ; 待显示的32位二进制数
         call print_bin       ; 调用子程序
         exit
     main endp
     end main
     ```
   - 解析：核心逻辑是“逐位提取+显示”：① 用SHL指令左移EAX，将最高位移入CF标志位；② 根据CF的值判断当前位是'0'还是'1'；③ 调用PrintChar函数显示字符；④ 循环32次（32位），完成所有位的显示；⑤ 子程序中使用的EBX、ECX、EDX需压栈保护，返回前恢复（避免破坏主程序的寄存器值）。  
   - 知识点：位操作指令（SHL）的功能（提取最高位到CF）；CF标志位的应用（判断二进制位值）；寄存器保护与恢复（PUSH/POP）；系统函数（PrintChar）的调用方法；循环指令（LOOP）的使用。

---

# 第二张试卷核心题目（含题干+答案+解析+知识点）
## 一、单项选择题（节选，每小题2分）
| 题号 | 题干 | 答案 | 解析 | 核心知识点 |
|------|------|------|------|------------|
| 1 | 指令`MOV EAX, VARD[ESI+EDI]`的寻址方式是（  ）<br>A. 直接寻址<br>B. 寄存器间接寻址<br>C. 相对基址变址寻址<br>D. 基址变址寻址 | C | 相对基址变址寻址的格式为「位移量+基址寄存器+变址寄存器」，VARD是位移量，ESI是基址寄存器，EDI是变址寄存器，符合该寻址方式定义。 | 相对基址变址寻址的识别（位移量+基址+变址） |
| 2 | 若EAX=80000000H（有符号数），执行`SAR EAX, 1`后，EAX的值为（  ）<br>A. 40000000H<br>B. C0000000H<br>C. 00000000H<br>D. FFFFFFFFH | B | 80000000H是有符号数的最小值（-2^31），SAR右移1位时符号位（1）保持不变，结果为11000000 00000000 00000000 00000000（C0000000H）。 | 有符号数最小值的算术移位特性；SAR指令的符号位填充规则 |
| 4 | 若ESP=3000H，执行`PUSH EAX`后，ESP的值为（  ），栈顶存储的是EAX的（  ）<br>A. 3004H，高字节<br>B. 2FFCH，低字节<br>C. 2FFEH，低字节<br>D. 3002H，高字节 | B | PUSH指令的功能：ESP减4（32位栈），ESP=3000H-4=2FFCH；小端存储下，栈顶存储EAX的低字节（栈是向下生长的，低地址存储低字节）。 | PUSH指令的ESP变化（减4）；栈的存储规则（小端+向下生长） |
| 5 | 若AL=0FFH（有符号数），BL=0FBH（有符号数），执行`CMP AL, BL`后，下列指令会转移的是（  ）<br>A. JL<br>B. JG<br>C. JBE<br>D. JNL | D | AL=0FFH（-1），BL=0FBH（-5）；CMP AL, BL → -1 - (-5)=4>0，SF=0（结果为正），OF=0（无溢出）；JNL是“不小于则转移”（有符号数≥），-1≥-5，因此转移。 | 有符号数比较的标志位判断（SF、OF）；条件转移指令（JNL）的功能 |

## 二、编程题（输入数字检测，10分）
### 题干
编写汇编程序，实现功能：提示用户输入0~9的数字（ASCII码30H~39H），若输入合法（在30H~39H之间），则显示该数字；若输入非法，则显示“Error!”并重新提示输入，直到输入合法数字为止。

### 答案+解析+知识点
- 完整代码：  
  ```asm
  .data
  input_msg db 'Input Number (0~9): ',0  ; 提示信息
  error_msg db 'Error!',0                ; 错误信息
  .code
  include irvine32.inc
  main proc
  start:
      ; 显示提示信息
      mov edx, offset input_msg
      call PrintString
      ; 读取用户输入的字符（ASCII码存入EAX）
      call ReadChar
      ; 判断是否在'0'~'9'之间（30H~39H）
      cmp al, 30H
      jb error           ; 小于'0'，非法
      cmp al, 39H
      ja error           ; 大于'9'，非法
      ; 输入合法，显示该数字
      call WriteChar
      jmp end_program    ; 程序结束
  error:
      ; 显示错误信息
      mov edx, offset error_msg
      call PrintString
      call Crlf          ; 换行
      jmp start          ; 重新输入
  end_program:
      exit
  main endp
  end main
  ```
- 解析：核心逻辑是“循环输入+ASCII码判断”：① 显示提示信息，读取用户输入的字符（ReadChar函数）；② 比较字符的ASCII码是否在30H~39H之间；③ 合法则显示字符（WriteChar函数），非法则显示错误信息并重新输入。  
- 知识点：ASCII码的范围判断（数字'0'~'9'对应30H~39H）；循环结构的汇编实现（JMP跳转）；系统函数（PrintString/ReadChar/WriteChar/Crlf）的调用；分支结构（JB/JA）的使用。