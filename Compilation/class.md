## 一、汇编语言基础
### （一）寄存器
寄存器是CPU内部用于临时存储数据、地址和指令的高速存储单元，按功能分为三类，核心考点集中在名称、用途、数量及特殊搭配：
1. 通用寄存器
- 名称：EAX、EBX、ECX、EDX（32位），对应的16位形式为AX、BX、CX、DX，8位形式为AH/AL、BH/BL、CH/CL、DH/DL
- 数量：4个（32位通用寄存器）
- 用途：
  - EAX：累加器，常用于算术运算、数据传送，也是函数返回值的默认存储寄存器
  - EBX：基址寄存器，常用于存储内存偏移地址（作为基址指针）
  - ECX：计数器，常用于循环指令（LOOP）的循环次数计数
  - EDX：数据寄存器，常用于乘法（MUL）、除法（DIV）运算中存储高位结果或额外数据
2. 专用寄存器
- 核心考点：标志寄存器（EFLAGS），存储指令执行后的状态信息（如进位、溢出、零标志等），是算术运算、控制转移指令的判断依据
- 关键标志位：
  - CF（进位标志）：无符号数运算溢出时置1（如8位运算99+200=299，超出0-255范围）
  - OF（溢出标志）：有符号数运算溢出时置1（如8位有符号数127+5=132，超出-128~127范围）
  - ZF（零标志）：运算结果为0时置1（如SUB AX,AX后ZF=1）
  - SF（符号标志）：运算结果为负数时置1（最高位为1）
  - PF（奇偶标志）：结果中1的个数为偶数时置1
3. 段寄存器
- 名称：CS（代码段寄存器）、DS（数据段寄存器）、SS（堆栈段寄存器）、ES（附加段寄存器）、FS、GS
- 数量：6个
- 用途：存储对应段的段地址，与偏移地址配合生成物理地址
- 特殊搭配及用途（必考）：
  - CS:EIP：代码段寄存器+指令指针寄存器，指向当前要执行的指令地址（CPU自动读取该地址指令）
  - SS:ESP：堆栈段寄存器+堆栈指针寄存器，指向栈顶地址（PUSH/POP指令操作栈顶）
  - SS:EBP：堆栈段寄存器+基址指针寄存器，指向栈底（常用于子程序中访问局部变量和参数）

### （二）存储器组织
1. 存储规则及表示
- 存储单位：字节（Byte，8位）、字（Word，16位）、双字（Double Word，32位）
- 存储顺序：小端存储（低字节存低地址，高字节存高地址），例：双字0x12345678存储在地址1000H-1003H时，1000H=78H，1001H=56H，1002H=34H，1003H=12H
- 地址表示：十六进制表示（后缀H），如1000H、200AH
2. 物理地址生成方式（只考实地址模式）
- 实地址模式下地址总线为20位，物理地址=段地址×16（左移4位）+偏移地址
- 示例：段地址DS=1234H，偏移地址SI=5678H，物理地址=1234H×16 + 5678H=12340H+5678H=179B8H
3. 存储模型
- 平展模型：整个内存作为一个连续的地址空间，无分段（32位保护模式常用）
- 段式模型：内存划分为多个段（代码段、数据段等），每个段独立寻址
- 实地址模型：16位模式，段地址16位，偏移地址16位，最大寻址空间1MB（2^20）
4. 工作方式
- 实地址模式：16位工作模式，寻址空间1MB，无内存保护，DOS系统采用
- 保护模式：32位/64位工作模式，支持多任务、内存保护，寻址空间大（32位最大4GB），考试范围仅涉及实地址模式

## 二、编程结构
### （一）汇编语言程序格式
1. 程序框架（必考，编程题基础）
完整程序从数据段开始编写，标准框架如下：
```asm
DATA SEGMENT ; 数据段定义（伪指令）
    ; 变量定义区域（DB/DW/DD等）
    VAR1 DB 10H ; 定义字节变量VAR1，初始值10H
    VAR2 DW 2030H ; 定义字变量VAR2，初始值2030H
DATA ENDS ; 数据段结束

STACK SEGMENT STACK ; 堆栈段定义
    DW 100 DUP(?) ; 分配200字节堆栈空间（100个word）
STACK ENDS ; 堆栈段结束

CODE SEGMENT ; 代码段定义
    ASSUME CS:CODE, DS:DATA, SS:STACK ; 关联段寄存器与段
START: ; 程序入口（起始标号）
    MOV AX, DATA ; 初始化数据段寄存器DS
    MOV DS, AX ; 不能直接MOV DS, DATA，需通过AX中转
    
    ; 核心功能代码区域
    
    MOV AH, 4CH ; 程序退出功能号
    INT 21H ; 调用DOS中断，结束程序
CODE ENDS ; 代码段结束
END START ; 程序结束，指定入口标号
```
2. 关键说明：
- 段定义必须包含数据段（DATA）、代码段（CODE），堆栈段（STACK）可选但建议定义
- ASSUME伪指令仅声明段寄存器与段的关联，需通过MOV指令实际初始化DS（CS由系统自动初始化）

### （二）开发过程
1. 开发步骤（4步）
- 编写源程序：使用文本编辑器（如记事本、EditPlus）编写，扩展名.asm
- 汇编：使用汇编器（MASM）将.asm源文件转换为.obj目标文件（语法检查）
  - 命令：MASM 源文件名.asm; （分号可省略.obj文件名）
- 链接：使用链接器（LINK）将.obj文件转换为.exe可执行文件（解决段地址分配、外部引用）
  - 命令：LINK 目标文件名.obj;
- 运行与调试：使用DOSBox或Debug调试器运行.exe文件，排查错误
2. 生成的文件类型
- .asm：源程序文件（文本文件，可编辑）
- .obj：目标文件（二进制文件，不可直接运行）
- .exe：可执行文件（二进制文件，可直接运行）
- .lst：列表文件（汇编过程生成，包含源程序、机器码、地址，用于调试）
- .obj：交叉引用文件（记录符号引用关系）

## 三、寻址方式
寻址方式是指令中获取操作数或转移地址的方式，分为两大类，必考识别与应用：

### （一）与数据有关的寻址（3大类，核心考点）
1. 立即寻址
- 定义：操作数直接包含在指令中（立即数）
- 格式：指令 目的操作数, 立即数
- 示例：MOV AX, 1234H（AX=1234H）、ADD BL, 0AH（BL=BL+0AH）
- 注意：立即数不能作为目的操作数（如MOV 1234H, AX 错误）
2. 寄存器寻址
- 定义：操作数存储在寄存器中，指令指定寄存器名称
- 格式：指令 寄存器1, 寄存器2 / 立即数
- 示例：MOV CX, AX（CX=AX）、SUB DX, BX（DX=DX-BX）
- 特点：执行速度最快（无需访问内存）
3. 存储器寻址（包含多种类型，必考识别）
- 定义：操作数存储在内存中，指令通过段地址+偏移地址定位内存单元
- 核心公式：物理地址=段地址（默认/显式指定）+ 偏移地址（由寻址方式计算）
- 默认段寄存器规则：
  - 数据访问：默认DS段（如MOV AL, [SI] 访问DS:SI指向的内存）
  - 堆栈操作：默认SS段（如POP [BP] 访问SS:BP指向的内存）
  - 字符串操作：源串默认DS段，目的串默认ES段
- 具体类型及示例：
  - 直接寻址：偏移地址直接在指令中（用[]表示）
    - 示例：MOV AX, [1000H]（访问DS:1000H和DS:1001H单元，AX=该字数据）
    - 符号地址形式：MOV BX, VAR（VAR为已定义变量，等价于MOV BX, [VAR]）
  - 寄存器间接寻址：偏移地址存储在寄存器SI、DI、BX、BP中
    - 示例：MOV CL, [SI]（访问DS:SI指向的字节单元）、MOV DX, [BP]（访问SS:BP指向的字单元）
  - 寄存器相对寻址：偏移地址=寄存器值+位移量
    - 示例：MOV AL, [BX+10H]（访问DS:BX+10H指向的字节单元）、MOV CX, VAR[SI]（VAR为位移量，等价于[SI+VAR]）
  - 基址变址寻址：偏移地址=基址寄存器（BX/BP）+ 变址寄存器（SI/DI）
    - 示例：MOV AX, [BX+SI]（访问DS:BX+SI指向的字单元）、MOV DH, [BP+DI]（访问SS:BP+DI指向的字节单元）
  - 相对基址变址寻址：偏移地址=基址寄存器+变址寄存器+位移量
    - 示例：MOV BX, [BX+SI+20H]（访问DS:BX+SI+20H指向的字单元）、MOV WORD PTR [BP+DI+VAR], 3456H（VAR为位移量）

### （二）与转移地址有关的寻址（控制转移指令用）
1. 分类维度：按转移范围（段内/段间）、按地址获取方式（直接/间接）
2. 段内转移：转移指令与目标地址在同一代码段，仅需修改IP/EIP
- 段内直接转移：目标地址直接在指令中（标号形式）
  - 示例：JMP SHORT LABEL（短转移，位移量8位）、CALL NEAR PTR SUB1（近调用，位移量16位）
- 段内间接转移：目标地址存储在寄存器或内存单元中
  - 示例：JMP AX（AX中存储目标偏移地址）、JMP WORD PTR [BX]（DS:BX指向的字单元存储目标偏移地址）
3. 段间转移：转移指令与目标地址在不同代码段，需修改CS和IP/EIP
- 段间直接转移：指令中直接包含目标段地址和偏移地址
  - 示例：JMP FAR PTR LABEL（LABEL在另一段，指令包含该段CS值和偏移地址）
- 段间间接转移：不考，无需掌握
4. 对应指令：JMP（无条件转移）、CALL（子程序调用）、JXX（条件转移，如JE、JG、JB等）

## 四、指令系统
指令是CPU可执行的操作命令，按功能分类，必考指令格式、功能、标志位影响及应用：

### （一）数据传送类指令
1. MOV指令（最常用，必考操作数规则）
- 功能：将源操作数传送到目的操作数（源操作数不变）
- 格式：MOV 目的操作数, 源操作数
- 核心规则（违反即错误）：
  - 不能在两个内存单元间直接传送（如MOV [1000H], [2000H] 错误，需通过寄存器中转）
  - 不能将立即数传送到段寄存器（如MOV DS, 1234H 错误，需通过AX中转：MOV AX,1234H → MOV DS,AX）
  - 源操作数和目的操作数位数必须一致（如MOV AL, 1234H 错误，AL为8位，1234H为16位）
- 合法示例：MOV AL, BL、MOV CX, 5678H、MOV [SI], DX、MOV ES, AX
2. PUSH/POP指令（堆栈操作，必考堆栈变化）
- 堆栈特性：先进后出（FILO），栈底在高地址，栈顶在低地址（ESP指向栈顶，压栈ESP减小，出栈ESP增大）
- PUSH指令（压栈）：
  - 格式：PUSH 操作数（16位/32位，字节不能压栈）
  - 操作过程：ESP = ESP - 2（16位）/ 4（32位）→ 将操作数存入ESP指向的栈顶单元
  - 示例：PUSH AX（AX=1234H），执行后ESP=ESP-2，栈顶两单元存储34H、12H（小端）
- POP指令（出栈）：
  - 格式：POP 目的操作数（16位/32位，段寄存器除CS外均可）
  - 操作过程：将ESP指向的栈顶单元数据取出到目的操作数 → ESP = ESP + 2（16位）/ 4（32位）
  - 示例：POP BX，执行后BX=栈顶数据，ESP=ESP+2
- 注意：PUSH和POP必须成对使用，避免堆栈失衡
3. LEA指令（取有效地址）
- 功能：将源操作数的偏移地址传送到目的寄存器（非数据内容）
- 格式：LEA 寄存器, 内存操作数
- 示例：LEA SI, VAR（SI=VAR的偏移地址，而非VAR的值）、LEA DX, [BX+SI+10H]（DX=BX+SI+10H的计算结果）
- 区别于MOV：MOV SI, OFFSET VAR 与 LEA SI, VAR 功能相同，但LEA支持动态计算偏移地址（如LEA SI, [BX+10H]，MOV无法直接实现）
4. XLAT指令（查表转换，注意应用）
- 功能：将BX指向的表格中，AL为索引的单元数据取出，存入AL（表格为字节型）
- 操作过程：AL = DS:[BX + AL]
- 使用步骤：
  1. 将表格首地址的偏移地址存入BX
  2. 将表格索引（0~n）存入AL
  3. 执行XLAT，AL得到表格中对应索引的内容
- 示例：表格TABLE DB 0,1,2,3,4,5（偏移地址0~5），执行MOV BX, OFFSET TABLE → MOV AL, 3 → XLAT后，AL=3

### （二）算术运算类指令
1. 核心指令：ADD（加）、SUB（减）、INC（加1）、DEC（减1）、CMP（比较）
2. 指令格式与功能：
- ADD 目的, 源：目的 = 目的 + 源（如ADD AX, BX、ADD [SI], 0AH）
- SUB 目的, 源：目的 = 目的 - 源（如SUB CL, DL、SUB DX, 1234H）
- INC 目的：目的 = 目的 + 1（如INC CX、INC BYTE PTR [DI]，无需源操作数）
- DEC 目的：目的 = 目的 - 1（如DEC EDX、DEC WORD PTR [BP]）
- CMP 目的, 源：目的 - 源（结果不存入目的，仅影响标志寄存器），用于后续条件转移
3. 对标志位的影响（必考，与JXX指令配合）
- ADD/SUB/CMP：影响CF、OF、ZF、SF、PF标志位
- INC/DEC：不影响CF标志位，影响ZF、SF、PF标志位
- 具体影响示例：
  - ADD AL, 0FFH（AL初始为1）：结果=100H，CF=1（进位），ZF=0，SF=0
  - SUB BL, BL：结果=0，ZF=1，CF=0，SF=0
  - CMP AH, 80H（AH=7FH）：7FH-80H=FFH，SF=1（结果为负），CF=1（借位），OF=0
4. 溢出与进位的区别（必考）
- 进位（CF）：针对无符号数，运算结果超出其表示范围（最高位产生进位/借位）
  - 示例：8位无符号数 250 + 10 = 260 → 超出0~255，CF=1
  - 16位无符号数 65530 + 10 = 65540 → 超出0~65535，CF=1
- 溢出（OF）：针对有符号数，运算结果超出其表示范围（正+正=负，负+负=正）
  - 示例：8位有符号数 120 + 10 = 130 → 超出-128~127，OF=1（结果二进制10000010，SF=1，实际为-126，与预期正结果矛盾）
  - 8位有符号数 -120 + (-10) = -130 → 超出范围，OF=1（结果二进制01111110，SF=0，实际为126，与预期负结果矛盾）
- 关键判断：无符号数看CF，有符号数看OF

### （三）位处理指令
1. 位运算指令（功能和应用必考）
- AND（按位与）：
  - 功能：对应位都为1则结果为1，否则为0
  - 应用：清0特定位（与0按位与）、保留特定位（与1按位与）
  - 示例：AND AL, 0FH（清AL高4位，保留低4位，如AL=12H → 02H）
- OR（按位或）：
  - 功能：对应位有1则结果为1，否则为0
  - 应用：置1特定位（与1按位或）
  - 示例：OR BL, 80H（置BL最高位为1，如BL=34H → B4H）
- NOT（按位非）：
  - 功能：各位取反（0→1，1→0）
  - 格式：NOT 操作数（无源操作数）
  - 示例：NOT CL（CL=0FH → F0H）
- NEG（求补）：
  - 功能：对操作数求补码（等价于 0 - 操作数）
  - 影响标志位：CF=1（操作数非0时），OF=1（操作数为最小负数时，如8位-128求补仍为-128）
  - 示例：NEG DH（DH=05H → FBH；DH=80H → 80H，OF=1）
- TEST（测试）：
  - 功能：按位与运算，结果不存入操作数，仅影响标志位（同CMP）
  - 应用：检测特定位是否为1
  - 示例：TEST AX, 0001H（检测AX最低位是否为1，若为1则ZF=0，否则ZF=1）
2. 移位指令（功能和应用必考）
- 逻辑移位（SHL、SHR）：不考虑符号位，移位后空位补0
  - SHL（逻辑左移）：
    - 功能：各位左移n位，最低位补0，最高位移入CF
    - 应用：无符号数乘以2^n（如SHL AL, 1 → AL×2）
    - 示例：SHL BL, 2（BL=03H → 0CH，CF=0；BL=80H → 00H，CF=1）
  - SHR（逻辑右移）：
    - 功能：各位右移n位，最高位补0，最低位移入CF
    - 应用：无符号数除以2^n（如SHR CX, 1 → CX÷2）
    - 示例：SHR DX, 3（DX=100H → 20H，CF=0）
- 算术移位（SAL、SAR）：考虑符号位，适用于有符号数
  - SAL（算术左移）：与SHL功能完全相同（左移补0，最高位移入CF）
  - SAR（算术右移）：
    - 功能：各位右移n位，最高位（符号位）保持不变，最低位移入CF
    - 应用：有符号数除以2^n（如SAR AL, 1 → AL÷2，向下取整）
    - 示例：SAR BH, 1（BH=0F0H（-16）→ 0F8H（-8），CF=0；BH=00H → 00H，CF=0）
- 循环移位（ROR、ROL、RCR、RCL）：移位时溢出位循环移入另一端
  - ROL（循环左移）：最高位移入CF和最低位
  - ROR（循环右移）：最低位移入CF和最高位
  - RCL（带进位循环左移）：最高位移入CF，CF移入最低位
  - RCR（带进位循环右移）：最低位移入CF，CF移入最高位
  - 示例：ROL CL, 1（CL=01H → 02H，CF=0；CL=80H → 01H，CF=1）

### （四）控制转移指令
1. JMP指令（无条件转移）
- 功能：无条件跳转到目标地址，不影响标志位
- 分类：段内短转移（SHORT，位移量8位，范围±127字节）、段内近转移（NEAR，位移量16位）、段间远转移（FAR，修改CS和IP）
- 示例：JMP LABEL（段内直接转移）、JMP AX（段内间接转移）、JMP FAR PTR LABEL2（段间转移）
2. JXX指令（条件转移，必考有符号数和无符号数区别）
- 功能：根据标志寄存器状态决定是否转移（转移则IP/EIP=IP/EIP+位移量，否则执行下一条）
- 核心考点：区分有符号数和无符号数的条件转移指令
  - 无符号数比较（针对CF、ZF）：
    - JE/JZ：等于则转移（ZF=1）
    - JNE/JNZ：不等于则转移（ZF=0）
    - JB/JNAE：低于/不高于等于则转移（CF=1）
    - JNB/JAE：不低于/高于等于则转移（CF=0）
    - JA/JNBE：高于/不低于等于则转移（CF=0且ZF=0）
    - JNA/JBE：不高于/低于等于则转移（CF=1或ZF=1）
  - 有符号数比较（针对SF、OF、ZF）：
    - JE/JZ：等于则转移（ZF=1）
    - JNE/JNZ：不等于则转移（ZF=0）
    - JL/JNGE：小于/不大于等于则转移（SF≠OF）
    - JNL/JGE：不小于/大于等于则转移（SF=OF）
    - JG/JNLE：大于/不小于等于则转移（SF=OF且ZF=0）
    - JNG/JLE：不大于/小于等于则转移（SF≠OF或ZF=1）
- 示例：
  - 无符号数比较：CMP AX, BX（AX=100，BX=200）→ JB LABEL（AX<BX，CF=1，转移）
  - 有符号数比较：CMP CX, DX（CX=-5，DX=3）→ JL LABEL（CX<DX，SF=1，OF=0，SF≠OF，转移）
3. LOOP指令（循环指令，必考替代指令、循环次数、转移范围）
- 功能：循环计数（CX自动减1），CX≠0则转移到目标标号
- 格式：LOOP 标号
- 操作过程：CX = CX - 1 → 若CX≠0，则转移到标号；否则执行下一条指令
- 循环次数：初始CX值即为循环次数（如CX=5，循环5次）
- 替代指令：
  - LOOPZ/LOOPE：CX减1后，CX≠0且ZF=1则转移
  - LOOPNZ/LOOPNE：CX减1后，CX≠0且ZF=0则转移
- 转移范围：段内短转移（位移量8位，范围±127字节）
- 示例：
```asm
MOV CX, 10 ; 循环10次
AGAIN:
    ; 循环体代码
    LOOP AGAIN ; CX减1，CX≠0则跳AGAIN
```
4. CALL/RET指令（子程序调用与返回，必考堆栈操作）
- CALL指令（调用子程序）：
  - 功能：保存返回地址（CS:IP）到堆栈，跳转到子程序入口
  - 堆栈操作（段内调用）：PUSH IP → IP=目标偏移地址
  - 堆栈操作（段间调用）：PUSH CS → PUSH IP → CS=目标段地址，IP=目标偏移地址
  - 示例：CALL SUB1（段内调用）、CALL FAR PTR SUB2（段间调用）
- RET指令（子程序返回）：
  - 功能：从堆栈中恢复返回地址到IP/CS，回到主程序
  - 堆栈操作（段内返回）：POP IP
  - 堆栈操作（段间返回）：POP IP → POP CS
  - 带参数返回（RET n）：返回后ESP=ESP+n（用于清理子程序调用时压入的参数）
  - 示例：RET（段内返回）、RET 4（段内返回，清理4字节参数）、RETF（段间返回）

### （五）串操作指令
- 考试要求：不做编程要求，但要知道rep和串操作指令的关系
- 核心串操作指令：MOVSB（字节串传送）、MOVSW（字串传送）、CMPSB（字节串比较）、SCASB（字节串扫描）等
- rep前缀功能：重复执行串操作指令，直到CX=0（CX为串长度）
- 关系：rep是串操作指令的重复前缀，通过CX控制重复次数，执行时CX自动减1，CX=0则停止重复
- 示例：MOV CX, 20 → REP MOVSB（传送20个字节串，DS:SI→ES:DI，SI和DI自动递增）

## 五、伪指令
伪指令是汇编程序识别的命令，不生成机器码，用于定义程序结构、变量、常量等，必考指令与伪指令的区别、变量定义、段定义等：

### （一）指令与伪指令的区别（必考）
| 特性         | 指令（机器指令）                | 伪指令（汇编伪指令）            |
|--------------|---------------------------------|---------------------------------|
| 执行主体     | CPU执行                         | 汇编器（MASM）处理              |
| 生成代码     | 生成对应的机器码（二进制指令）  | 不生成机器码，仅用于汇编控制    |
| 作用时机     | 程序运行时执行                  | 程序汇编（编译）时处理          |
| 示例         | MOV、ADD、JMP                   | SEGMENT、DB、EQU、END           |

### （二）核心伪指令
1. 段定义与程序结束伪指令
- SEGMENT/ENDS：定义段（代码段、数据段、堆栈段等）
  - 格式：段名 SEGMENT [属性] → 段体 → 段名 ENDS
  - 示例：DATA SEGMENT → ... → DATA ENDS
- ASSUME：关联段寄存器与段（告诉汇编器哪个段寄存器对应哪个段）
  - 格式：ASSUME 段寄存器:段名, ...
  - 示例：ASSUME CS:CODE, DS:DATA, SS:STACK
- ORG：指定段内偏移地址（默认从0开始）
  - 示例：ORG 100H（段内后续指令/变量从偏移100H开始分配地址）
- END：程序结束伪指令，指定程序入口标号
  - 格式：END 入口标号
  - 示例：END START（指定程序从START标号开始执行）
2. 变量定义伪指令（必考，含内存分布图绘制）
- 核心伪指令：DB（定义字节，1字节）、DW（定义字，2字节）、DD（定义双字，4字节）、DQ（定义四字）、DT（定义十字节）
- 重复定义伪指令：DUP（重复定义，格式：重复次数 DUP(初始值)）
- 字符定义：ASCII码存储，单字符用''，字符串用''（按顺序存储每个字符的ASCII码）
- 示例及内存分布（必考画图题）：
  - 示例1：VAR1 DB 10H, 'A', 3 DUP(0)
    - 内存分布（偏移地址从0开始）：
      00H: 10H（十六进制数）
      01H: 41H（'A'的ASCII码）
      02H: 00H（重复第1个0）
      03H: 00H（重复第2个0）
      04H: 00H（重复第3个0）
  - 示例2：VAR2 DW 1234H, 'AB', ?
    - 内存分布（小端存储）：
      00H: 34H（1234H的低字节）
      01H: 12H（1234H的高字节）
      02H: 41H（'A'的ASCII码，字的低字节）
      03H: 42H（'B'的ASCII码，字的高字节）
      04H: ?（未初始化，默认0或随机值）
  - 示例3：VAR3 DD 56789ABCH
    - 内存分布（小端存储）：
      00H: BCH
      01H: 9AH
      02H: 78H
      03H: 56H
- 内存分布图绘制要求：横向或纵向标注偏移地址、存储内容（十六进制），明确每个变量的占用字节数和存储顺序
3. 常量定义伪指令
- EQU：等价定义（不能重新定义）
  - 格式：常量名 EQU 表达式
  - 示例：COUNT EQU 10（COUNT=10）、MAX EQU 255
- =：赋值定义（可重新定义）
  - 格式：常量名 = 表达式
  - 示例：NUM = 5 → NUM = NUM + 3（NUM最终=8）
4. 属性操作符（必考，如OFFSET）
- OFFSET：取变量或标号的偏移地址
  - 示例：MOV SI, OFFSET VAR（SI=VAR的段内偏移地址）
- SEG：取变量或标号的段地址
  - 示例：MOV AX, SEG VAR（AX=VAR所在段的段地址）
- TYPE：取变量类型对应的字节数（DB=1，DW=2，DD=4）
  - 示例：TYPE VAR1（VAR1为DB类型，结果=1）、TYPE VAR2（VAR2为DW类型，结果=2）
- LENGTH：取变量的元素个数（仅对DUP定义的变量有效）
  - 示例：VAR3 DB 5 DUP(0) → LENGTH VAR3=5；VAR4 DW 10,20 → LENGTH VAR4=1（非DUP定义，结果=1）
- SIZE：取变量的总字节数（SIZE=TYPE×LENGTH）
  - 示例：VAR3 DB 5 DUP(0) → SIZE VAR3=1×5=5；VAR5 DD 3 DUP(?) → SIZE VAR5=4×3=12

## 六、程序设计
### （一）分支结构
1. 执行分支的条件判定（核心）
- 基于算术运算结果：通过ADD/SUB/CMP指令影响标志位，JXX指令判定
- 基于位状态：通过TEST/AND指令检测特定位，JXX指令判定（如ZF=0表示特定位为1）
2. 分支程序的编写（必考编程题）
- 单分支结构（if-else）：
```asm
; 示例：若AX > BX，则CX=1，否则CX=0（无符号数）
CMP AX, BX
JG BIGGER ; AX>BX则跳BIGGER
MOV CX, 0 ; 否则CX=0
JMP EXIT ; 跳过else部分
BIGGER:
MOV CX, 1 ; AX>BX则CX=1
EXIT:
; 后续代码
```
- 多分支结构（if-else if-else）：
```asm
; 示例：根据AL的值（0/1/2）给BL赋值（0→10H，1→20H，2→30H，其他→0）
CMP AL, 0
JE CASE0
CMP AL, 1
JE CASE1
CMP AL, 2
JE CASE2
MOV BL, 0 ; 其他情况
JMP EXIT
CASE0:
MOV BL, 10H
JMP EXIT
CASE1:
MOV BL, 20H
JMP EXIT
CASE2:
MOV BL, 30H
EXIT:
; 后续代码
```

### （二）循环结构
1. 循环程序的实现方式（3种，必考）
- 计数循环（基于CX+LOOP指令）：已知循环次数，最常用
```asm
; 示例：计算1~10的和，结果存入AX
MOV AX, 0 ; 累加器清0
MOV CX, 10 ; 循环10次（计数1~10）
MOV BX, 1 ; 初始值1
AGAIN:
ADD AX, BX ; AX=AX+BX
INC BX ; BX自增1
LOOP AGAIN ; CX减1，CX≠0则跳AGAIN
; 最终AX=55
```
- 条件循环（基于JXX指令）：未知循环次数，满足条件则循环
```asm
; 示例：从内存BUF开始查找0，找到后SI指向该单元（BUF为字节数组）
MOV SI, OFFSET BUF ; SI指向数组首地址
SEARCH:
MOV AL, [SI] ; 取当前单元数据
CMP AL, 0 ; 比较是否为0
JE FOUND ; 找到则跳FOUND
INC SI ; 未找到则SI自增
JMP SEARCH ; 继续查找
FOUND:
; SI指向0所在单元，后续代码
```
- 嵌套循环（多重循环）：外层循环控制内层循环次数，注意CX保护
```asm
; 示例：双重循环，外层5次，内层3次，AX累加计数
MOV AX, 0
MOV CX, 5 ; 外层循环次数
OUTER:
MOV DX, CX ; 保存外层CX
MOV CX, 3 ; 内层循环次数
INNER:
INC AX ; AX自增1
LOOP INNER ; 内层循环结束
MOV CX, DX ; 恢复外层CX
LOOP OUTER ; 外层循环结束
; 最终AX=5×3=15
```
2. 循环、多重循环程序的编写要求
- 循环初始化：设置循环计数（CX）、指针（SI/DI/BX）、累加器等
- 循环体：核心操作（数据处理、内存访问等）
- 循环控制：更新计数/指针，条件判断
- 多重循环注意：内层循环前保存外层循环的CX，内层循环结束后恢复，避免外层循环计数被破坏

### （三）子程序结构
1. 子程序的编写（注意定义和返回）
- 子程序定义格式：
```asm
; 子程序名：SUB_ADD，功能：计算两个数的和（AX= operand1，BX= operand2，结果AX=和）
SUB_ADD PROC NEAR ; NEAR表示段内子程序（默认），FAR表示段间
    ADD AX, BX ; 核心功能：AX=AX+BX
    RET ; 返回主程序
SUB_ADD ENDP ; 子程序结束
```
- 主程序调用格式：
```asm
; 主程序中调用SUB_ADD
MOV AX, 1234H ; 第一个操作数
MOV BX, 5678H ; 第二个操作数
CALL SUB_ADD ; 调用子程序，AX=1234H+5678H=68ACH
; 后续代码
```
2. 参数传递方式（3种，必考）
- 寄存器传递：参数通过通用寄存器传递（最快捷，适用于参数少的情况）
  - 示例：子程序SUB_MUL（AX=乘数1，BX=乘数2，结果DX:AX=乘积）
- 堆栈传递：参数先压入堆栈，子程序中通过BP指针访问（适用于参数多的情况）
  - 示例：主程序传递两个参数（10和20），子程序计算和并返回AX
    ```asm
    ; 主程序调用
    PUSH 10 ; 参数2压栈
    PUSH 20 ; 参数1压栈（栈中顺序：20→10，ESP指向10）
    CALL SUB_SUM ; 调用子程序
    ADD ESP, 4 ; 清理堆栈（两个参数共4字节）
    ; 子程序定义
    SUB_SUM PROC NEAR
        PUSH BP ; 保存BP
        MOV BP, SP ; BP=ESP，建立栈帧
        MOV AX, [BP+4] ; 取参数1（20，BP+4=ESP+4，跳过BP和返回地址）
        ADD AX, [BP+6] ; 加参数2（10）
        POP BP ; 恢复BP
        RET ; 返回，AX=30
    SUB_SUM ENDP
    ```
- 内存传递：参数存储在内存单元中，子程序通过变量名或指针访问（适用于参数量大或需保存参数的情况）
  - 示例：变量A和B存储参数，子程序读取A、B计算和存入C
    ```asm
    A DB 15
    B DB 25
    C DB ?
    ; 子程序
    SUB_SUM_MEM PROC NEAR
        MOV AL, A
        ADD AL, B
        MOV C, AL
        RET
    SUB_SUM_MEM ENDP
    ```
3. 堆栈的变化情况（必考）
- 段内调用子程序堆栈变化（以CALL SUB和RET为例）：
  1. 主程序执行CALL SUB：PUSH IP（返回地址）→ ESP=ESP-2
  2. 子程序执行PUSH BP：PUSH BP → ESP=ESP-2
  3. 子程序执行MOV BP, SP：BP=ESP（栈帧基址）
  4. 子程序执行POP BP：POP BP → ESP=ESP+2
  5. 子程序执行RET：POP IP → ESP=ESP+2（恢复到调用前状态）
- 堆栈变化示意图（假设初始ESP=1000H，返回地址=0020H）：
  - CALL后：ESP=0FFEH，栈单元0FFEH~0FFFH=20H（IP值）
  - PUSH BP后：ESP=0FFCH，栈单元0FFCH~0FFDH=BP原值
  - POP BP后：ESP=0FFEH，BP恢复原值
  - RET后：ESP=1000H，IP=0020H（回到主程序）
4. 寄存器保护方式和目的（必考）
- 保护方式：子程序入口处PUSH需要保护的寄存器，出口处POP恢复（顺序相反）
- 目的：避免子程序修改的寄存器值破坏主程序中该寄存器的原有数据（主程序可能后续使用该寄存器）
- 示例：
```asm
SUB_EXAMPLE PROC NEAR
    PUSH AX ; 保护AX
    PUSH BX ; 保护BX
    PUSH CX ; 保护CX
    ; 子程序核心代码（修改AX、BX、CX）
    MOV AX, 10
    MOV BX, 20
    ADD CX, AX
    ; 恢复寄存器
    POP CX ; 恢复CX（与PUSH顺序相反）
    POP BX ; 恢复BX
    POP AX ; 恢复AX
    RET
SUB_EXAMPLE ENDP
```

### （四）宏汇编
1. 宏定义及使用（必考格式）
- 宏定义格式：
```asm
宏名 MACRO [形参1, 形参2, ...] ; 宏定义开始，可带参数
    ; 宏体（汇编指令序列）
ENDM ; 宏定义结束
```
- 宏调用格式：宏名 [实参1, 实参2, ...]（实参与形参一一对应）
- 示例：定义宏ADD_NUM，实现两个数相加并存储结果
```asm
; 宏定义（形参：操作数1，操作数2，结果存储单元）
ADD_NUM MACRO OPR1, OPR2, RESULT
    MOV AX, OPR1
    ADD AX, OPR2
    MOV RESULT, AX
ENDM

; 宏调用（实参：1234H，5678H，SUM）
DATA SEGMENT
    SUM DW ?
DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    ADD_NUM 1234H, 5678H, SUM ; 宏调用，等价于插入宏体代码
    MOV AH, 4CH
    INT 21H
CODE ENDS
END START
```
2. 宏与子程序的区别（必考，分点对比）
| 特性         | 宏                             | 子程序（过程）                  |
|--------------|--------------------------------|---------------------------------|
| 代码生成     | 宏调用处插入宏体完整代码（代码膨胀） | 子程序代码仅存储一次，调用时跳转（代码精简） |
| 执行速度     | 快（无跳转和堆栈操作）         | 慢（需CALL/RET和堆栈操作）      |
| 参数传递     | 实参直接替换形参（支持常量、寄存器、内存） | 通过寄存器、堆栈、内存传递（需显式处理） |
| 适用场景     | 短小指令序列，调用次数少       | 复杂功能，调用次数多            |
| 寄存器影响   | 直接使用寄存器，需手动保护     | 可在子程序内保护寄存器，不影响主程序 |

## 七、考试题型与分值
### （一）分值分布（两种方案，均需掌握）
方案一：
1. 单项选择题：20分（每题2分，共10题）
2. 填空题：15分（每空1分，共15空）
3. 判断题：10分（每题1分，共10题）
4. 问答题：20分（每题5分，共4题）
5. 应用题：35分（共4题）

方案二：
1. 单项选择题：10分（每题1分，共10题）
2. 填空题：15分（每空1分，共15空）
3. 判断题：10分（每题1分，共10题）
4. 问答题：25分（每题5分，共5题）
5. 应用题：40分（共4题）

### （二）各题型考查重点
1. 单项选择题：寄存器用途、寻址方式识别、指令格式与功能、伪指令用法、标志位影响、宏与子程序区别等基础知识点
2. 填空题：物理地址计算、指令功能填空、堆栈变化、变量定义格式、循环次数计算、参数传递方式等
3. 判断题：指令合法性（如MOV DS, 1234H是否正确）、寻址方式判断、标志位影响、伪指令作用、程序功能判断等
4. 问答题：寄存器分类及用途、寻址方式分类及区别、指令与伪指令区别、宏与子程序区别、堆栈操作过程、标志位含义及影响因素等
5. 应用题：综合应用知识点，必考4类题型（见下文）

## 八、应用题题型详解
### （一）题型1：变量定义，画图（必考）
- 考试要求：根据给定的变量定义，绘制内存分布图（标注偏移地址、存储内容）
- 核心要点：
  - 明确变量类型（DB/DW/DD）对应的字节数
  - 小端存储规则（字/双字的字节顺序）
  - 字符存储为ASCII码
  - DUP重复定义的展开
- 示例：
  给定变量定义：
  ```asm
  DATA SEGMENT
      VAR1 DB 'AB', 3 DUP(5)
      VAR2 DW 1234H, ?
      VAR3 DD 0ABCDH
  DATA ENDS
  ```
  绘制内存分布图（偏移地址从0开始）：
  | 偏移地址 | 存储内容（十六进制） | 对应变量/说明               |
  |----------|----------------------|----------------------------|
  | 00H      | 41H                  | VAR1第1字节（'A'的ASCII码） |
  | 01H      | 42H                  | VAR1第2字节（'B'的ASCII码） |
  | 02H      | 05H                  | VAR1第3字节（DUP第1个5）   |
  | 03H      | 05H                  | VAR1第4字节（DUP第2个5）   |
  | 04H      | 05H                  | VAR1第5字节（DUP第3个5）   |
  | 05H      | 34H                  | VAR2第1字节（1234H低字节） |
  | 06H      | 12H                  | VAR2第2字节（1234H高字节） |
  | 07H      | ?                    | VAR2第3字节（未初始化）    |
  | 08H      | ?                    | VAR2第4字节（未初始化）    |
  | 09H      | CDH                  | VAR3第1字节（0ABCDH低字节）|
  | 0AH      | ABH                  | VAR3第2字节                |
  | 0BH      | 00H                  | VAR3第3字节                |
  | 0CH      | 00H                  | VAR3第4字节（0ABCDH高字节）|

### （二）题型2：完型填空 或 阅读程序写程序功能（必考）
1. 完型填空：给定程序框架，填写缺失的指令（如循环初始化、条件判断、指令操作数等）
- 示例：程序功能为计算1~N的累加和（N=5），填写缺失指令
  ```asm
  DATA SEGMENT
      N DB 5
      SUM DB 0
  DATA ENDS
  CODE SEGMENT
      ASSUME CS:CODE, DS:DATA
  START:
      MOV AX, DATA
      MOV DS, AX
      MOV AL, 0 ; 累加器清0
      MOV CL, N ; 循环次数=5
      MOV BL, 1 ; 初始值=1
  AGAIN:
      ADD AL, BL ; 累加
      (1) ______ ; BL自增1（答案：INC BL）
      (2) ______ ; 循环控制（答案：LOOP AGAIN）
      MOV SUM, AL
      MOV AH, 4CH
      INT 21H
  CODE ENDS
  END START
  ```
2. 阅读程序写功能：分析给定程序的指令序列，用自然语言描述其功能（如累加、查找、比较、数据转换等）
- 示例：阅读以下程序，说明功能
  ```asm
  DATA SEGMENT
      BUF DB 1,3,5,7,9
      COUNT EQU $-BUF
      RESULT DB 0
  DATA ENDS
  CODE SEGMENT
      ASSUME CS:CODE, DS:DATA
  START:
      MOV AX, DATA
      MOV DS, AX
      MOV SI, OFFSET BUF
      MOV CX, COUNT
      MOV AL, 0
  LOP:
      CMP [SI], 5
      JNE NEXT
      INC AL
  NEXT:
      INC SI
      LOOP LOP
      MOV RESULT, AL
      MOV AH, 4CH
      INT 21H
  CODE ENDS
  END START
  ```
  答案：统计字节数组BUF（元素1,3,5,7,9）中值等于5的元素个数，结果存入RESULT（最终RESULT=1）

### （三）题型3：编程题，写程序段或子程序（必考）
- 考试要求：根据题目要求，编写核心程序段或完整子程序（无需调用输入输出函数，结果存入指定位置）
- 核心要点：
  - 明确功能需求（如累加、乘法、查找、位操作等）
  - 选择合适的指令和寻址方式
  - 子程序需包含参数传递、寄存器保护、返回指令
- 示例1：编写程序段，将AX寄存器中的16位二进制数转换为十进制数的ASCII码，存入BUF缓冲区（低位在前）
  关键步骤：AX÷10取余（得到个位ASCII）→ 商再÷10取余（十位）→ 直到商为0 → 结果存入BUF
  ```asm
  ; AX=待转换数，BUF为字节缓冲区
  MOV BX, 10 ; 除数=10
  MOV SI, OFFSET BUF ; SI指向BUF首地址
  CONVERT:
      XOR DX, DX ; DX清0（除法高位）
      DIV BX ; AX=AX÷10的商，DX=余数（0~9）
      ADD DL, 30H ; 余数转换为ASCII码（0→30H='0'）
      MOV [SI], DL ; 存入BUF
      INC SI ; SI自增
      CMP AX, 0 ; 商是否为0
      JNE CONVERT ; 不为0继续转换
  ; 最终BUF中存储十进制数的ASCII码（低位在前）
  ```
- 示例2：编写子程序SUB_FACT，计算N!（N≤5，N存入BL，结果存入AX）
  ```asm
  SUB_FACT PROC NEAR
      PUSH CX ; 保护CX
      MOV AX, 1 ; 阶乘初始值=1
      MOV CX, BX ; 循环次数=N
      CMP CX, 0 ; N=0时阶乘=1
      JE EXIT
  FACT_LOOP:
      MUL CX ; AX=AX×CX（阶乘计算）
      LOOP FACT_LOOP
  EXIT:
      POP CX ; 恢复CX
      RET ; 返回，AX=N!
  SUB_FACT ENDP
  ```

### （四）题型4：编程题，写完整程序（必考）
- 考试要求：根据题目要求，编写完整汇编程序（包含数据段、代码段定义，程序入口，功能实现），结果存入指定变量或寄存器
- 核心要点：
  - 程序框架完整（DATA/CODE段定义，ASSUME，START入口，程序退出INT 21H）
  - 变量定义正确（DB/DW等）
  - 功能实现符合要求，无语法错误
- 示例：编写完整程序，计算字节数组ARR（元素为10,20,30,40,50）的平均值，结果存入AVE（字节型，四舍五入）
  ```asm
  DATA SEGMENT
      ARR DB 10,20,30,40,50 ; 数组
      COUNT EQU $-ARR ; 数组长度=5
      SUM DB 0 ; 累加和
      AVE DB 0 ; 平均值
  DATA ENDS

  CODE SEGMENT
      ASSUME CS:CODE, DS:DATA
  START:
      MOV AX, DATA
      MOV DS, AX ; 初始化DS

      ; 步骤1：计算数组累加和
      MOV SI, OFFSET ARR ; SI指向数组首地址
      MOV CX, COUNT ; 循环次数=5
      MOV AL, 0 ; 累加器清0
  SUM_LOOP:
      ADD AL, [SI] ; 累加数组元素
      INC SI ; SI自增
      LOOP SUM_LOOP
      MOV SUM, AL ; 存储累加和（SUM=150）

      ; 步骤2：计算平均值（150÷5=30，四舍五入）
      MOV AH, 0 ; AX=SUM=150
      MOV BL, COUNT ; BL=5
      DIV BL ; AL=商=30，AH=余数=0
      MOV AVE, AL ; 存储平均值（AVE=30）

      ; 程序退出
      MOV AH, 4CH
      INT 21H
  CODE ENDS
  END START
  ```

## 九、复习与考试提示
### （一）复习提示
1. 核心原则：不是单纯记忆知识点，而是会做题（避免眼高手低），知识点需结合例题和习题理解
2. 习题要求：课后习题中的填空题、判断题、选择题必须全部完成，应用题至少完成80%
3. 考试范围：仅覆盖到第五章（指令系统及之前内容，含程序设计基础），无需复习后续章节
4. 重点突破：
  - 寄存器特殊搭配（CS:EIP、SS:ESP等）
  - 物理地址计算（实地址模式）
  - 寻址方式识别与应用
  - 指令功能与标志位影响
  - 变量定义与内存分布图
  - 分支、循环、子程序编程

### （二）考试提示
1. 答题规范：严格按题目要求答题，如程序设计题明确要求“分子程序设计”则必须写子程序，要求“完整程序”则需包含完整框架
2. 编程原则：
  - 不炫技：功能正确即可，无需使用复杂指令或算法，避免额外增加难度
  - 不遗漏：确保核心功能实现，无逻辑漏洞
  - 不冗余：无需添加题目未要求的功能（如输入输出函数调用）
3. 避免低级错误（扣分重灾区）：
  - 操作码写错（如MOV写成MOv、ADD写成ADB）
  - 指令格式错误（如MOV [1000H], [2000H]、PUSH AL）
  - 关键字写错（如SEGMENT写成SEGMEN、END写成EN）
  - 寄存器位数不匹配（如MOV AL, 1234H）
  - 堆栈失衡（PUSH和POP次数不相等）
4. 答题策略：
  - 先做客观题（选择、填空、判断），再做主观题（问答、应用）
  - 应用题先易后难，不会的题目先标记，避免空题（即使不会完整编写，也可写部分核心指令）
  - 编程题结果必须存入题目指定的变量或寄存器，无明确要求时存入AX或自定义变量