; 1. 数据段定义（存放变量、常量，必须在代码段前）
DATA SEGMENT          ; DATA：数据段名（自定义，英文大写，见名知义）；SEGMENT：段开始伪指令（“SEGMENT”=段的起始）
    VAR DB 10H        ; VAR：变量名（自定义）；DB：字节定义伪指令（“DB”=Define Byte，定义1字节）；10H：变量初始值（16进制，可省略，省略则初始值不确定）
    SUM DW ?          ; SUM：变量名（用于存储结果）；DW：字定义伪指令（“DW”=Define Word，定义2字节）；?：表示初始值为空（汇编时分配内存，但不赋值）
    STR DB 'HELLO$'   ; STR：字符串变量名；DB：字节定义（每个字符占1字节）；'HELLO'：字符串（每个字符对应ASCII码，H=48H、E=45H等）；$：字符串结束符（DOS中断识别结束的标志，必须加）
DATA ENDS             ; DATA：与段开始的段名一致（不能错）；ENDS：段结束伪指令（“ENDS”=段的终止，与SEGMENT成对）

; 2. 代码段定义（存放执行指令，必须关联段寄存器）
CODE SEGMENT          ; CODE：代码段名（自定义）；SEGMENT：段开始伪指令
    ASSUME CS:CODE, DS:DATA  ; ASSUME：段关联伪指令（“ASSUME”=假设，告诉汇编器段寄存器与段的对应关系）；CS:CODE：CS寄存器对应代码段CODE（指令存放的段）；DS:DATA：DS寄存器对应数据段DATA（变量存放的段）
START:                ; START：程序入口标号（“标号”=指令的地址别名，汇编器会记录其偏移地址）；必须有（END指令需指向此标号）
    ; 初始化数据段（必考！DS不能直接赋值，需用AX中转）
    MOV AX, DATA      ; MOV：数据传送指令；AX：通用寄存器（中转用）；DATA：数据段名（汇编时会替换为数据段的段地址）；作用：将数据段地址送入AX
    MOV DS, AX        ; MOV：数据传送指令；DS：数据段寄存器；AX：存放数据段地址；作用：将AX中的段地址送入DS，完成数据段初始化（DS指向数据段，才能访问变量）
    
    ; 程序核心代码（根据题目需求编写，如赋值、运算等）
    MOV AL, VAR       ; MOV：数据传送；AL：8位寄存器；VAR：变量名（汇编时替换为偏移地址）；作用：将VAR变量的值（10H）送入AL
    ADD AL, 20H       ; ADD：加法指令；AL：目的操作数（累加和）；20H：立即数；作用：AL=10H+20H=30H
    MOV SUM, AX       ; MOV：数据传送；SUM：字变量；AX：存放结果（AL=30H，AH=00H，AX=0030H）；作用：将结果送入SUM变量
    
    ; 程序退出（实地址模式下DOS系统的标准退出方式，必考！）
    MOV AH, 4CH       ; MOV：数据传送；AH：8位高字节寄存器；4CH：DOS中断功能号（“4CH”=程序退出功能，固定值）
    INT 21H           ; INT：中断指令（“INT”=Interrupt，触发中断）；21H：DOS中断向量号（“21H”=DOS系统中断，CPU调用DOS系统功能）；作用：触发DOS中断，执行退出功能，程序正常结束
CODE ENDS             ; CODE：与段开始的段名一致；ENDS：段结束伪指令
END START             ; END：程序结束伪指令（“END”=汇编结束，告诉汇编器停止汇编）；START：程序入口标号（汇编器从START开始生成指令，确定程序执行起点）

汇编语言复习PPT（逐字逐词极致细致讲解）
 
按PPT页面顺序，对每个知识点、每个术语、每个指令字段进行「原子级拆解」，覆盖定义、底层逻辑、字面含义、实例验证，确保无任何模糊概念，适配零基础或极致备考需求。
 
第1页：汇编语言基础（寄存器 + 存储器组织）
 
一、寄存器（逐词拆解核心术语）
 
1. 寄存器的本质定义
 
- 寄存器：CPU（中央处理器）内部集成的「高速存储单元」（“寄存”=临时存放，“器”=硬件单元），速度远快于内存（毫秒级vs纳秒级），用于临时存放程序执行时的「数据、地址、状态」，避免频繁访问内存拖慢速度。
- 核心特点：数量有限（x86架构32位CPU共8个通用寄存器、6个段寄存器等）、访问速度最快、按功能分类（通用/专用/段）。
 
2. 通用寄存器（EAX~EDX，逐寄存器逐字段拆解）
 
- 通用：功能不固定（“通用”=可灵活用于数据运算、地址存放等，无专属固定功能），共4个32位寄存器，兼容16位（后缀X）和8位（高字节H/低字节L）拆分使用（“兼容”=支持不同位数操作，适配老程序）。
- 逐寄存器拆解（含英文全称、字面含义、用途细节）：
32位寄存器 英文全称 字面含义 16位别名 8位高字节 8位低字节 核心用途（逐点解释） 
EAX Extended Accumulator Extended=扩展（32位比16位AX扩展），Accumulator=累加器 AX AH AL 1. 算术运算：所有加法（ADD）、减法（SUB）等运算默认首选（“累加器”=累计运算结果）； 2. I/O操作：DOS中断（如INT 21H）功能调用时，AH存功能号（如AH=4CH是退出功能）； 3. 子程序返回值：默认用EAX存放子程序计算结果（主程序直接从EAX取） 
EBX Extended Base Base=基址（基础地址） BX BH BL 1. 基址寻址：存储器寻址中作为基础地址（如[BX+10H]，BX是基址）； 2. 暂存数据：无固定功能，仅临时存放数据（如运算过程中保存中间结果） 
ECX Extended Counter Counter=计数器 CX CH CL 1. 循环指令：LOOP指令默认计数器（CX值=循环次数，每次LOOP自动CX-1）； 2. 移位指令：移位次数>1时，CL存移位次数（如SHL AX, CL，CL=3表示移位3次） 
EDX Extended Data Data=数据 DX DH DL 1. 扩展运算：配合EAX做32位运算（如EDX:EAX存放64位运算结果，EDX存高32位）； 2. I/O操作：端口地址>255时，DX存端口地址（如OUT DX, AL，DX=378H是打印机端口） 
- 拆分规则（逐位解释）：
- 32位（EAX）：bit0~bit31（共32个二进制位），完整存储双字数据；
- 16位（AX）：bit0~bit15（低16位），兼容16位程序，独立使用时不影响高16位；
- 8位高字节（AH）：bit8~bit15（AX的高8位），“H”=High（高）；
- 8位低字节（AL）：bit0~bit7（AX的低8位），“L”=Low（低）；
- 例：EAX=12345678H → AX=5678H、AH=56H、AL=78H（拆分后互不影响，修改AL不改变AH和高16位）。
 
3. 专用寄存器（功能固定，逐寄存器逐字段拆解）
 
- 专用：功能专属（“专用”=只能用于特定场景，不可随意挪用），考试重点3个：
寄存器 英文全称 字面含义 位数 核心功能（逐字解释） 
ESP Extended Stack Pointer Stack=堆栈，Pointer=指针（指向） 32位 1. 定位栈顶：“栈顶”=堆栈中最后压入数据的地址，ESP永远指向栈顶； 2. 自动修改：PUSH（压栈）时ESP-4（32位），POP（出栈）时ESP+4（“自动”=CPU执行指令时自动调整，无需手动修改）； 3. 搭配SS：SS是堆栈段寄存器， SS:ESP  是栈顶的完整地址（“搭配”=必须联合使用才能定位栈顶，单独ESP无意义） 
EBP Extended Base Pointer Base=基址，Pointer=指针 32位 1. 定位栈基：“栈基”=子程序调用时，栈顶的初始地址（压入返回地址后的地址）； 2. 访问堆栈参数：子程序中通过 [EBP+4]   [EBP+8]  取堆栈中的参数（“基址指针”=以栈基为基准计算参数地址，避免ESP因压栈/出栈变动导致地址错乱）； 3. 搭配SS：同ESP， SS:EBP  定位栈基地址 
EIP Extended Instruction Pointer Instruction=指令，Pointer=指针 32位 1. 指向_next指令：“next指令”=CPU即将执行的下一条指令的偏移地址； 2. 自动递增：CPU执行完当前指令后，EIP自动加上当前指令的长度（如MOV AL, 30H占2字节，EIP+2）； 3. 不可直接修改：不能用MOV指令改EIP（如MOV EIP, 1000H错误），只能通过转移指令（JMP/CALL/RET）间接修改； 4. 搭配CS： CS:EIP  是下一条指令的完整地址（CS=段地址，EIP=偏移地址） 
- 补充：FLAGS（标志寄存器）=Status Flag Register（状态标志寄存器），是16位寄存器，每一位对应一个“标志位”（如CF/ZF），存储指令执行后的状态（如加法是否有进位），后续指令（如Jxx）依赖其判断。
 
4. 段寄存器（内存分段管理，逐寄存器逐字段拆解）
 
- 段：将1MB内存（实地址模式）分成若干个64KB的“段”（“段”=内存的一部分，类似文件夹分类文件），段寄存器存储每个段的“段地址”（段的起始地址的高12位）。
- 核心作用：解决16位寄存器寻址范围不足（16位最大64KB）的问题，通过“段地址+偏移地址”实现1MB内存访问。
- 逐寄存器拆解：
段寄存器 英文全称 字面含义 位数 核心用途（逐字解释） 能否直接赋值（底层原因） 
CS Code Segment Code=代码，Segment=段 16位 指向「代码段」：代码段是存放程序指令（如MOV、ADD）的内存段， CS:EIP  定位当前要执行的指令 不能（底层原因：CS直接关联程序执行地址，若允许MOV CS, AX，可能导致程序跳转到非法地址崩溃，CPU硬件限制禁止直接修改） 
DS Data Segment Data=数据，Segment=段 16位 指向「数据段」：数据段是存放变量（如VAR DB 30H）的内存段，默认访问内存时（如[BX]）用DS作为段地址 能，但不能直接接立即数/段名（底层原因：段寄存器是16位，但CPU不支持立即数直接写入段寄存器，需通过通用寄存器中转，如MOV AX, 2000H → MOV DS, AX） 
ES Extra Segment Extra=额外的，Segment=段 16位 指向「附加段」：辅助数据段，常用于串操作指令（如MOVS）的目的串（默认ES:DI指向目的串） 同DS（需寄存器中转赋值） 
SS Stack Segment Stack=堆栈，Segment=段 16位 指向「堆栈段」：堆栈段是存放堆栈数据（PUSH压入的数据、子程序返回地址）的内存段， SS:ESP  定位栈顶 同DS（需寄存器中转赋值，赋值后需确保堆栈地址在1MB内） 
FS/GS 无固定全称 额外扩展段 16位 现代CPU扩展的附加段，用于多线程、调试等场景，考试不涉及 忽略 
 
5. 特殊搭配（逐搭配逐字解释）
 
- SS:ESP：
- SS=Stack Segment（堆栈段地址），ESP=Stack Pointer（栈顶偏移地址）；
- “搭配”=两者联合才能唯一确定栈顶的物理地址（物理地址=SS×16+ESP）；
- 例：SS=2000H，ESP=0004H → 栈顶物理地址=2000H×16+0004H=20004H。
- SS:EBP：
- SS=堆栈段地址，EBP=Base Pointer（栈基偏移地址）；
- 用于子程序中，EBP固定指向栈基（子程序调用时压入返回地址后的栈顶），后续访问堆栈参数/局部变量时，地址基于EBP计算（如[EBP+4]是第一个参数），不受ESP变动影响（ESP可能因压入局部变量改变）。
- CS:EIP：
- CS=Code Segment（代码段地址），EIP=Instruction Pointer（下一条指令偏移地址）；
- 是CPU执行指令的“核心地址”，CPU通过CS:EIP取出下一条指令，执行后自动更新EIP，实现程序顺序执行；
- 转移指令（如JMP）通过修改CS和/或EIP，改变程序执行流程（如JMP LABEL修改EIP为LABEL的偏移地址）。
 
二、存储器组织（实地址模式为唯一考点，逐术语拆解）
 
1. 存储规则及表示（逐术语、逐规则拆解）
 
- 存储器：CPU外部的「内存单元」（“存储”=长期存放程序和数据，区别于寄存器的临时存放），实地址模式下容量为1MB（00000H~FFFFFH，共1048576字节）。
- 存储规则（小端序）：
- 小端序（Little-Endian）：“小端”=低字节（数据的低位字节），“序”=存储顺序；
- 定义：多字节数据（字/双字）存入内存时，低字节存低地址，高字节存高地址（x86架构强制规则，无例外）；
- 逐字解释关键术语：
- 低字节：数据的二进制低位对应的字节（如1234H，二进制1001000110100B，低8位是00110100B=34H，即低字节）；
- 高字节：数据的二进制高位对应的字节（1234H的高8位是00010010B=12H，即高字节）；
- 低地址：内存地址数值较小的单元（如0000H比0001H低）；
- 高地址：内存地址数值较大的单元（如0001H比0000H高）；
- 实例（二进制级拆解）： VAR DW 1234H （字变量，值=1234H=0001 0010 0011 0100B），起始偏移地址=0000H：
- 低地址0000H：存储低字节34H=0011 0100B（低8位）；
- 高地址0001H：存储高字节12H=0001 0010B（高8位）；
- 验证：从内存读取时，0000H取34H，0001H取12H，组合为1234H，还原原数据。
- 存储表示（按长度分类，逐类型拆解）：
类型 长度 表示符号（伪指令） 字面含义 取值范围（二进制/十进制/十六进制） 用途（逐点解释） 
字节 8位 BYTE（DB） 字=8位（1字节=8个二进制位），Byte=字节 二进制：00000000B~11111111B 无符号十进制：0~255 有符号十进制：-128~+127 十六进制：00H~FFH 1. 存储字符：如'A'的ASCII码是41H（8位），适合用字节存储； 2. 存储短整数：范围-128~+127的整数（如年龄、分数）； 3. 节省内存：无需大空间时用字节，减少内存占用 
字 16位 WORD（DW） 字=2字节=16位，Word=字 二进制：0000000000000000B~1111111111111111B 无符号十进制：0~65535 有符号十进制：-32768~+32767 十六进制：0000H~FFFFH 1. 存储中整数：范围-32768~+32767的整数（如工资、数量）； 2. 存储偏移地址：实地址模式下偏移地址是16位，用字存储； 3. 普通运算：16位数据运算（如AX是字寄存器，配合字变量） 
双字 32位 DWORD（DD） 双字=4字节=32位，Double Word=双字 二进制：32个0~32个1 无符号十进制：0~4294967295 有符号十进制：-2147483648~+2147483647 十六进制：00000000H~FFFFFFFFH 1. 存储长整数：大范围整数（如身份证号、时间戳）； 2. 存储物理地址：保护模式下物理地址是32位，用双字存储； 3. 32位运算：EAX是双字寄存器，配合双字变量运算 
 
2. 物理地址生成方式（仅考实地址模式，逐公式、逐术语拆解）
 
- 物理地址：内存单元的「唯一绝对地址」（“物理”=硬件层面的实际地址，区别于“逻辑地址”=段地址+偏移地址），实地址模式下范围00000H~FFFFFH（1MB）。
- 核心公式（逐部分拆解）：物理地址 = 段地址 × 16 + 偏移地址
- 段地址：由段寄存器（CS/DS/ES/SS）提供的16位地址（如DS=1234H），“段地址”=内存段的起始地址的高12位（×16后左移4位，覆盖1MB地址）；
- ×16：等价于「左移4位」（二进制左移4位=数值×16），原因：段地址是16位，左移4位后变成20位（16位+4位），刚好匹配20位物理地址（1MB=2²⁰字节）；
- 偏移地址：16位地址（0000H~FFFFH），“偏移”=相对于段起始地址的偏移量（如段地址×16=20000H，偏移地址=1234H，则实际地址=20000H+1234H=21234H）；
- 实例（二进制级验证）：DS=1234H（段地址），偏移地址=5678H
1. 段地址×16：1234H=0001 0010 0011 0100B → 左移4位=0001 0010 0011 0100 0000B=12340H；
2. 加偏移地址：12340H + 5678H=179B8H（物理地址）；
3. 结果：CPU通过179B8H访问内存单元，取出数据。
- 关键限制（底层原因）：
- 段地址×16后必须≤FFFF0H（因为偏移地址最大FFFFH，物理地址最大FFFF0H+FFFFH=FFFFFH）；
- 偏移地址必须是16位（0000H~FFFFH），超出则寻址错误（如偏移地址=10000H，超出16位，非法）。
 
3. 存储模型（3种，逐模型逐术语拆解）
 
- 存储模型：「内存的管理方式」（“模型”=组织内存的规则），考试要求掌握定义及区别：
存储模型 核心定义（逐字解释） 适用场景（底层原因） 考试要求 
平展模型 平展=内存是连续的“平面”（无分段），逻辑地址=物理地址（“平展”=无层级，直接访问） 32/64位保护模式（如Windows）：内存容量大（4GB以上），分段会降低效率，平展模型直接用32/64位地址访问 了解定义（考试不考计算，仅判断对错） 
段式模型 段式=将内存分成多个“独立段”（代码段、数据段等），每个段有独立的段地址，通过“段地址+偏移地址”访问（“段式”=按功能分段管理） 16/32位模式：内存容量较小（1MB~4GB），分段可实现多程序共享内存（不同程序用不同段地址，避免冲突） 掌握核心逻辑（结合实地址模式理解分段的必要性） 
实地址模型 实地址=实际物理地址，是段式模型的“简化版”（16位），段地址×16+偏移地址生成1MB物理地址，段长度最大64KB（偏移地址0000H~FFFFH） 16位实地址模式（如DOS系统）：兼容8086CPU，老程序依赖此模型，汇编考试所有题目基于此 重点掌握（所有存储器相关考题的基础） 
 
4. 工作方式（2种，逐方式逐术语拆解）
 
- 工作方式：CPU访问内存、执行指令的「模式」（“方式”=CPU的工作规则），仅考实地址模式：
工作方式 核心特点（逐点逐字解释） 考试关联 
实地址模式 1. 16位操作：寄存器、指令均按16位设计（兼容8086CPU的16位架构）； 2. 内存1MB：物理地址范围00000H~FFFFFH（1MB=1024KB=1048576字节）； 3. 单任务：同一时间只能运行一个程序（“单任务”=CPU资源全给一个程序，无多程序切换）； 4. 无内存保护：程序可访问任意内存地址（无权限限制，“无保护”=可能修改其他程序数据导致崩溃）； 5. 兼容8086指令集：仅支持8086CPU的基础指令（如MOV、ADD），不支持复杂指令（如SIMD指令） 所有考题均基于此模式（物理地址计算、指令执行、程序编写） 
保护模式 1. 32/64位操作：支持32/64位寄存器和指令（如EAX、EDX是32位）； 2. 内存4GB以上：32位保护模式支持4GB内存（2³²字节），64位支持更大容量； 3. 多任务：同一时间可运行多个程序（CPU分时切换，“多任务”=提高资源利用率）； 4. 内存保护：程序只能访问自身权限内的内存（“保护”=避免越权访问，提高稳定性）； 5. 段描述符表：段地址需通过“段描述符表”解析（段描述符存储段的基地址、长度、权限） 了解即可（考试不涉及，仅区分实地址模式） 
 
第2页：编程结构（程序格式 + 开发过程）
 
一、汇编语言程序格式（编程题必考，逐行逐字段拆解）
 
1. 程序框架（逐行解释，含每个关键字、指令的含义）
 
- 核心原则：完整程序从数据段开始写（“数据段”=存放变量，“代码段”=使用变量，先定义后使用，顺序不能颠倒）。
- 标准框架（逐行拆解，含底层逻辑）：
 
asm
  

; 1. 数据段定义（存放变量、常量，必须在代码段前）
DATA SEGMENT          ; DATA：数据段名（自定义，英文大写，见名知义）；SEGMENT：段开始伪指令（“SEGMENT”=段的起始）
    VAR DB 10H        ; VAR：变量名（自定义）；DB：字节定义伪指令（“DB”=Define Byte，定义1字节）；10H：变量初始值（16进制，可省略，省略则初始值不确定）
    SUM DW ?          ; SUM：变量名（用于存储结果）；DW：字定义伪指令（“DW”=Define Word，定义2字节）；?：表示初始值为空（汇编时分配内存，但不赋值）
    STR DB 'HELLO$'   ; STR：字符串变量名；DB：字节定义（每个字符占1字节）；'HELLO'：字符串（每个字符对应ASCII码，H=48H、E=45H等）；$：字符串结束符（DOS中断识别结束的标志，必须加）
DATA ENDS             ; DATA：与段开始的段名一致（不能错）；ENDS：段结束伪指令（“ENDS”=段的终止，与SEGMENT成对）

; 2. 代码段定义（存放执行指令，必须关联段寄存器）
CODE SEGMENT          ; CODE：代码段名（自定义）；SEGMENT：段开始伪指令
    ASSUME CS:CODE, DS:DATA  ; ASSUME：段关联伪指令（“ASSUME”=假设，告诉汇编器段寄存器与段的对应关系）；CS:CODE：CS寄存器对应代码段CODE（指令存放的段）；DS:DATA：DS寄存器对应数据段DATA（变量存放的段）
START:                ; START：程序入口标号（“标号”=指令的地址别名，汇编器会记录其偏移地址）；必须有（END指令需指向此标号）
    ; 初始化数据段（必考！DS不能直接赋值，需用AX中转）
    MOV AX, DATA      ; MOV：数据传送指令；AX：通用寄存器（中转用）；DATA：数据段名（汇编时会替换为数据段的段地址）；作用：将数据段地址送入AX
    MOV DS, AX        ; MOV：数据传送指令；DS：数据段寄存器；AX：存放数据段地址；作用：将AX中的段地址送入DS，完成数据段初始化（DS指向数据段，才能访问变量）
    
    ; 程序核心代码（根据题目需求编写，如赋值、运算等）
    MOV AL, VAR       ; MOV：数据传送；AL：8位寄存器；VAR：变量名（汇编时替换为偏移地址）；作用：将VAR变量的值（10H）送入AL
    ADD AL, 20H       ; ADD：加法指令；AL：目的操作数（累加和）；20H：立即数；作用：AL=10H+20H=30H
    MOV SUM, AX       ; MOV：数据传送；SUM：字变量；AX：存放结果（AL=30H，AH=00H，AX=0030H）；作用：将结果送入SUM变量
    
    ; 程序退出（实地址模式下DOS系统的标准退出方式，必考！）
    MOV AH, 4CH       ; MOV：数据传送；AH：8位高字节寄存器；4CH：DOS中断功能号（“4CH”=程序退出功能，固定值）
    INT 21H           ; INT：中断指令（“INT”=Interrupt，触发中断）；21H：DOS中断向量号（“21H”=DOS系统中断，CPU调用DOS系统功能）；作用：触发DOS中断，执行退出功能，程序正常结束
CODE ENDS             ; CODE：与段开始的段名一致；ENDS：段结束伪指令
END START             ; END：程序结束伪指令（“END”=汇编结束，告诉汇编器停止汇编）；START：程序入口标号（汇编器从START开始生成指令，确定程序执行起点）
 
 
- 考试必记易错点（逐点解释原因）：
1. 漏写ASSUME伪指令：汇编器不知道段寄存器对应哪个段，访问变量时会报错（如找不到VAR的段地址）；
2. 直接写 MOV DS, DATA ：错误原因：段寄存器不能直接接收段名（DATA是段名，汇编时是符号，不是数值），必须通过AX中转；
3. 漏写程序入口START：END伪指令无指向，汇编器不知道程序从哪里开始执行，生成的.exe文件无法运行；
4. 漏写程序退出指令（MOV AH,4CH+INT21H）：程序执行完核心代码后，会继续执行后续内存中的垃圾指令，导致程序崩溃（DOS系统需要显式退出）。
 
2. 完整程序与程序段的区别（逐词解释）
 
- 完整程序：包含「数据段+代码段+段定义+初始化+退出」的完整结构（“完整”=可直接汇编、链接生成.exe文件运行）；
- 适用场景：应用题中明确要求“编写完整程序”；
- 程序段：仅包含「核心逻辑指令」（如MOV、ADD），省略段定义、ASSUME、初始化、退出指令（“程序段”=完整程序的一部分，不可单独运行）；
- 适用场景：应用题中要求“编写程序段实现XX功能”；
- 例：实现AL=VAR+20H的程序段： MOV AL, VAR；ADD AL, 20H （无需段定义和初始化）。
 
二、开发过程（逐步骤、逐软件、逐文件拆解）
 
1. 开发步骤（4步，按顺序逐步拆解，含每个步骤的目的）
 
- 步骤1：编写源程序（第1步）
- 操作：用文本编辑器（如记事本）编写.asm格式的源文件，输入汇编语言代码（如上述标准框架）；
- 目的：将程序逻辑用汇编语言（人类可阅读的指令）记录下来；
- 关键：文件名自定义（如TEST.asm），后缀必须是.asm（“asm”=Assembly Language，汇编语言的缩写），保存为纯文本格式（不能是Word文档）。
- 步骤2：汇编（第2步）
- 操作：用汇编器（如MASM）对.asm源文件执行汇编命令（如 MASM TEST.ASM ）；
- 目的：将汇编语言代码（人类可读）转换为机器码（CPU可执行的二进制代码）；
- 关键：检查语法错误（如指令写错、伪指令缺失），无错误则生成.obj目标文件；若有错误（如MOV写成MOVV），汇编器会提示错误行号和原因，需修改源程序后重新汇编。
- 步骤3：链接（第3步）
- 操作：用链接器（如Link）对.obj目标文件执行链接命令（如 LINK TEST.OBJ ）；
- 目的：将.obj文件中的机器码与系统库（如DOS中断服务程序）链接，解决外部符号引用（如多个.obj文件共享变量），生成可执行文件；
- 关键：无链接错误则生成.exe文件；若有错误（如子程序未定义），链接器提示后需修改源程序重新汇编、链接。
- 步骤4：运行与调试（第4步）
- 操作：双击.exe文件运行，或用调试器（如Debug）执行调试命令（如 DEBUG TEST.EXE ）；
- 目的：验证程序功能是否正确，排查逻辑错误（如结果错误、程序崩溃）；
- 关键：调试时可单步执行（T命令）、查看寄存器（R命令）、查看内存（D命令）、查看堆栈（S命令），定位错误后修改源程序，重复步骤2~4直到程序正常运行。
 
2. 使用的软件（逐软件拆解，含功能、操作命令）
 
开发步骤 软件名称 英文全称 核心功能（逐点解释） 常用操作命令 
编写源程序 记事本 Notepad 1. 纯文本编辑（仅支持文字输入，无格式）； 2. 保存为.asm文件（后缀必须手动输入）； 3. 免费内置（Windows系统自带，无需额外安装） 新建→输入代码→文件→保存→文件名输入“TEST.asm”→保存类型选“所有文件” 
汇编 MASM Microsoft Macro Assembler 1. 语法检查：检查源程序中的指令、伪指令是否符合语法规则； 2. 生成机器码：将合法的汇编指令转换为CPU可执行的二进制机器码； 3. 生成.obj文件：将机器码存入.obj目标文件（二进制格式） 命令行输入： MASM TEST.ASM （回车后按3次回车，生成TEST.OBJ） 
链接 Link Microsoft Linker 1. 链接系统库：将.obj文件与DOS系统库（如INT 21H的实现代码）合并； 2. 解决外部引用：若源程序调用了其他.obj文件的子程序，链接器会找到对应的代码并合并； 3. 生成.exe文件：将链接后的机器码存入.exe可执行文件 命令行输入： LINK TEST.OBJ （回车后按3次回车，生成TEST.EXE） 
调试 Debug DOS Debugger 1. 单步执行：T命令（Trace），逐条执行指令，观察每步的寄存器/内存变化； 2. 查看寄存器：R命令（Register），显示所有寄存器的值，可修改寄存器（如 R AX ）； 3. 查看内存：D命令（Dump），显示指定地址的内存数据（如 D DS:0 查看数据段起始内存）； 4. 查看堆栈：S命令（Stack），显示堆栈段的数据（如 S SS:ESP 查看栈顶）； 5. 运行程序：G命令（Go），直接运行程序到断点或结束 命令行输入： DEBUG TEST.EXE （进入调试模式后输入相关命令） 
 
3. 生成的文件（3类核心文件，逐文件拆解，含格式、用途、关联）
 
文件后缀 英文全称 生成步骤 文件格式 核心用途（逐点解释） 与其他文件的关联 
.asm Assembly Source File 编写源程序 纯文本格式（ASCII码） 1. 存储汇编语言代码（人类可阅读、可修改）； 2. 作为汇编器的输入文件（汇编的依据）； 3. 便于程序维护（修改时直接编辑.asm文件） 是.obj文件的“源文件”，.asm→汇编→.obj 
.obj Object File 汇编 二进制格式（机器码+符号表） 1. 存储汇编后的机器码（CPU可执行，但不完整）； 2. 包含符号表（记录变量、标号的地址）； 3. 作为链接器的输入文件（链接的依据） 是.asm文件的“中间产物”，.obj→链接→.exe 
.exe Executable File 链接 二进制格式（完整机器码+系统信息） 1. 可直接运行（DOS/Windows系统识别并执行）； 2. 包含完整的机器码（程序逻辑）和系统信息（如程序入口地址）； 3. 是开发的最终产物（用户使用的文件） 是.obj文件的“最终产物”，.exe可直接运行，无需依赖.asm和.obj文件 
 
- 补充文件：.lst（List File，列表文件），汇编时可选生成，包含源程序、机器码、地址的对应关系（如每一行汇编指令对应的机器码和偏移地址），考试不考，仅用于调试。
 
第3页：寻址方式（逐类、逐术语、逐指令拆解）
 
寻址方式是「找到指令中操作数地址的方法」（“寻址”=寻找地址，“方式”=方法），分两类：与数据有关（找数据地址）、与转移地址有关（找指令地址）。
 
一、与数据有关的寻址（3大类，逐类逐术语逐指令拆解）
 
1. 立即寻址（Immediate Addressing）
 
- 定义（逐字解释）：操作数是「立即数」（“立即”=指令中直接给出，无需寻找，取数立即），直接嵌入指令中，CPU执行时从指令中直接获取操作数，无需访问寄存器/内存。
- 格式（逐字段解释）： MOV 目的操作数, 立即数 
- 目的操作数：接收数据的对象（必须是寄存器或内存，不能是立即数）；
- 立即数：固定数值（如10H、3456H、'A'），可以是二进制（后缀B）、十进制（默认）、十六进制（后缀H）、字符（单引号括起，对应ASCII码）。
- 实例（逐指令拆解，含二进制）：
-  MOV AL, 30H ：
- 目的操作数：AL（8位寄存器）；
- 立即数：30H=00110000B（ASCII码对应'0'）；
- 寻址方式：立即寻址（30H在指令中，直接取数）；
- 执行结果：AL=30H；
-  MOV CX, 1234H ：
- 立即数：1234H=0001001000110100B；
- 执行结果：CX=1234H；
-  MOV BL, 'A' ：
- 立即数：'A'的ASCII码=41H=01000001B；
- 执行结果：BL=41H；
- 核心特点（底层原因）：
- 取数最快：数据在指令中，CPU取指令时同时取操作数，无需额外访问寄存器/内存（寄存器访问需1个时钟周期，内存需多个，立即数无需额外周期）；
- 不能作为目的操作数：立即数是固定数值，不是存储单元（如 MOV 30H, AL 错误，30H是数值，不能接收数据）。
 
2. 寄存器寻址（Register Addressing）
 
- 定义（逐字解释）：操作数存放在「通用寄存器」或「段寄存器」中（“寄存器”=存储单元，“寻址”=寻找寄存器的地址），指令中直接写寄存器名，CPU执行时从寄存器中获取操作数。
- 格式（逐字段解释）： MOV 目的寄存器, 源寄存器  或  MOV 寄存器, 立即数 （结合立即寻址）
- 目的寄存器：接收数据的寄存器（如AX、BX）；
- 源寄存器：提供数据的寄存器（如CX、DX）；
- 寄存器类型：通用寄存器（EAX~EDX、BX等）、段寄存器（DS、ES等），需类型匹配。
- 实例（逐指令拆解）：
-  MOV AX, BX ：
- 目的寄存器：AX（16位）；
- 源寄存器：BX（16位）；
- 寻址方式：寄存器寻址（操作数在BX中）；
- 执行结果：AX=BX的值（BX的值复制到AX，BX不变）；
-  ADD ECX, EDX ：
- 目的寄存器：ECX（32位）；
- 源寄存器：EDX（32位）；
- 寻址方式：寄存器寻址；
- 执行结果：ECX=ECX+EDX的值；
-  MOV DS, AX ：
- 目的寄存器：DS（段寄存器）；
- 源寄存器：AX（通用寄存器）；
- 寻址方式：寄存器寻址；
- 执行结果：DS=AX的值（初始化数据段）；
- 核心特点（底层原因）：
- 取数快：寄存器在CPU内部，访问速度仅次于立即数（比内存快10~100倍）；
- 操作数可作目的/源：寄存器是存储单元，可接收数据（目的）或提供数据（源）；
- 必须类型匹配：寄存器位数需与数据位数一致（如 MOV AL, AX 错误，AL是8位，AX是16位，类型不匹配，CPU无法执行）。
 
3. 存储器寻址（Memory Addressing，重点+难点）
 
- 定义（逐字解释）：操作数存放在「内存单元」中（“存储器”=内存，“寻址”=寻找内存单元的地址），需通过“段地址+偏移地址”定位内存单元，CPU执行时从内存中获取操作数。
- 核心前提：默认段地址在DS寄存器（如[BX]的段地址=DS），若用BP寄存器作基址（如[BP]），段地址默认在SS寄存器（堆栈段）；若需用其他段寄存器，需加「段超越前缀」（如 ES:[BX] ，段地址=ES）。
- 5种类型（逐类拆解格式、偏移地址公式、实例、底层逻辑）：
寻址类型 格式（逐字段解释） 偏移地址计算公式（逐符号解释） 实例（逐指令拆解） 考试注意事项 
直接寻址  MOV 寄存器, [偏移地址]  或  MOV 寄存器, 变量名  偏移地址 = 指令中的直接地址（或变量名对应的偏移地址） “直接地址”=指令中明确给出的16位地址（如1000H）；“变量名对应的偏移地址”=汇编时给变量分配的偏移地址（如VAR的偏移地址=0000H） 例1： MOV AL, [1000H]  - 段地址=DS（默认）； - 偏移地址=1000H； - 物理地址=DS×16+1000H； - 执行结果：AL=物理地址对应内存单元的字节数据； 例2： MOV AX, VAR （VAR DW 1234H，偏移地址=0000H） - 偏移地址=VAR的偏移地址=0000H； - 物理地址=DS×16+0000H； - 执行结果：AX=1234H（内存0000H=34H，0001H=12H） 变量名本质是“直接地址的别名”（汇编时变量名替换为偏移地址），如 MOV AX, VAR 等价于 MOV AX, [0000H] （VAR的偏移地址=0000H）； 直接地址必须是16位（0000H~FFFFH），超出则非法 
寄存器间接寻址  MOV 寄存器, [基址/变址寄存器]  偏移地址 = 寄存器的值 “基址/变址寄存器”=仅允许BX、SI、DI、BP（CPU硬件限制，其他寄存器如AX不能作间址寄存器） 例1： MOV AL, [BX] （BX=2000H，DS=1000H） - 偏移地址=BX的值=2000H； - 物理地址=1000H×16+2000H=12000H； - 执行结果：AL=12000H对应内存单元的字节数据； 例2： MOV AX, [BP] （BP=0004H，SS=3000H） - 段地址=SS（BP作基址，默认堆栈段）； - 偏移地址=BP的值=0004H； - 物理地址=3000H×16+0004H=30004H； - 执行结果：AX=30004H对应内存单元的字数据 间址寄存器只能是BX、SI、DI、BP（如 MOV AL, [AX] 错误，AX不能作间址寄存器）； 用BP时段地址=SS，其他间址寄存器段地址=DS 
寄存器相对寻址  MOV 寄存器, [寄存器+位移量]  或  MOV 寄存器, 变量名[寄存器]  偏移地址 = 寄存器的值 + 位移量 “位移量”=指令中给出的8位/16位立即数（如10H、-5H）或变量名（变量名的偏移地址作为位移量） 例1： MOV AL, [BX+10H] （BX=2000H，DS=1000H） - 偏移地址=2000H+10H=2010H； - 物理地址=1000H×16+2010H=12010H； - 执行结果：AL=12010H对应内存单元的字节数据； 例2： MOV AX, VAR[SI] （VAR偏移地址=0000H，SI=0002H，DS=1000H） - 偏移地址=0000H+0002H=0002H； - 物理地址=1000H×16+0002H=10002H； - 执行结果：AX=10002H对应内存单元的字数据 位移量可正可负（如 [BX-5H] ，偏移地址=BX-5H）； 常用于访问数组元素（变量名是数组起始地址，寄存器是索引，位移量=起始地址+索引） 
基址变址寻址  MOV 寄存器, [基址寄存器+变址寄存器]  偏移地址 = 基址寄存器的值 + 变址寄存器的值 “基址寄存器”=BX、BP；“变址寄存器”=SI、DI（必须两两组合，不能用两个基址或两个变址寄存器） 例： MOV AL, [BX+SI] （BX=2000H，SI=0010H，DS=1000H） - 偏移地址=2000H+0010H=2010H； - 物理地址=1000H×16+2010H=12010H； - 执行结果：AL=12010H对应内存单元的字节数据 基址寄存器只能是BX、BP，变址寄存器只能是SI、DI（如 [BX+BX] 错误，两个基址寄存器）； 段地址规则：基址寄存器是BP则段地址=SS，是BX则段地址=DS 
相对基址变址寻址  MOV 寄存器, [基址+变址+位移量]  或  MOV 寄存器, 变量名[基址+变址]  偏移地址 = 基址寄存器的值 + 变址寄存器的值 + 位移量 “位移量”=立即数或变量名的偏移地址 例： MOV AX, [BX+SI+20H] （BX=2000H，SI=0010H，DS=1000H） - 偏移地址=2000H+0010H+20H=2030H； - 物理地址=1000H×16+2030H=12030H； - 执行结果：AX=12030H对应内存单元的字数据 最复杂的存储器寻址，常用于访问二维数组（基址=行索引，变址=列索引，位移量=数组起始地址） 
- 考试判断技巧（逐步判断）：
1. 看操作数是否在内存中（指令中有[ ]或变量名，且不是立即数/寄存器）→ 存储器寻址；
2. 看偏移地址组成：
- 仅直接地址/变量名 → 直接寻址；
- 仅寄存器 → 间接寻址；
- 寄存器+位移量 → 相对寻址；
- 基址+变址 → 基址变址寻址；
- 基址+变址+位移量 → 相对基址变址寻址。
 
二、与转移地址有关的寻址（控制转移指令用，逐类拆解）
 
1. 分类（4种组合，段间间接不考，逐类逐术语拆解）
 
分类维度 类型 核心定义（逐字解释） 底层逻辑 
按转移范围 段内转移 转移地址在「当前代码段」内（“段内”=CS寄存器的值不变），仅修改EIP（指令指针寄存器） 当前代码段的段地址=CS，转移地址的段地址=CS，无需修改CS，仅修改EIP为转移地址的偏移量 
 段间转移 转移地址在「其他代码段」内（“段间”=CS寄存器的值改变），需同时修改CS和EIP 转移地址的段地址≠当前CS，需将转移地址的段地址送入CS，偏移地址送入EIP 
按地址来源 直接转移 转移地址「直接写在指令中」（用标号表示，“直接”=地址在指令里，无需寻找） 标号是转移地址的别名，汇编时标号替换为段地址和/或偏移地址，指令执行时直接使用 
 间接转移 转移地址存放在「寄存器或内存中」（“间接”=地址不在指令里，需从寄存器/内存中读取） 指令中写寄存器/内存地址，执行时先从寄存器/内存中取出转移地址，再修改CS和/或EIP 
 
2. 表现形式（指令举例，逐指令拆解）
 
- 段内直接短转移： JMP SHORT LABEL 
- JMP：无条件转移指令；
- SHORT：短转移关键字（“SHORT”=短距离，偏移量范围±127字节）；
- LABEL：当前代码段内的标号（转移目标地址的别名）；
- 执行逻辑：EIP=EIP+偏移量（偏移量=LABEL的偏移地址-EIP的当前值），CS不变；
- 适用场景：转移距离近（±127字节），节省指令内存（指令长度2字节）。
- 段内直接近转移： JMP NEAR PTR LABEL 
- NEAR PTR：近转移关键字（“NEAR”=近距离，偏移量范围±32767字节）；
- 执行逻辑：EIP=EIP+偏移量，CS不变；
- 适用场景：同一段内中长距离转移（指令长度3字节）。
- 段内间接转移： JMP BX  /  JMP [SI] 
- 例1： JMP BX （BX=1234H，CS=2000H）
- 执行逻辑：EIP=BX的值=1234H，CS不变=2000H；
- 转移地址=CS:EIP=2000H:1234H=21234H；
- 例2： JMP [SI] （SI=0000H，DS=3000H，内存30000H=5678H）
- 执行逻辑：从内存30000H取出偏移地址=5678H，EIP=5678H，CS不变；
- 转移地址=CS:5678H；
- 适用场景：动态转移（转移地址由程序运行时的数据决定，如根据用户输入修改BX的值）。
- 段间直接转移： JMP FAR PTR LABEL 
- FAR PTR：远转移关键字（“FAR”=远距离，跨段转移）；
- LABEL：其他代码段的标号（包含段地址和偏移地址）；
- 执行逻辑：CS=LABEL的段地址，EIP=LABEL的偏移地址；
- 例：LABEL的段地址=4000H，偏移地址=0000H → 转移地址=4000H:0000H=40000H；
- 适用场景：跨段跳转（如从代码段CODE1跳到代码段CODE2）。
 
3. 考试重点（逐点解释）
 
- 段内转移 vs 段间转移：核心看是否修改CS（段内不修改，段间修改）；
- 直接转移 vs 间接转移：核心看地址是否在指令中（直接用标号，间接用寄存器/内存）；
- Jxx条件转移指令：仅支持「段内直接短转移」（偏移量范围±127字节），原因：Jxx指令长度仅2字节，节省内存（若支持长转移，指令长度会增加）。
 
第4页：指令（一）—— 数据传送类指令（逐字逐词拆解）
 
数据传送类指令核心是「数据的复制与转移」（“传送”=复制，源操作数不变，目的操作数被覆盖），多数不影响标志位（除PUSH/POP对CF的间接影响），是编程的基础，考试占比极高，需逐指令、逐字段、逐规则拆解。
 
1. MOV 指令（Move，数据传送指令，最核心）
 
（1）指令本质拆解
 
- MOV：英文全称Move（移动），但实际是「数据复制」（源操作数的值不变，仅复制到目的操作数），非物理移动；
- 核心功能：将源操作数的数值复制到目的操作数，覆盖目的操作数原有值；
- 格式： MOV 目的操作数, 源操作数 （“目的操作数”=接收数据的对象，“源操作数”=提供数据的对象）。
 
（2）3条核心规则（考试必考，逐字逐词解释+底层原因）
 
规则1：操作数类型必须匹配
 
- 类型：指数据的长度（字节BYTE/字WORD/双字DWORD），“匹配”=目的操作数与源操作数的长度完全一致（CPU硬件限制：不同长度数据无法直接复制，需转换后再传）；
- 正确实例（逐句拆解）：
-  MOV AL, 30H ：AL是8位（字节），30H是8位立即数（字节）→ 类型匹配；
- 执行结果：AL=30H（源操作数30H不变）；
-  MOV AX, 1234H ：AX是16位（字），1234H是16位立即数（字）→ 类型匹配；
- 执行结果：AX=1234H；
-  MOV EAX, 12345678H ：EAX是32位（双字），12345678H是32位立即数（双字）→ 类型匹配；
- 执行结果：EAX=12345678H；
- 错误实例（逐句解释原因）：
-  MOV AL, 1234H ：AL是8位（字节），1234H是16位（字）→ 类型不匹配；
- 错误原因：1234H占用2字节，AL仅能存储1字节，数据溢出，CPU无法执行；
-  MOV AX, BL ：AX是16位（字），BL是8位（字节）→ 类型不匹配；
- 错误原因：BL的8位数据无法直接填充AX的16位，需显式扩展（如 MOV AH, 0；MOV AL, BL ）。
 
规则2：不能直接实现“内存→内存”传送
 
- 内存→内存：源操作数和目的操作数都是内存单元（如[BX]、VAR），“直接”=不通过中间介质（寄存器）；
- 底层原因：CPU硬件设计不支持内存单元之间直接数据通路，需通过寄存器中转（寄存器是CPU内部高速单元，可同时连接两个内存单元）；
- 正确实现（逐句拆解）：
asm
  

MOV AL, [BX]  ; 第一步：内存[BX]→寄存器AL（内存→寄存器）
MOV [SI], AL  ; 第二步：寄存器AL→内存[SI]（寄存器→内存）
 
 
- 执行逻辑：先将内存[BX]的数据复制到AL，再将AL的数据复制到内存[SI]，间接实现内存→内存传送；
- 错误实例： MOV [BX], [SI]  → 直接内存→内存，汇编器报错“Invalid combination of opcode and operands”（操作码和操作数组合无效）。
 
规则3：段寄存器的特殊限制（3点，逐点解释底层原因）
 
- 限制1：源操作数和目的操作数不能同时是段寄存器；
- 实例： MOV CS, DS  错误；
- 底层原因：段寄存器是16位专用寄存器，CPU内部无段寄存器之间的直接数据通路，需通过通用寄存器中转（如 MOV AX, DS；MOV CS, AX ，但CS不能直接赋值，见限制2）；
- 限制2：不能直接给CS赋值；
- 实例： MOV CS, 2000H  错误；
- 底层原因：CS（代码段寄存器）直接关联程序执行地址（CS:EIP），若允许直接修改，可能导致程序跳转到非法地址（如未定义的内存），引发崩溃，CPU硬件禁止直接赋值，仅能通过JMP/CALL/RET等转移指令间接修改；
- 限制3：其他段寄存器（DS/ES/SS）可赋值，但不能直接接立即数/段名；
- 实例： MOV DS, 2000H  错误， MOV DS, DATA  错误（DATA是段名）；
- 正确实例： MOV AX, 2000H；MOV DS, AX  或  MOV AX, DATA；MOV DS, AX ；
- 底层原因：段寄存器的赋值逻辑仅支持从通用寄存器接收数据（CPU指令集设计），立即数和段名（汇编时是符号，非数值）无法直接写入。
 
（3）考试易错点（逐点解释原因+规避方法）
 
- 易错点1： MOV DS, DATA  错误 → 原因：DATA是段名，段寄存器不能直接接段名；规避：用AX中转（ MOV AX, DATA；MOV DS, AX ）；
- 易错点2： MOV [AX], BX  错误 → 原因：AX不能作间址寄存器（存储器寻址中间址寄存器仅BX/SI/DI/BP）；规避：用BX代替AX（ MOV [BX], BX ）；
- 易错点3： MOV CS, AX  错误 → 原因：CS不能直接赋值；规避：用JMP间接修改（ JMP FAR PTR LABEL ，修改CS和EIP）。
 
2. PUSH / POP 指令（堆栈操作指令，Stack Push/Pop）
 
（1）堆栈本质拆解
 
- 堆栈：英文Stack，是内存中一块「先进后出（FILO）」的连续区域（“先进后出”=先压入的数据后弹出，类似堆盘子）；
- 堆栈定位：由 SS:ESP 联合定位（SS=Stack Segment，堆栈段地址；ESP=Stack Pointer，栈顶指针），“栈顶”=堆栈中最后压入数据的内存单元，ESP永远指向栈顶；
- 核心用途：临时存储数据、子程序返回地址、参数传递（避免占用寄存器资源）。
 
（2）PUSH 指令（压栈，Push onto Stack）
 
- 指令含义：“Push”=推，将操作数“推”入堆栈（压栈），栈顶指针向下移动（内存地址减小）；
- 格式： PUSH 操作数 （操作数必须是字/双字，不能是字节）；
- 操作数限制：“字节”=8位（如AL、BL），“字”=16位（如AX、BX），“双字”=32位（如EAX、EBX）；
- 底层原因：堆栈操作的最小单位是字（16位），32位模式下默认双字（32位），字节操作会破坏堆栈对齐（堆栈地址需是2/4的倍数），导致程序崩溃；
- 32位模式下操作步骤（逐步拆解，含二进制）：
1. ESP = ESP - 4（“ESP减4”=栈顶指针向下移动4字节，空出32位空间，双字压栈）；
2. 将操作数的32位数据按小端序压入栈顶（ SS:ESP 指向的地址）；
3. 小端序存储：低字节存低地址，高字节存高地址（x86架构强制规则）；
- 实例（逐句拆解，ESP初始值=00001000H，EAX=12345678H）：
- 指令： PUSH EAX ；
- 步骤1：ESP = 1000H - 4 = 00000FFCH；
- 步骤2：EAX=12345678H（二进制：0001 0010 0011 0100 0101 0110 0111 1000B）；
- 栈顶存储（低地址→高地址）：78H（低字节）、56H、34H、12H（高字节）；
- 结果：ESP=00000FFCH，栈顶 SS:0FFCH 存储12345678H。
 
（3）POP 指令（出栈，Pop from Stack）
 
- 指令含义：“Pop”=弹出，从栈顶取出数据“弹”到操作数，栈顶指针向上移动（内存地址增大）；
- 格式： POP 操作数 （操作数必须是字/双字，不能是字节）；
- 32位模式下操作步骤（承接上述PUSH实例）：
1. 从栈顶（ SS:ESP ）取出32位数据，按小端序组合后送入目的操作数；
2. ESP = ESP + 4（栈顶指针向上移动4字节，释放栈顶空间）；
- 实例（逐句拆解）：
- 指令： POP EBX ；
- 步骤1：从栈顶00000FFCH取出数据（78H、56H、34H、12H），组合为12345678H，送入EBX；
- 步骤2：ESP = 00000FFCH + 4 = 00001000H（恢复到压栈前的ESP值）；
- 结果：EBX=12345678H，ESP=00001000H，堆栈平衡。
 
（4）考试重点（逐点解释+实例验证）
 
- 重点1：操作数不能是字节 → 实例： PUSH AL 、 POP BL  错误， PUSH AX 、 POP BX  正确；
- 重点2：堆栈平衡 → “平衡”=PUSH和POP的次数相等（压入n次，弹出n次），否则ESP错乱；
- 反例： PUSH EAX；PUSH EBX；POP EAX  → 压入2次，弹出1次，ESP=1000H-8+4=0FFCH≠初始值，后续操作栈顶地址错误；
- 重点3：段寄存器可压栈/弹出 → 实例： PUSH DS （压入DS的值）、 POP ES （弹出到ES）正确；
- 注意： POP CS  合法但危险（直接修改CS，导致程序跳转到未知地址），考试不建议使用；
- 重点4：应用题常考堆栈变化 → 给定PUSH/POP序列，要求计算ESP值、栈顶数据、栈内存储顺序，需逐步模拟（如 PUSH AX；PUSH BX；POP AX；POP BX ，ESP最终恢复初始值）。
 
3. LEA 指令（Load Effective Address，取有效地址指令）
 
（1）指令本质拆解
 
- LEA：英文全称Load Effective Address，“Load”=加载（送入寄存器），“Effective Address”=有效地址（内存单元的偏移地址，“有效”=可直接用于寻址的地址）；
- 核心功能：将内存单元的「偏移地址」（而非内存中的数据）加载到通用寄存器，本质是“地址传送”，非“数据传送”；
- 格式： LEA 寄存器, 内存单元 （“内存单元”=用存储器寻址表示，如[BX]、VAR）。
 
（2）与MOV的核心区别（考试必考，逐实例对比）
 
- 关键区别：MOV取内存单元的「数据」，LEA取内存单元的「偏移地址」；
- 对比实例（逐句拆解，变量定义： VAR DW 1234H ，VAR的偏移地址=0000H，内存0000H=34H，0001H=12H）：
指令 执行过程（逐步） 执行结果 本质 
 MOV AX, VAR  1. VAR是内存单元（直接寻址），段地址=DS； 2. 计算物理地址=DS×16+0000H； 3. 从物理地址取出字数据（34H+12H=1234H）； 4. 将数据1234H送入AX； AX=1234H 数据传送（取内存数据） 
 LEA AX, VAR  1. VAR是内存单元，直接获取其偏移地址=0000H； 2. 将偏移地址0000H送入AX； 3. 不访问内存，仅提取地址； AX=0000H 地址传送（取偏移地址） 
 
（3）常见用法（考试实例拆解）
 
- 用法1：获取简单变量的偏移地址（如上述实例）；
- 用法2：获取复杂内存地址（计算表达式后的偏移地址，无需手动计算）；
- 实例： LEA BX, [SI+DI+10H] （SI=0002H，DI=0003H）；
- 执行过程：计算偏移地址=0002H+0003H+10H=0015H，将0015H送入BX；
- 优势：无需手动计算地址，汇编器自动解析表达式，避免计算错误；
- 对比MOV： MOV BX, SI+DI+10H  错误（MOV不能直接计算寄存器+立即数的表达式，需分步： MOV BX, SI；ADD BX, DI；ADD BX, 10H ）。
 
（4）考试易错点
 
- 易错点：将LEA误用作MOV，如 LEA AL, VAR  错误（AL是8位，VAR的偏移地址是16位，类型不匹配）；
- 规避：LEA的目的寄存器需是16/32位（如AX、BX、EAX），匹配偏移地址的长度。
 
4. XLAT 指令（Translate，查表转换指令）
 
（1）指令本质拆解
 
- XLAT：英文全称Translate，“转换”=根据索引从表格中查找对应值，实现“索引→值”的映射（如0→'0'、1→'1'）；
- 核心功能：字节查表转换（仅支持字节，不支持字/双字），无需手动计算表格地址，简化查表逻辑；
- 底层依赖：固定寄存器搭配（BX=表格偏移地址，AL=索引），CPU硬件设计固定，不可修改。
 
（2）必须满足的3个前提（考试必考，逐点解释）
 
前提1：表格定义（字节型表格，DB伪指令）
 
- “字节型表格”=表格中每个元素是1字节（DB伪指令定义），“表格”=连续的内存单元（元素按顺序存储）；
- 实例： TABLE DB 30H, 31H, 32H, 33H （对应索引0→'0'、1→'1'、2→'2'、3→'3'）；
- 存储：TABLE的偏移地址=0000H，内存0000H=30H、0001H=31H、0002H=32H、0003H=33H。
 
前提2：BX寄存器=表格的偏移地址
 
- “表格的偏移地址”=表格在数据段中的偏移地址（如TABLE的偏移地址=0000H）；
- 赋值方式： MOV BX, OFFSET TABLE （OFFSET取表格的偏移地址，送入BX）；
- 底层原因：XLAT指令默认从BX获取表格基地址，硬件设计固定，不可用其他寄存器（如CX）替代。
 
前提3：AL寄存器=表格的索引值
 
- “索引值”=表格中元素的位置（0-based，即第0项、第1项…，范围0~表格长度-1）；
- 限制：索引值必须是8位（0~255），表格长度最大256字节；
- 底层原因：AL是8位寄存器，XLAT指令仅读取AL的8位作为索引，超出则索引错误（如表格长度=4，AL=4→索引越界，读取无效数据）。
 
（3）操作过程（唯一逻辑，逐步拆解）
 
- 核心逻辑： AL = [BX + AL] （将表格中“BX+AL”偏移地址对应的字节数据，覆盖写入AL）；
- 实例（承接上述表格定义）：
asm
  

MOV BX, OFFSET TABLE  ; 步骤1：BX=0000H（表格偏移地址）
MOV AL, 2             ; 步骤2：AL=2（索引值，取第2项）
XLAT                  ; 步骤3：计算地址=BX+AL=0000H+2=0002H；从0002H取出32H；AL=32H
 
- 结果：AL=32H（对应字符'2'），实现索引→值的转换。
 
（4）考试注意事项
 
- 注意1：表格必须用DB定义（字节型），用DW/DD定义会导致数据长度不匹配（XLAT仅读取1字节）；
- 注意2：寄存器搭配不能错（BX=地址，AL=索引），错用其他寄存器（如CX=地址）会导致查表失败；
- 注意3：索引值不能超出表格长度（如表格长度=4，AL=4→读取内存0004H的随机数据，结果错误）。
 
第5页：指令（二）—— 算术运算类指令（逐字逐词拆解）
 
算术运算类指令核心是「数值的加减运算」，多数会影响标志位（CF/ZF/SF/OF/AF/PF），标志位是后续分支/循环指令的判断依据，需逐指令、逐标志位、逐规则拆解。
 
1. 核心指令（ADD/SUB/INC/DEC/CMP，逐指令拆解）
 
（1）ADD 指令（Add，加法指令）
 
- 指令本质：“Add”=加，将源操作数的值与目的操作数的值相加，结果存入目的操作数（覆盖原有值）；
- 格式： ADD 目的操作数, 源操作数 ；
- 操作数类型：支持寄存器-寄存器、寄存器-立即数、寄存器-内存、内存-立即数（不支持内存-内存，同MOV规则）；
- 实例（逐步拆解，AL=30H，BL=20H）：
- 指令： ADD AL, BL ；
- 执行过程：30H（AL）+20H（BL）=50H；将50H存入AL；
- 结果：AL=50H，BL=20H（源操作数不变）；
- 对标志位的影响（逐位解释）：
- CF（进位标志）：0（无进位，50H未超出8位无符号数范围0~255）；
- ZF（零标志）：0（结果50H≠0）；
- SF（符号标志）：0（结果最高位=0，正数）；
- OF（溢出标志）：0（结果50H在8位有符号数范围-128~+127内）；
- AF（半进位标志）：0（低4位0+0=0，无进位到高4位）；
- PF（奇偶标志）：1（结果二进制101000，含2个1，偶数个）；
- 易错点： ADD DS, AX  错误（段寄存器不能直接参与算术运算）； ADD AL, AX  错误（类型不匹配）。
 
（2）SUB 指令（Subtract，减法指令）
 
- 指令本质：“Subtract”=减，将目的操作数的值减去源操作数的值，结果存入目的操作数；
- 底层逻辑：减法等价于“目的操作数 + （-源操作数的补码）”（计算机仅能做加法，减法通过补码转换为加法）；
- 格式： SUB 目的操作数, 源操作数 ；
- 实例（逐步拆解，AX=50H，BX=30H）：
- 指令： SUB AX, BX ；
- 执行过程：50H - 30H = 20H（补码转换：30H的补码=D0H，50H+D0H=120H，舍弃进位1→20H）；
- 结果：AX=20H，BX=30H（源操作数不变）；
- 对标志位的影响：与ADD一致（影响所有6个标志位）；
- 例： SUB AL, 20H （AL=10H）→ 10H-20H=0F0H（借位，CF=1；结果≠0，ZF=0；最高位=1，SF=1）。
 
（3）INC 指令（Increment，自增1指令）
 
- 指令本质：“Increment”=增加，将操作数的值加1，结果存入操作数；
- 格式： INC 操作数 （操作数=寄存器/内存，不能是立即数/段寄存器）；
- 实例： MOV CX, 5；INC CX  → CX=6；
- 对标志位的影响（核心考点）：不影响CF标志位（底层原因：INC是“自增1”，设计时忽略进位，避免影响循环逻辑），影响ZF/SF/OF/AF/PF；
- 例： MOV AL, 0FFH；INC AL  → AL=00H（ZF=1，CF=0，无进位）；
- 用途：循环计数器自增（如 INC CX；JNZ LOOP_LABEL ）。
 
（4）DEC 指令（Decrement，自减1指令）
 
- 指令本质：“Decrement”=减少，将操作数的值减1，结果存入操作数；
- 格式： DEC 操作数 （同INC，不能是立即数/段寄存器）；
- 实例： MOV BX, 3；DEC BX  → BX=2；
- 对标志位的影响：不影响CF标志位（同INC），影响其他5个标志位；
- 例： MOV AL, 00H；DEC AL  → AL=0FFH（SF=1，CF=0，无借位）；
- 用途：循环计数器自减（如 DEC CX；JNZ LOOP_LABEL ）。
 
（5）CMP 指令（Compare，比较指令，重中之重）
 
- 指令本质：“Compare”=比较，执行“目的操作数 - 源操作数”，但不保存结果（仅修改标志位）；
- 核心用途：配合Jxx条件转移指令，实现分支判断（比较后根据标志位决定是否跳转）；
- 格式： CMP 目的操作数, 源操作数 ；
- 与SUB的区别（考试必考）：
- SUB：保存减法结果（覆盖目的操作数），修改标志位；
- CMP：不保存结果（目的操作数不变），仅修改标志位；
- 实例（逐步拆解，AX=40H，BX=30H）：
- 指令： CMP AX, BX ；
- 执行过程：40H - 30H = 10H（不保存结果）；修改标志位（CF=0，ZF=0，SF=0，OF=0）；
- 后续分支： JG LABEL （AX>BX，标志位满足，跳转）；
- 易错点：CMP不修改任何操作数，仅改标志位，若误将CMP当作SUB使用（期望保存结果），会导致逻辑错误。
 
2. 关键考点：对标志位的影响（逐位拆解）
 
标志位（FLAGS寄存器的位）是“指令执行结果的状态记录”，后续Jxx指令依赖其判断，需逐位解释定义、判断规则、实例验证。
 
（1）6个核心标志位（逐位拆解）
 
标志位 英文全称 中文含义 判断规则（逐字解释） 实例验证（基于ADD/Sub/CMP） 
CF Carry Flag 进位/借位标志 无符号数运算： 加法→结果超出无符号数的最大范围（如8位0~255）→ CF=1（进位）； 减法→被减数 < 减数→ CF=1（借位）； 否则CF=0 例1（加法进位）： ADD AL, 0FFH （AL=1）→ 1+255=256（超出8位范围）→ CF=1； 例2（减法借位）： SUB AL, 2 （AL=1）→ 1<2→ CF=1 
ZF Zero Flag 零标志 运算结果=0→ ZF=1； 结果≠0→ ZF=0 例： CMP AX, AX （AX-AX=0）→ ZF=1；  ADD AL, 1 （AL=0）→ AL=1≠0→ ZF=0 
SF Sign Flag 符号标志 运算结果的最高位（符号位）=1→ SF=1（负数）； 最高位=0→ SF=0（正数）； （仅当ZF=0时有效，ZF=1时结果为0，无正负） 例1（正数）： ADD AL, 10H （结果00010000B，最高位0）→ SF=0； 例2（负数）： SUB AL, 20H （AL=10H，结果11110000B，最高位1）→ SF=1 
OF Overflow Flag 溢出标志 有符号数运算： 结果超出有符号数的范围（8位-128~+127）→ OF=1（溢出）； 否则OF=0； （溢出判断技巧：正数+正数=负数，负数+负数=正数→ 溢出） 例1（溢出）： ADD AL, 7FH （AL=1，7FH=+127）→ 1+127=128（超出+127）→ 结果80H（-128）→ OF=1； 例2（不溢出）： ADD AL, 30H （AL=20H，结果50H=+80）→ OF=0 
AF Auxiliary Flag 半进位标志 算术运算时，低4位（bit0~bit3）向高4位（bit4~bit7）产生进位/借位→ AF=1； 否则AF=0 例（半进位）： ADD AL, 0FH （AL=1）→ 1+15=16（低4位15+1=16，向高4位进位）→ AF=1； 例（无半进位）： ADD AL, 0EH （AL=1）→ 1+14=15→ AF=0 
PF Parity Flag 奇偶标志 运算结果的低8位中，1的个数为偶数→ PF=1； 为奇数→ PF=0； （仅关注低8位，与高位无关） 例1（偶数个1）： ADD AL, 20H （结果00100000B，1个1→ 奇数）→ PF=0； 例2（偶数个1）： ADD AL, 30H （结果00110000B，2个1→ 偶数）→ PF=1 
 
（2）指令对标志位的影响总结（考试填空/判断题高频）
 
指令 CF ZF SF OF AF PF 核心记忆点 
ADD √ √ √ √ √ √ 全影响 
SUB √ √ √ √ √ √ 全影响 
INC × √ √ √ √ √ 不影响CF 
DEC × √ √ √ √ √ 不影响CF 
CMP √ √ √ √ √ √ 全影响（同ADD/SUB） 
 
- 口诀：ADD/SUB/CMP全影响，INC/DEC不影响CF（考试直接套用）。
 
3. 难点：溢出（OF）与进位（CF）的区别（问答题必考，逐字拆解）
 
（1）核心定义（逐字解释，结合8位运算实例）
 
进位（CF）：无符号数的“超界”标志
 
- 针对对象：无符号数（“无符号数”=仅表示正数，范围0~2ⁿ-1，n=位数）；
- 判断标准：运算结果超出无符号数的最大范围→ 产生进位（加法）或借位（减法）→ CF=1；
- 实例（8位无符号数，范围0~255）：
- 加法进位： 9FH（159） + 61H（97） = 100H（256）  → 256>255（超界）→ CF=1；
- 减法借位： 10H（16） - 20H（32） = 0F0H（240）  → 16<32（超界）→ CF=1；
- 无进位/借位： 30H（48） + 20H（32） = 50H（80）  → 80≤255→ CF=0。
 
溢出（OF）：有符号数的“超界”标志
 
- 针对对象：有符号数（“有符号数”=用最高位表示符号，0=正，1=负，范围-2ⁿ⁻¹~+2ⁿ⁻¹-1，n=位数）；
- 判断标准：运算结果超出有符号数的范围→ 符号异常（正数变负数，负数变正数）→ OF=1；
- 实例（8位有符号数，范围-128~+127）：
- 加法溢出： 7FH（+127） + 01H（+1） = 80H（-128）  → +128超出+127（超界）→ 正数变负数→ OF=1；
- 减法溢出： 80H（-128） - 01H（-1） = 7FH（+127）  → -129超出-128（超界）→ 负数变正数→ OF=1；
- 无溢出： 30H（+48） + 20H（+32） = 50H（+80）  → +80在范围內→ OF=0。
 
（2）关键区别（考试答题模板，逐点逐字解释）
 
1. 针对对象不同：
- CF针对「无符号数」（仅表示大小，无正负）；
- OF针对「有符号数」（有正负，最高位是符号位）；
2. 判断标准不同：
- CF看「结果是否超出无符号数的范围」（加法超界=进位，减法超界=借位）；
- OF看「结果是否超出有符号数的范围」（超界=符号异常，正数变负或负数变正）；
3. 独立性不同：
- CF和OF无必然联系（可同时为1、同时为0、一1一0）；
- 实例1（同时为1）： 9FH（无符号159/有符号-97） + 61H（无符号97/有符号+97） = 100H  → CF=1（无符号超界），OF=1（有符号-97+97=-256，超界）；
- 实例2（CF=1，OF=0）： 0FFH（无符号255/有符号-1） + 01H（无符号1/有符号+1） = 100H  → CF=1（无符号超界），OF=0（有符号-1+1=0，未超界）；
- 实例3（CF=0，OF=1）： 7FH（+127） + 02H（+2） = 81H（-127）  → CF=0（无符号127+2=129≤255），OF=1（有符号超界）。
 
（3）考试答题技巧（直接套用模板）
 
- 题目：简述溢出（OF）与进位（CF）的区别？
- 答案：1. 针对对象不同：CF针对无符号数，OF针对有符号数；2. 判断标准不同：CF看无符号数是否超界（进位/借位），OF看有符号数是否超界（符号异常）；3. 独立性不同：两者无必然联系，可独立为0或1。
 
第6页：指令（三）—— 位处理+控制转移+串操作指令（逐字逐词拆解）
 
一、位处理指令（Bit Manipulation Instructions，按位操作）
 
位处理指令是「对数据的二进制位进行单独操作」（如清位、置位、移位），不影响其他位，多用于硬件控制、数据加密等场景，分位运算指令和移位指令两类。
 
1. 位运算指令（5条，AND/OR/NOT/NEG/TEST，逐指令拆解）
 
（1）AND 指令（Logical AND，按位与指令）
 
- 指令本质：“AND”=逻辑与，对目的操作数和源操作数的「每一位」执行“全1则1，否则0”的逻辑运算，结果存入目的操作数；
- 格式： AND 目的操作数, 源操作数 ；
- 位运算规则（逐位验证）：
目的位 源位 结果位 实例（二进制） 
0 0 0 0 & 0 = 0 
0 1 0 0 & 1 = 0 
1 0 0 1 & 0 = 0 
1 1 1 1 & 1 = 1 
- 典型应用（考试重点，逐例拆解）：
- 应用1：清位（将某几位变为0）→ 源操作数对应位为0，其他位为1；
- 实例：清AL的第3位（bit3），AL=0FH（00001111B）；
- 指令： AND AL, 0F7H （0F7H=11110111B，bit3=0）；
- 运算：00001111B & 11110111B = 00000111B（AL=07H）；
- 结果：bit3被清0，其他位不变；
- 应用2：保留位（将某几位保留，其他位清0）→ 源操作数对应位为1，其他位为0；
- 实例：保留AL的低4位，AL=3AH（00111010B）；
- 指令： AND AL, 0FH （0FH=00001111B，低4位=1）；
- 运算：00111010B & 00001111B = 00001010B（AL=0AH）；
- 结果：低4位保留，高4位清0；
- 对标志位的影响：影响ZF/SF/PF，CF=0（固定），不影响OF/AF；
- 例： AND AL, 0  → AL=0→ ZF=1，CF=0；
- 易错点： AND [BX], [SI]  错误（内存-内存操作不允许）； AND AL, 1234H  错误（类型不匹配）。
 
（2）OR 指令（Logical OR，按位或指令）
 
- 指令本质：“OR”=逻辑或，对目的操作数和源操作数的「每一位」执行“有1则1，否则0”的逻辑运算，结果存入目的操作数；
- 格式： OR 目的操作数, 源操作数 ；
- 位运算规则（逐位验证）：
目的位 源位 结果位 实例（二进制） 
0 0 0 0 
0 1 1 0 
1 0 1 1 
1 1 1 1 
- 典型应用（考试重点，逐例拆解）：
- 应用1：置位（将某几位变为1）→ 源操作数对应位为1，其他位为0；
- 实例：置AL的第2位（bit2），AL=0FH（00001111B）；
- 指令： OR AL, 04H （04H=00000100B，bit2=1）；
- 运算：00001111B | 00000100B = 00001111B（AL=0FH，bit2已为1，无变化）；
- 若AL=0BH（00001011B），运算后=00001111B（AL=0FH），bit2置1；
- 应用2：合并数据（将两个数的不同位合并为1）；
- 实例：AL=0AH（00001010B），BL=05H（00000101B），合并为00001111B；
- 指令： OR AL, BL ；
- 运算：00001010B | 00000101B = 00001111B（AL=0FH）；
- 对标志位的影响：同AND（影响ZF/SF/PF，CF=0，不影响OF/AF）；
- 易错点：OR指令会修改目的操作数（区别于TEST指令）。
 
（3）NOT 指令（Logical NOT，按位取反指令）
 
- 指令本质：“NOT”=逻辑非，对操作数的「每一位」执行“0→1，1→0”的取反操作，结果存入操作数；
- 格式： NOT 操作数 （操作数=寄存器/内存，不能是立即数）；
- 位运算规则（逐位验证）：
原位 结果位 实例（二进制） 
0 1 ~0 = 1 
1 0 ~1 = 0 
- 实例（逐步拆解）：
- 指令： MOV BL, 3FH（00111111B）；NOT BL ；
- 运算：~00111111B = 11000000B（0C0H）；
- 结果：BL=0C0H；
- 对标志位的影响：不影响任何标志位（核心考点，考试判断题高频）；
- 例： NOT AL （AL=0）→ AL=0FFH，FLAGS寄存器无任何变化；
- 易错点：NOT是“按位取反”，不是“求反码”（反码=符号位不变，其他位取反；NOT是所有位取反）；
- 例：AL=80H（-128，有符号数）→ NOT AL=7FH（+127，所有位取反），反码=FFH（符号位1不变，其他位取反）。
 
（4）NEG 指令（Negate，求补码指令）
 
- 指令本质：“Negate”=否定、求反，对操作数执行“0 - 操作数”的运算，结果存入操作数（等价于“按位取反+1”，即补码）；
- 格式： NEG 操作数 （操作数=寄存器/内存，不能是立即数）；
- 底层逻辑：补码=反码+1，NEG指令直接计算补码（计算机中负数以补码存储）；
- 实例（逐步拆解）：
- 例1：AL=30H（+48）→ NEG AL；
- 运算：0 - 30H = 0D0H（-48的补码=~30H+1=CFH+1=D0H）；
- 结果：AL=0D0H；
- 例2：AL=0 → NEG AL；
- 运算：0 - 0 = 0；
- 结果：AL=0，CF=0（唯一CF=0的情况）；
- 对标志位的影响：影响所有标志位，CF=1（除非操作数=0）；
- 例： NEG AL （AL=1）→ AL=0FFH（-1），CF=1，SF=1，ZF=0；
- 与NOT的区别（考试必考）：
- NOT：按位取反（无+1），不影响标志位；
- NEG：按位取反+1（补码），影响所有标志位；
- 实例：AL=30H → NOT AL=CFH，NEG AL=D0H（CFH+1）。
 
（5）TEST 指令（Test，测试指令）
 
- 指令本质：“Test”=测试，对目的操作数和源操作数执行“按位与”运算，但不保存结果，仅修改标志位；
- 格式： TEST 目的操作数, 源操作数 ；
- 与AND的区别（考试必考，逐点对比）：
对比维度 TEST 指令 AND 指令 
结果保存 不保存（目的操作数不变） 保存（结果存入目的操作数） 
核心用途 测试某几位是否为1（如判断bit0是否为1） 清位、保留位（修改目的操作数） 
标志位影响 同AND（影响ZF/SF/PF，CF=0） 同TEST 
- 典型应用（考试重点，逐例拆解）：
- 应用：测试某一位是否为1（通过ZF判断，ZF=0→位为1，ZF=1→位为0）；
- 实例：判断AL的第0位（bit0）是否为1，若为1则跳至LABEL；
- 指令： TEST AL, 01H （01H=00000001B，仅bit0=1）；
- 运算：AL的bit0与1进行AND运算，其他位与0运算（结果为0）；
- 标志位：若AL的bit0=1→ 结果≠0→ ZF=0→  JNZ LABEL （跳转）；
- 若AL的bit0=0→ 结果=0→ ZF=1→ 不跳转；
- 易错点：TEST不修改目的操作数，若误将TEST当作AND使用（期望清位），会导致逻辑错误。
 
2. 移位指令（8条，按功能分类，逐指令拆解）
 
移位指令是「将操作数的二进制位按指定方向移动」（左移/右移），移出的位可能存入CF或循环填入，分逻辑移位、算术移位、循环移位三类，核心是“移位方向、是否带进位、对符号位的影响”。
 
（1）移位次数规则（所有移位指令通用，考试必考）
 
- 规则1：移位次数=1时，直接写次数（如 SHL AX, 1 ）；
- 规则2：移位次数>1时，必须用CL寄存器存储次数（如 MOV CL, 3；SHR BX, CL ）；
- 底层原因：CPU指令集设计，移位指令的“移位次数”字段仅支持1位（0~1），次数>1时需通过CL寄存器传递；
- 易错点： SHL AX, 3  错误（次数>1未用CL）； MOV CL, 1；SHL AX, CL  正确（等价于 SHL AX, 1 ）。
 
（2）逻辑移位（Logical Shift，针对无符号数，2条）
 
逻辑移位不考虑符号位，仅按二进制位移动，高位/低位补0。
 
① SHL 指令（Shift Left Logical，逻辑左移）
 
- 指令本质：“Shift Left”=左移，“Logical”=逻辑（无符号），操作数左移n位，最高位移入CF，最低位补0；
- 格式： SHL 操作数, 次数 ；
- 等价运算：无符号数×2ⁿ（左移1位×2，左移2位×4，依此类推）；
- 实例（逐位拆解，AL=0AH=00001010B，CL=1）：
- 指令： SHL AL, CL ；
- 移位过程：最高位0→CF=0；最低位补0→ 00010100B（14H）；
- 结果：AL=14H（0AH×2=14H），CF=0；
- 对标志位的影响：CF=移出的最高位；ZF/SF/PF由结果决定；OF仅在次数=1时有效（最高位≠CF则OF=1）；
- 例： SHL AL, 1 （AL=7FH=01111111B）→ 最高位0→CF=0；结果=11111110B（FEH）；最高位（1）≠CF（0）→ OF=1（有符号数溢出）。
 
② SHR 指令（Shift Right Logical，逻辑右移）
 
- 指令本质：“Shift Right”=右移，“Logical”=逻辑（无符号），操作数右移n位，最低位移入CF，最高位补0；
- 格式： SHR 操作数, 次数 ；
- 等价运算：无符号数÷2ⁿ（向下取整）；
- 实例（逐位拆解，AX=1000H=0001000000000000B，CL=2）：
- 指令： SHR AX, CL ；
- 移位过程：最低位0→CF=0，次低位0→CF=0；最高位补0→ 0000010000000000B（0400H）；
- 结果：AX=0400H（1000H÷4=0400H），CF=0；
- 对标志位的影响：CF=移出的最低位；其他标志位同SHL；
- 例： SHR AL, 1 （AL=0F0H=11110000B，无符号240）→ 结果=078H（120），CF=0，SF=0（最高位补0）。
 
（3）算术移位（Arithmetic Shift，针对有符号数，2条）
 
算术移位考虑符号位，右移时最高位（符号位）保持不变，左移与逻辑移位一致。
 
① SAL 指令（Shift Arithmetic Left，算术左移）
 
- 指令本质：“Shift Arithmetic Left”=算术左移，针对有符号数，操作与SHL完全相同（左移n位，最高位移入CF，最低位补0）；
- 格式： SAL 操作数, 次数 ；
- 等价运算：有符号数×2ⁿ（不溢出前提下）；
- 实例（逐位拆解，AL=30H=00110000B，有符号数+48，CL=1）：
- 指令： SAL AL, 1 ；
- 结果：AL=60H（+96=48×2），CF=0，OF=0；
- 与SHL的区别：语义不同（SAL用于有符号数，SHL用于无符号数），功能完全一致（考试可互换，但需根据数据类型选择）。
 
② SAR 指令（Shift Arithmetic Right，算术右移）
 
- 指令本质：“Shift Arithmetic Right”=算术右移，针对有符号数，操作数右移n位，最低位移入CF，最高位（符号位）保持不变（补符号位）；
- 格式： SAR 操作数, 次数 ；
- 等价运算：有符号数÷2ⁿ（向下取整）；
- 实例（逐位拆解，分正数和负数）：
- 例1（正数，AL=30H=00110000B，+48，CL=1）：
- 移位过程：最低位0→CF=0；最高位（0）保持不变→ 00011000B（18H）；
- 结果：AL=18H（+24=48÷2），CF=0；
- 例2（负数，AL=0D0H=11010000B，-48，CL=1）：
- 移位过程：最低位0→CF=0；最高位（1）保持不变→ 11101000B（0E8H）；
- 结果：AL=0E8H（-24=-48÷2），CF=0；
- 与SHR的核心区别（考试必考）：
- SHR（逻辑右移）：最高位补0（不考虑符号）；
- SAR（算术右移）：最高位补符号位（保持正负不变）；
- 实例对比（AL=0F0H=11110000B）：
-  SHR AL, 1  → 078H（无符号120，最高位补0）；
-  SAR AL, 1  → 0F8H（有符号-8，最高位补1）。
 
（4）循环移位（Rotate Shift，带进位/不带进位，4条）
 
循环移位的核心是“移出的位重新填入空位”，分为不带进位（ROL/ROR）和带进位（RCL/RCR）两类。
 
① ROL 指令（Rotate Left，不带进位左循环）
 
- 指令本质：“Rotate Left”=左循环，操作数左移n位，最高位移出后，同时填入最低位和CF（无进位参与循环，仅操作数内部循环）；
- 格式： ROL 操作数, 次数 ；
- 实例（逐位拆解，AL=0AH=00001010B，CL=1）：
- 移位过程：最高位0→移出→ 填入最低位和CF→ 00010100B（14H）；
- 结果：AL=14H，CF=0；
- 若CL=8（循环8位）→ AL=0AH（回到原值），CF=0（移出位为0）。
 
② ROR 指令（Rotate Right，不带进位右循环）
 
- 指令本质：“Rotate Right”=右循环，操作数右移n位，最低位移出后，同时填入最高位和CF；
- 格式： ROR 操作数, 次数 ；
- 实例（逐位拆解，AL=0AH=00001010B，CL=1）：
- 移位过程：最低位0→移出→ 填入最高位和CF→ 00000101B（05H）；
- 结果：AL=05H，CF=0。
 
③ RCL 指令（Rotate Left Through Carry，带进位左循环）
 
- 指令本质：“Rotate Left Through Carry”=带进位左循环，操作数左移n位，最高位移出后填入CF，CF原有的值填入最低位（操作数+CF组成循环）；
- 格式： RCL 操作数, 次数 ；
- 实例（逐位拆解，AL=0AH=00001010B，CF=1，CL=1）：
- 移位过程：最高位0→移出→ CF=0；CF原有值1→ 填入最低位→ 00010101B（15H）；
- 结果：AL=15H，CF=0。
 
④ RCR 指令（Rotate Right Through Carry，带进位右循环）
 
- 指令本质：“Rotate Right Through Carry”=带进位右循环，操作数右移n位，最低位移出后填入CF，CF原有的值填入最高位；
- 格式： RCR 操作数, 次数 ；
- 实例（逐位拆解，AL=0AH=00001010B，CF=1，CL=1）：
- 移位过程：最低位0→移出→ CF=0；CF原有值1→ 填入最高位→ 10000101B（85H）；
- 结果：AL=85H，CF=0。
 
（5）移位指令考试重点（逐点解释）
 
- 重点1：移位次数>1时必须用CL（如 SHL AX, 3  错误， MOV CL,3；SHL AX,CL  正确）；
- 重点2：逻辑移位vs算术移位（SHR/SHL用于无符号数，SAR/SAL用于有符号数）；
- 重点3：循环移位的进位参与（RCL/RCR带CF循环，ROL/ROR不带）；
- 重点4：标志位影响（CF必受影响，OF仅次数=1时有效）。
 
二、控制转移指令（Control Transfer Instructions，改变程序流程）
 
控制转移指令通过修改「CS:EIP」（指令指针）改变程序执行顺序，核心是“跳转、循环、子程序调用”，是分支、循环、子程序设计的基础，需逐指令、逐格式、逐逻辑拆解。
 
1. JMP 指令（Unconditional Jump，无条件转移指令）
 
- 指令本质：“Jump”=跳转，无论标志位状态，强制转移到指定地址执行（“无条件”=不依赖任何条件，直接跳转）；
- 核心功能：修改EIP（段内转移）或CS+EIP（段间转移），改变程序执行流程；
- 分类（同寻址方式中的“与转移地址有关的寻址”，段间间接不考）：
 
（1）段内直接短转移（JMP SHORT LABEL）
 
- 格式拆解：
- JMP：无条件转移指令；
- SHORT：短转移关键字（“SHORT”=短距离，偏移量范围±127字节）；
- LABEL：当前代码段内的标号（转移目标地址的别名）；
- 底层逻辑：
- 偏移量=LABEL的偏移地址 - 当前EIP的值（当前EIP是JMP指令的下一条指令地址）；
- 偏移量用8位二进制表示（范围-128~+127，对应±127字节）；
- EIP=EIP + 偏移量（仅修改EIP，CS不变）；
- 实例（逐地址拆解，CS=2000H，当前EIP=0008H，LABEL的偏移地址=0010H）：
- 偏移量=0010H - 0008H=0008H（+8字节，在±127范围内）；
- EIP=0008H + 0008H=0010H；
- 转移地址=CS:EIP=2000H:0010H=20010H；
- 特点：指令长度2字节（节省内存），适用于短距离跳转。
 
（2）段内直接近转移（JMP NEAR PTR LABEL）
 
- 格式拆解：
- NEAR PTR：近转移关键字（“NEAR”=近距离，偏移量范围±32767字节）；
- LABEL：当前代码段内的标号；
- 底层逻辑：
- 偏移量用16位二进制表示（范围-32768~+32767，对应±32767字节）；
- EIP=EIP + 偏移量（CS不变）；
- 实例：CS=2000H，当前EIP=0008H，LABEL的偏移地址=1000H→ 偏移量=1000H-0008H=0FF8H→ EIP=0008H+0FF8H=1000H→ 转移地址=2000H:1000H=21000H；
- 特点：指令长度3字节，适用于同一段内中长距离跳转。
 
（3）段内间接转移（JMP 寄存器 / JMP [内存]）
 
- 格式拆解：
- JMP 寄存器：转移地址存放在通用寄存器中（如BX、EAX）；
- JMP [内存]：转移地址存放在内存单元中（如[SI]、[BX+10H]）；
- 底层逻辑：
- 从寄存器/内存中取出偏移地址，送入EIP（CS不变）；
- 实例（逐步拆解）：
- 例1（寄存器间接）： MOV BX, 1234H；JMP BX （CS=2000H）；
- 执行：EIP=BX的值=1234H；
- 转移地址=2000H:1234H=21234H；
- 例2（内存间接）： MOV SI, 0000H；JMP [SI] （DS=3000H，内存30000H=5678H）；
- 执行：从内存30000H取出偏移地址=5678H，EIP=5678H；
- 转移地址=CS:5678H；
- 特点：转移地址动态可变（由程序运行时的数据决定），适用于灵活跳转（如根据用户输入跳转）。
 
（4）段间直接转移（JMP FAR PTR LABEL）
 
- 格式拆解：
- FAR PTR：远转移关键字（“FAR”=远距离，跨段转移）；
- LABEL：其他代码段的标号（包含段地址和偏移地址）；
- 底层逻辑：
- 从LABEL中提取段地址→ 送入CS；
- 提取偏移地址→ 送入EIP；
- 同时修改CS和EIP，实现跨段跳转；
- 实例：LABEL的段地址=4000H，偏移地址=0000H→ CS=4000H，EIP=0000H→ 转移地址=4000H:0000H=40000H；
- 特点：指令长度5字节，适用于跨段跳转（如从代码段CODE1跳到CODE2）。
 
（5）考试重点
 
- 段内转移仅修改EIP，段间转移修改CS+EIP；
- SHORT偏移量范围±127字节，NEAR±32767字节；
- 段内间接转移的寄存器只能是通用寄存器（如BX、EAX），不能是段寄存器。
 汇编语言复习PPT（逐字逐词极致细致讲解·续）
- 指令本质：“Conditional Jump”=条件跳转，根据「前一条指令修改的标志位」决定是否转移（条件满足则跳转，否则顺序执行）；

- 核心依赖：标志位（CF/ZF/SF/OF），前一条指令通常是CMP（比较）、ADD（加法）、SUB（减法）等影响标志位的指令；

- 核心考点：有符号数与无符号数的条件转移指令区分（考试高频，避免混淆）。
 
（1）无符号数条件转移指令（针对无符号数比较，如CMP AX,BX）
 
表格
   

指令 英文全称 中文含义 标志位判断条件（逐字解释） 实例（AX和BX为无符号数） 
JA Jump Above 高于（AX > BX） CF=0（无借位，AX≥BX） 且 ZF=0（AX≠BX）→ AX > BX  CMP AX,BX；JA LABEL （AX>BX则跳转） 
JB Jump Below 低于（AX < BX） CF=1（有借位，AX < BX） 且 ZF=0（AX≠BX）→ AX < BX  CMP AX,BX；JB LABEL （AX<BX则跳转） 
JAE Jump Above or Equal 高于或等于（AX ≥ BX） CF=0（无借位，AX≥BX）→ 无论ZF是否为1  CMP AX,BX；JAE LABEL （AX≥BX则跳转） 
JBE Jump Below or Equal 低于或等于（AX ≤ BX） CF=1（有借位，AX < BX） 或 ZF=1（AX=BX）→ AX ≤ BX  CMP AX,BX；JBE LABEL （AX≤BX则跳转） 
JE Jump Equal 等于（AX = BX） ZF=1（比较结果为0）  CMP AX,BX；JE LABEL （AX=BX则跳转） 
JNE Jump Not Equal 不等于（AX ≠ BX） ZF=0（比较结果不为0）  CMP AX,BX；JNE LABEL （AX≠BX则跳转） 
 
- 记忆口诀：无符号“高JA低JB，等于JE不等JNE”（JA=高于，JB=低于，JE=等于，JNE=不等于）。

2. Jxx 指令（Conditional Jump，条件转移指令，重中之重）
 
（2）有符号数条件转移指令（针对有符号数比较，如CMP AX,BX）
 
指令 英文全称 中文含义 标志位判断条件（逐字解释） 实例（AX和BX为有符号数） 
JGE Jump Greater or Equal 大于或等于（AX ≥ BX） SF=OF（符号位与溢出标志一致，说明无溢出，结果正负正确）→ 无论ZF是否为1（ZF=1表示等于，ZF=0表示大于）  CMP AX,BX；JGE LABEL （AX≥BX则跳转，如AX=30H(+48)，BX=20H(+32)，CMP后SF=0、OF=0，SF=OF→跳转） 
JLE Jump Less or Equal 小于或等于（AX ≤ BX） SF≠OF（符号位与溢出标志不一致，说明有溢出，结果正负异常） 或 ZF=1（AX=BX）→ 满足任一条件即AX ≤ BX  CMP AX,BX；JLE LABEL （AX≤BX则跳转，如AX=80H(-128)，BX=10H(+16)，CMP后SF=1、OF=1，SF=OF但ZF=0？不，AX=-128 < BX=+16，CMP后SF=1、OF=0（有符号数减法-128-16=-144，超出-128~+127，OF=1），SF≠OF→跳转） 
JE Jump Equal 等于（AX = BX） 同无符号数，ZF=1（比较结果为0）  CMP AX,BX；JE LABEL （AX=BX则跳转，与数据类型无关） 
JNE Jump Not Equal 不等于（AX ≠ BX） 同无符号数，ZF=0（比较结果不为0）  CMP AX,BX；JNE LABEL （AX≠BX则跳转，与数据类型无关） 
 
记忆口诀：有符号“大JG小JL，等于JE不等JNE，SF=OF是大于等于（JGE），SF≠OF或ZF=1是小于等于（JLE）”（核心：有符号数需结合SF和OF判断，无符号数结合CF和ZF判断，考试绝不能混淆）。
 
（3）考试易错点（逐点解释原因+规避方法）
 
- 易错点1：混淆有符号/无符号条件转移指令（如用JA判断有符号数“大于”）→ 原因：未区分数据类型，JA/JB针对无符号数/JB针对无符号数（看CF/ZF），JG/JL针对有符号数（看SF/OF/ZF）；规避：先判断数据类型（题目明确“无符号数”用JA/JB，“有符号数”用JG/JL）。
- 易错点2：条件转移指令前未加影响标志位的指令（如直接写 JG LABEL ）→ 原因：Jxx依赖前一条指令的标志位，无前置指令则标志位状态随机，跳转逻辑错误；规避：Jxx前必须加CMP、ADD、SUB等影响标志位的指令（优先CMP，专门用于比较）。
- 易错点3：用JGE判断“大于”（如 CMP AX,BX；JGE LABEL 期望AX>BX）→ 原因：JGE是“大于或等于”（含等于），若需“严格大于”需用JG；规避：严格大于/小于用JG/JL，含等于用JGE/JLE。
 
3. 循环指令（Loop Instructions，重复执行一段程序）
 
循环指令本质是“JMP+计数器自减”，自动完成“计数器减1→判断是否为0→不为0则循环”，核心依赖CX寄存器（循环计数器） 和标志位，适用于固定次数的循环（考试高频应用题）。
 
（1）LOOP 指令（Loop，无条件循环指令）
 
- 指令本质：“Loop”=循环，将CX自减1（CX=CX-1），若CX≠0则转移到标号处循环，若CX=0则顺序执行（“无条件”=仅判断CX是否为0，不依赖其他标志位）；
- 格式： LOOP LABEL （LABEL：循环体的起始标号，必须在当前代码段内）；
- 底层执行步骤（逐步拆解）：
1. CX = CX - 1（计数器自减1，不影响CF标志位，同INC/DEC）；
2. 判断CX是否为0：若CX≠0→ EIP指向LABEL（循环）；若CX=0→ EIP指向LOOP的下一条指令（退出循环）；
- 实例（逐句拆解，实现“循环3次，累加AX的值”）：
asm
  

MOV AX, 0   ; AX初始化为0（累加器）
MOV CX, 3   ; CX=3（循环次数=3次，因为第一次LOOP先减1为2，共执行3次）
LOOP_LABEL: ; 循环体起始标号
ADD AX, 10H ; 每次累加10H（AX=AX+10H）
LOOP LOOP_LABEL ; 循环指令：CX自减1→判断CX≠0则跳回LOOP_LABEL
; 执行过程：
; 第1次：CX=3→减1=2（≠0）→ AX=0+10H=10H→ 循环
; 第2次：CX=2→减1=1（≠0）→ AX=10H+10H=20H→ 循环
; 第3次：CX=1→减1=0（=0）→ AX=20H+10H=30H→ 退出循环
; 最终结果：AX=30H，CX=0
 
- 考试重点：循环次数=CX初始值（如CX=5→循环5次），因为每次LOOP先减1再判断，初始值为n则执行n次；
- 易错点： LOOP 前未给CX赋值（CX为随机值，可能导致死循环）→ 规避：循环前必须用 MOV CX, n 定义循环次数。
 
（2）LOOPE / LOOPZ 指令（Loop if Equal / Loop if Zero，相等/零循环指令）
 
- 指令本质：“LOOPE”=Equal（相等时循环），“LOOPZ”=Zero（零循环），两者功能完全一致（指令助记符可互换）；
- 核心逻辑：CX自减1→ 若CX≠0 且 ZF=1（前一条指令结果为0/相等），则循环；否则退出；
- 格式： LOOPE LABEL  或  LOOPZ LABEL ；
- 实例（逐句拆解，实现“查找字符串中第一个非0字符，最多查找5次”）：
asm
  

MOV SI, 0000H ; SI=字符串起始偏移地址（DS:SI指向字符串）
MOV CX, 5     ; 最多查找5次
LOOP_LABEL:
MOV AL, [SI]  ; 取当前字符到AL
CMP AL, 0     ; 比较字符是否为0（影响ZF：AL=0则ZF=1，否则ZF=0）
LOOPE LOOP_LABEL ; CX自减1→ CX≠0且ZF=1→ 循环（继续查找）
; 执行逻辑：
; 若[SI]=0→ ZF=1，CX减1后≠0→ 跳回查找下一个字符（SI需手动自增：ADD SI,1）
; 若[SI]≠0→ ZF=0→ 退出循环（找到非0字符）
; 若CX减1后=0→ 退出循环（查找5次未找到）
 
- 关键区别（与LOOP对比）：LOOP仅判断CX≠0，LOOPE需同时满足“CX≠0且ZF=1”；
- 考试重点：适用于“相等/为0时继续循环”的场景（如查找相等元素、判断字符串结束）。
 
（3）LOOPNE / LOOPNZ 指令（Loop if Not Equal / Loop if Not Zero，不相等/非零循环指令）
 
- 指令本质：“LOOPNE”=Not Equal（不相等时循环），“LOOPNZ”=Not Zero（非零循环），两者功能完全一致；
- 核心逻辑：CX自减1→ 若CX≠0 且 ZF=0（前一条指令结果不为0/不相等），则循环；否则退出；
- 格式： LOOPNE LABEL  或  LOOPNZ LABEL ；
- 实例（逐句拆解，实现“查找字符串中第一个0字符，最多查找5次”）：
asm
  

MOV SI, 0000H ; SI=字符串起始偏移地址
MOV CX, 5     ; 最多查找5次
LOOP_LABEL:
MOV AL, [SI]  ; 取当前字符到AL
CMP AL, 0     ; 比较是否为0（AL=0→ZF=1，否则ZF=0）
LOOPNE LOOP_LABEL ; CX自减1→ CX≠0且ZF=0→ 循环（继续查找）
; 执行逻辑：
; 若[SI]≠0→ ZF=0，CX减1后≠0→ 跳回查找下一个（ADD SI,1）
; 若[SI]=0→ ZF=1→ 退出循环（找到0字符）
; 若CX=0→ 退出循环（未找到）
 
- 考试重点：适用于“不相等/非0时继续循环”的场景（如查找不同元素、跳过非0数据）；
- 记忆口诀：LOOP无条件（仅看CX），LOOPE相等循环（CX≠0+ZF=1），LOOPNE不等循环（CX≠0+ZF=0）。
 
4. 子程序调用与返回指令（Call/Return，模块化编程核心）
 
子程序（Subroutine）是程序中可重复调用的代码段（如“加法函数”“打印函数”），通过 CALL 调用子程序， RET 返回主程序，核心是“保存返回地址”和“恢复返回地址”（依赖堆栈）。
 
（1）CALL 指令（Call Subroutine，子程序调用指令）
 
- 指令本质：“Call”=调用，暂停当前程序执行，跳转到子程序地址；同时将“返回地址”（当前CALL指令的下一条指令地址）压入堆栈（以便返回时使用）；
- 核心功能：① 保存返回地址（CS:EIP）到堆栈；② 修改CS:EIP，跳转到子程序；
- 分类（同JMP，分段内/段间，段间间接不考）：
 
① 段内直接调用（CALL NEAR PTR LABEL）
 
- 格式拆解：
- NEAR PTR：近调用（默认，可省略），子程序与主程序在同一代码段（仅修改EIP）；
- LABEL：子程序的起始标号（当前代码段内）；
- 底层执行步骤（逐步拆解，CS=2000H，当前EIP=0010H（CALL指令地址），子程序LABEL偏移地址=0050H）：
1. 计算返回地址：返回地址=当前EIP + CALL指令长度（NEAR CALL长度3字节）= 0010H + 3 = 0013H；
2. 保存返回地址到堆栈： PUSH EIP （EIP=0013H，32位模式下压栈4字节，ESP=ESP-4，栈顶存储0013H）；
3. 跳转子程序：EIP=LABEL偏移地址=0050H（CS不变=2000H）；
4. 转移地址=CS:EIP=2000H:0050H=20050H（开始执行子程序）；
- 特点：仅压入EIP（返回地址的偏移量），适合同一段内子程序调用（最常用）。
 
② 段内间接调用（CALL 寄存器 / CALL [内存]）
 
- 格式： CALL BX （返回地址的偏移量存于BX）、 CALL [SI] （返回地址的偏移量存于内存DS:SI）；
- 底层执行步骤（以 CALL BX 为例，BX=0060H，CS=2000H，当前EIP=0010H）：
1. 计算返回地址=0010H + 3 = 0013H；
2. 压栈返回地址： PUSH EIP （ESP=ESP-4，栈顶=0013H）；
3. 跳转子程序：EIP=BX=0060H；
4. 转移地址=2000H:0060H=20060H；
- 特点：返回地址动态可变（由寄存器/内存数据决定），适用于动态调用（如根据用户输入调用不同子程序）。
 
③ 段间直接调用（CALL FAR PTR LABEL）
 
- 格式拆解：
- FAR PTR：远调用，子程序与主程序在不同代码段（需同时修改CS和EIP）；
- LABEL：子程序标号（含段地址和偏移地址）；
- 底层执行步骤（LABEL段地址=3000H，偏移地址=0000H，当前CS=2000H，EIP=0010H）：
1. 计算返回地址=0010H + 5（FAR CALL长度5字节）= 0015H；
2. 保存返回地址到堆栈（先压CS，再压EIP，栈遵循“先进后出”）：
-  PUSH CS （CS=2000H，ESP=ESP-4，栈顶=2000H）；
-  PUSH EIP （EIP=0015H，ESP=ESP-4，栈顶=0015H）；
3. 跳转子程序：CS=LABEL段地址=3000H，EIP=LABEL偏移地址=0000H；
4. 转移地址=3000H:0000H=30000H；
- 特点：压入CS和EIP（完整返回地址），适用于跨段调用；
- 考试重点：段内调用压入1个值（EIP），段间调用压入2个值（CS→EIP），堆栈弹出顺序与压入相反。
 
（2）RET 指令（Return，子程序返回指令）
 
- 指令本质：“Return”=返回，从堆栈中弹出“返回地址”，送入EIP（段内返回）或CS+EIP（段间返回），恢复主程序执行；
- 核心功能：弹出堆栈中的返回地址，修改CS:EIP，回到主程序的下一条指令；
- 分类：
 
① 段内返回（RET）
 
- 格式： RET （默认，与段内CALL对应）；
- 底层执行步骤（承接段内直接调用实例，栈顶存储返回地址0013H，ESP=00000FFCH）：
1. 弹出返回地址： POP EIP （从栈顶00000FFCH取出0013H，送入EIP；ESP=ESP+4=00001000H）；
2. 恢复主程序：EIP=0013H，CS=2000H→ 主程序从0013H开始执行；
- 特点：仅弹出EIP，堆栈减少4字节（32位模式）。
 
② 段间返回（RETF）
 
- 格式： RETF （与段间FAR CALL对应）；
- 底层执行步骤（承接段间直接调用实例，栈顶依次存储0015H（EIP）、2000H（CS），ESP=00000FF8H）：
1. 弹出EIP： POP EIP （取出栈顶0015H→EIP；ESP=00000FFCH）；
2. 弹出CS： POP CS （取出栈顶2000H→CS；ESP=00001000H）；
3. 恢复主程序：CS=2000H，EIP=0015H→ 主程序从0015H开始执行；
- 特点：弹出EIP和CS（先弹EIP，再弹CS，与压入顺序相反），堆栈减少8字节；
- 考试易错点： RET 与 RETF 不能混用（段内CALL用RET，段间FAR CALL用RETF），否则弹出错误地址，导致程序崩溃。
 
③ 带立即数的返回指令（RET n，n为立即数）
 
- 格式： RET 2 、 RET 4 （n为偶数，32位模式下n通常为4的倍数）；
- 指令本质：执行 RET 后，额外执行 ADD ESP, n （调整堆栈指针，释放子程序调用时压入的参数）；
- 用途：子程序调用时若通过堆栈传递参数（如 PUSH AX 传递参数给子程序），返回时需释放参数占用的堆栈空间；
- 实例（逐步拆解，子程序调用时压入1个参数，n=4）：
asm
  

; 主程序：传递参数AX=10H给子程序
MOV AX, 10H
PUSH AX       ; 压入参数，ESP=ESP-4（参数占4字节）
CALL SUB1     ; 段内调用子程序（压入返回地址EIP，ESP=ESP-4）
; 子程序SUB1：执行完成后返回，释放参数空间
SUB1:
; 子程序逻辑（使用参数[ESP+4]，因为ESP当前指向返回地址，参数在返回地址下方4字节）
MOV BX, [ESP+4] ; BX=10H（取出参数）
RET 4         ; 1. 弹出EIP（返回主程序）；2. ADD ESP,4（释放参数占用的4字节，ESP恢复到压入参数前的值）
 
- 考试重点：n的值=参数占用的堆栈字节数（如传递2个双字参数，n=8），目的是保持堆栈平衡。
 
（3）考试重点总结
 
- 调用与返回的对应关系：段内CALL ↔ RET，段间FAR CALL ↔ RETF；
- 堆栈操作顺序：CALL压入返回地址（段间先CS后EIP），RET弹出返回地址（段间先EIP后CS）；
- RET n的作用：释放堆栈参数，n=参数总字节数（必须为偶数，32位下为4的倍数）。
 
三、串操作指令（String Instructions，批量处理数据）
 
串操作指令是「对连续的内存数据（串）进行批量操作」（如复制、比较、查找），一次操作1字节（BYTE）、1字（WORD）或1双字（DWORD），可配合重复前缀实现“自动循环操作”，核心是“固定寄存器搭配”和“方向标志DF”。
 
1. 串操作的核心前提（所有串指令通用，考试必考）
 
（1）固定寄存器搭配（CPU硬件设计，不可修改）
 
串操作类型 源串地址寄存器（提供数据） 目的串地址寄存器（接收数据） 串长度寄存器（循环次数） 
所有串指令 DS:SI（DS=源串段地址，SI=源串偏移地址） ES:DI（ES=目的串段地址，DI=目的串偏移地址） CX（存储串长度，循环次数=CX值） 
 
- 说明：
- 源串默认在数据段（DS），若需修改源串段地址，需用段超越前缀（如 MOVS BYTE PTR ES:[DI], CS:[SI] ，指定源串在代码段CS）；
- 目的串必须在附加段（ES），不能用段超越前缀修改（CPU硬件限制）；
- 32位模式下，SI/EI可替换为ESI/EDI（32位寄存器，偏移地址范围更大），CX可替换为ECX。
 
（2）方向标志DF（Direction Flag，控制串操作地址递增/递减）
 
- DF是FLAGS寄存器的第10位（bit10），仅影响串操作指令中SI/DI的变化方向：
- DF=0（默认）：地址递增（SI=SI+n，DI=DI+n，n=操作数长度：字节n=1，字n=2，双字n=4）→ 从串的起始地址向末尾操作（正向处理）；
- DF=1：地址递减（SI=SI-n，DI=DI-n）→ 从串的末尾地址向起始操作（反向处理）；
- 控制DF的指令（2条，无操作数）：
-  CLD （Clear Direction Flag）：清方向标志，DF=0（正向操作，最常用）；
-  STD （Set Direction Flag）：置方向标志，DF=1（反向操作）；
- 考试重点：串操作前必须明确DF的值（默认DF=0，若需反向需先执行 STD ），否则SI/DI方向错误，导致操作数据错误。
 
（3）重复前缀（Repeat Prefix，实现串操作自动循环）
 
重复前缀不能单独使用，必须紧跟在串指令前，作用是“自动循环执行串指令，直到CX=0或满足指定条件”，核心是“减少循环代码编写”（替代LOOP指令）。
 
重复前缀 英文全称 循环条件（逐字解释） 适用串指令 核心用途 
REP Repeat 每次执行串指令后，CX=CX-1→ 若CX≠0，继续循环；否则退出 MOVS、STOS、LODS 无条件重复（适用于“复制串、存储串、读取串”，需执行CX次） 
REPE Repeat if Equal 每次执行串指令后，CX=CX-1→ 若CX≠0 且 ZF=1（相等/为0），继续循环；否则退出 CMPS、SCAS 相等时重复（适用于“查找第一个不相等的字符、比较两串是否完全相等”） 
REPNE Repeat if Not Equal 每次执行串指令后，CX=CX-1→ 若CX≠0 且 ZF=0（不相等/非0），继续循环；否则退出 CMPS、SCAS 不相等时重复（适用于“查找第一个相等的字符、比较两串是否不完全相等”） 
 
- 记忆口诀：REP无条件（仅看CX），REPE相等循环（CX≠0+ZF=1），REPNE不等循环（CX≠0+ZF=0）（同循环指令逻辑一致）。
 
2. 5条核心串指令（逐指令拆解，含重复前缀用法）
 
（1）MOVS 指令（Move String，串传送指令，最常用）
 
- 指令本质：“Move String”=串传送，将源串（DS:SI）的一个数据（字节/字/双字）复制到目的串（ES:DI），同时根据DF自动修改SI和DI（递增/递减）；
- 核心功能：批量复制内存数据（如将字符串从一个内存区域复制到另一个区域）；
- 格式（需指定操作数长度，避免类型不匹配）：
- 字节串传送： MOVS BYTE PTR ES:[DI], BYTE PTR DS:[SI] （可简写为 MOVSB ，B=Byte）；
- 字串传送： MOVS WORD PTR ES:[DI], WORD PTR DS:[SI] （简写为 MOVSW ，W=Word）；
- 双字串传送： MOVS DWORD PTR ES:[DI], DWORD PTR DS:[SI] （简写为 MOVSD ，D=Double Word）；
- 底层执行步骤（以 MOVSB 为例，DF=0，SI=0000H，DI=0010H，CX=3，DS=2000H，ES=3000H）：
1. 复制字节：将DS:SI（2000H:0000H）的字节数据→ 送入ES:DI（3000H:0010H）；
2. 修改地址（DF=0，递增）：SI=0000H+1=0001H，DI=0010H+1=0011H；
3. 循环控制（若加重复前缀 REP ）：CX=3-1=2→ CX≠0→ 重复步骤1-2；
4. 循环结束：CX=0→ 停止复制；
- 实例（完整代码，复制3个字节的串，正向操作）：
asm
  

; 定义源串和目的串（数据段）
DATA SEGMENT
SOURCE DB 11H, 22H, 33H ; 源串：3个字节，偏移地址0000H
DEST DB 3 DUP(0)        ; 目的串：3个字节，初始为0，偏移地址0003H
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, ES:DATA ; 让ES指向数据段（目的串在数据段）
START:
MOV AX, DATA
MOV DS, AX       ; 初始化DS（源串段地址）
MOV ES, AX       ; 初始化ES（目的串段地址，必须与DS一致，因为目的串在数据段）
MOV SI, OFFSET SOURCE ; SI=源串偏移地址=0000H
MOV DI, OFFSET DEST   ; DI=目的串偏移地址=0003H
MOV CX, 3         ; CX=3（串长度=3，复制3次）
CLD              ; 清DF=0（正向操作，SI/DI递增）
REP MOVSB        ; 重复执行MOVSB，直到CX=0（复制3个字节）
; 执行结果：DEST = 11H, 22H, 33H（与SOURCE完全一致）
; 退出程序
MOV AH, 4CH
INT 21H
CODE ENDS
END START
 
- 考试重点：
- 必须初始化DS和ES（目的串在ES段，若与源串同段，需将ES赋值为DS）；
- 必须指定操作数长度（用MOVSB/MOVSW/MOVSD，或显式写BYTE PTR）；
- REP MOVSB是“无条件复制CX次”，适用于完整复制串。
 
（2）CMPS 指令（Compare String，串比较指令）
 
- 指令本质：“Compare String”=串比较，将源串（DS:SI）的一个数据与目的串（ES:DI）的对应数据执行 CMP 操作（相减，不保存结果，仅修改标志位），同时根据DF修改SI和DI；
- 核心功能：批量比较两串是否相等，或查找两串中第一个不相等的字符；
- 格式（指定操作数长度）：
- 字节串比较： CMPS BYTE PTR DS:[SI], BYTE PTR ES:[DI] （简写 CMPSB ）；
- 字串比较： CMPS WORD PTR DS:[SI], WORD PTR ES:[DI] （简写 CMPSW ）；
- 双字串比较： CMPS DWORD PTR DS:[SI], DWORD PTR ES:[DI] （简写 CMPSD ）；
- 底层执行逻辑： CMP 源串数据, 目的串数据 → 修改标志位（ZF=1表示相等，ZF=0表示不相等）→ 根据DF修改SI/DI→ 若加重复前缀，判断循环条件；
- 实例（完整代码，比较两串是否完全相等，最多比较3次）：
asm
  

DATA SEGMENT
STR1 DB 11H, 22H, 33H ; 串1：3个字节
STR2 DB 11H, 23H, 33H ; 串2：3个字节（第2个字节与STR1不同）
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, ES:DATA
START:
MOV AX, DATA
MOV DS, AX
MOV ES, AX
MOV SI, OFFSET STR1   ; SI=STR1偏移地址=0000H
MOV DI, OFFSET STR2   ; DI=STR2偏移地址=0003H
MOV CX, 3             ; CX=3（最多比较3次）
CLD                   ; DF=0（正向操作）
REPE CMPSB            ; 重复比较：CX≠0且ZF=1（相等）→ 继续比较
; 循环退出条件：1. CX=0（两串完全相等）；2. ZF=0（找到不相等的字符）
JZ EQUAL              ; 若ZF=1→ 两串相等，跳至EQUAL
; 若ZF=0→ 两串不相等，输出提示（此处省略输出代码）
JMP EXIT
EQUAL:
; 两串相等，输出提示（此处省略输出代码）
EXIT:
MOV AH, 4CH
INT 21H
CODE ENDS
END START
; 执行过程：
; 第1次比较：STR1[0]=11H vs STR2[0]=11H→ ZF=1，CX=2，SI=1，DI=4；
; 第2次比较：STR1[1]=22H vs STR2[1]=23H→ ZF=0，CX=1，SI=2，DI=5；
; 循环退出（ZF=0）→ 跳至EXIT，判断两串不相等。
 
- 考试重点：
- REPE CMPSB：相等时继续比较，退出时要么CX=0（完全相等），要么ZF=0（第一个不相等）；
- REPNE CMPSB：不相等时继续比较，退出时要么CX=0（完全不相等），要么ZF=1（第一个相等）；
- 比较后需用JZ/JNZ判断结果（ZF=1相等，ZF=0不相等）。
 
（3）SCAS 指令（Scan String，串扫描指令）
 
- 指令本质：“Scan String”=串扫描，将累加器（AL/AX/EAX）中的数据与目的串（ES:DI）的一个数据执行 CMP 操作（相减，修改标志位），同时根据DF修改DI；
- 核心功能：在一串数据中查找指定值（如查找字符串中是否包含字符'A'）；
- 格式（指定操作数长度，累加器与操作数长度匹配）：
- 字节串扫描： SCAS BYTE PTR ES:[DI] （简写 SCASB ，用AL存储查找值）；
- 字串扫描： SCAS WORD PTR ES:[DI] （简写 SCASW ，用AX存储查找值）；
- 双字串扫描： SCAS DWORD PTR ES:[DI] （简写 SCASD ，用EAX存储查找值）；
- 底层执行逻辑： CMP AL/AX/EAX, 目的串数据 → 修改标志位（ZF=1表示找到，ZF=0表示未找到）→ 根据DF修改DI→ 若加重复前缀，判断循环条件；
- 实例（完整代码，在3个字节的串中查找02H，正向查找）：
asm
  

DATA SEGMENT
STR DB 01H, 02H, 03H ; 待扫描串：3个字节，偏移地址0000H
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, ES:DATA
START:
MOV AX, DATA
MOV DS, AX
MOV ES, AX
MOV DI, OFFSET STR   ; DI=串偏移地址=0000H
MOV AL, 02H          ; AL=查找值=02H（字节型，与串长度匹配）
MOV CX, 3            ; CX=3（最多查找3次）
CLD                  ; DF=0（正向查找）
REPNE SCASB          ; 重复扫描：CX≠0且ZF=0（未找到）→ 继续查找
; 循环退出条件：1. CX=0（未找到）；2. ZF=1（找到）
JZ FOUND             ; ZF=1→ 找到，跳至FOUND
; 未找到，输出提示
JMP EXIT
FOUND:
; 找到，计算查找位置：位置=初始DI + （初始CX - 剩余CX） - 1（因为找到后DI已递增）
; 初始DI=0，初始CX=3，剩余CX=3-2=1（找到时CX=1）→ 位置=0 + (3-1) -1=1（正确，02H在第2个位置，0-based）
EXIT:
MOV AH, 4CH
INT 21H
CODE ENDS
END START
; 执行过程：
; 第1次扫描：AL=02H vs STR[0]=01H→ ZF=0，CX=2，DI=1；
; 第2次扫描：AL=02H vs STR[1]=02H→ ZF=1，CX=1，DI=2；
; 循环退出（ZF=1）→ 跳至FOUND，确认找到。
 
- 考试重点：
- 查找值必须存入累加器（AL/AX/EAX），且与串长度匹配（字节串用AL，字串用AX）；
- REPNE SCASB：未找到时继续扫描，退出时ZF=1表示找到，ZF=0表示未找到；
- 查找位置计算： 查找位置 = 初始DI + (初始CX - 剩余CX) - 1 （因为找到后DI已自动递增/递减，需回退1位）。
 
（4）LODS 指令（Load String，串装入指令）
 
- 指令本质：“Load String”=串装入，将源串（DS:SI）的一个数据读取到累加器（AL/AX/EAX），同时根据DF修改SI；
- 核心功能：批量读取串数据到累加器（如逐个读取字符串的每个字符，进行处理）；
- 格式（指定操作数长度）：
- 字节串装入： LODS BYTE PTR DS:[SI] （简写 LODSB ，装入AL）；
- 字串装入： LODS WORD PTR DS:[SI] （简写 LODSW ，装入AX）；
- 双字串装入： LODS DWORD PTR DS:[SI] （简写 LODSD ，装入EAX）；
- 实例（完整代码，读取3个字节的串，逐个存入BL、BH、CL）：
asm
  

DATA SEGMENT
STR DB 11H, 22H, 33H ; 待读取串：3个字节
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA
START:
MOV AX, DATA
MOV DS, AX
MOV SI, OFFSET STR   ; SI=串偏移地址=0000H
MOV CX, 3            ; CX=3（读取3次）
CLD                  ; DF=0（正向读取，SI递增）
; 第1次读取：装入AL→ BL
LODSB                ; AL=STR[0]=11H，SI=0+1=1
MOV BL, AL           ; BL=11H
; 第2次读取：装入AL→ BH
LODSB                ; AL=STR[1]=22H，SI=1+1=2
MOV BH, AL           ; BH=22H
; 第3次读取：装入AL→ CL
LODSB                ; AL=STR[2]=33H，SI=2+1=3
MOV CL, AL           ; CL=33H
; 执行结果：BL=11H，BH=22H，CL=33H
EXIT:
MOV AH, 4CH
INT 21H
CODE ENDS
END START
 
- 考试重点：
- 数据装入累加器（AL/AX/EAX），不修改其他寄存器（除SI）；
- 通常不与REP前缀连用（因为REP会连续装入，最终累加器仅保留最后一个数据），多用于循环中逐个处理数据。
 
（5）STOS 指令（Store String，串存储指令）
 
- 指令本质：“Store String”=串存储，将累加器（AL/AX/EAX）中的数据写入到目的串（ES:DI），同时根据DF修改DI；
- 核心功能：批量将累加器的数据写入串（如将处理后的字符逐个存入内存）；
- 格式（指定操作数长度）：
- 字节串存储： STOS BYTE PTR ES:[DI] （简写 STOSB ，从AL写入）；
- 字串存储： STOS WORD PTR ES:[DI] （简写 STOSW ，从AX写入）；
- 双字串存储： STOS DWORD PTR ES:[DI] （简写 STOSD ，从EAX写入）；
- 实例（完整代码，将AL中的0AH重复写入3个字节的串，用REP前缀自动循环）：
asm
  

DATA SEGMENT
BUF DB 3 DUP(0)      ; 待写入串：3个字节，初始为0
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, ES:DATA
START:
MOV AX, DATA
MOV DS, AX
MOV ES, AX
MOV DI, OFFSET BUF   ; DI=串偏移地址=0000H
MOV AL, 0AH          ; AL=写入值=0AH（字节型）
MOV CX, 3            ; CX=3（写入3次）
CLD                  ; DF=0（正向写入，DI递增）
REP STOSB            ; 重复执行STOSB，直到CX=0（写入3次）
; 执行结果：BUF = 0AH, 0AH, 0AH（3个字节均为0AH）
EXIT:
MOV AH, 4CH
INT 21H
CODE ENDS
END START
 
- 考试重点：
- 数据从累加器写入目的串（ES:DI），必须初始化ES；
- REP STOSB是“无条件写入CX次”，适用于将同一数据填充到串中（如清空缓冲区、初始化数组）。
 
3. 串操作指令考试总结（高频考点）
 
指令 核心功能 累加器 重复前缀推荐 关键注意事项 
MOVS 复制串 无 REP 初始化DS/ES/SI/DI/CX，指定长度 
CMPS 比较串 无 REPE/REPNE 比较后用JZ/JNZ判断结果 
SCAS 扫描串（查找） AL/AX/EAX REPNE 查找值存入累加器，计算位置需回退1 
LODS 装入串（读取） AL/AX/EAX 一般不用REP 逐个读取，累加器存当前数据 
STOS 存储串（写入） AL/AX/EAX REP 初始化ES/DI/CX，同一数据填充串 
 
- 口诀：“MOVS复制REP用，CMPS比较看ZF，SCPS比较看ZF，SCAS查找AL装，LODS读取STOS写”；
- 必记前提：DS:SI源串，ES:DI目的串，CX长度，DF控方向（CLD=0正向，STD=1反向）。
 
第7页：汇编语言程序设计（逐字逐词拆解）
 
一、程序设计的核心结构（3种基础结构，考试应用题必考）
 
汇编语言程序的核心结构与高级语言一致（顺序、分支、循环），所有复杂程序均由这3种结构组合而成，需掌握“每类结构的代码模板+逻辑实现+调试技巧”。
 
1. 顺序结构（Sequential Structure）
 
- 结构本质：“顺序执行”，程序从第一条指令开始，依次执行每一条指令，无跳转、无循环（最简单的结构，是分支/循环的基础）；
- 核心特点：指令执行顺序与代码编写顺序一致，无标志位判断，无控制转移指令；
- 典型场景：数据初始化、简单运算、单步数据处理；
- 完整实例（逐句拆解，实现“将AX=10H，BX=20H相加，结果存入CX”）：
asm
  

CODE SEGMENT
ASSUME CS:CODE
START:
; 顺序执行步骤1：初始化数据
MOV AX, 10H    ; 第1条：AX=10H（赋值）
MOV BX, 20H    ; 第2条：BX=20H（赋值）
; 顺序执行步骤2：简单运算
ADD AX, BX     ; 第3条：AX=10H+20H=30H（加法）
; 顺序执行步骤3：存储结果
MOV CX, AX     ; 第4条：CX=30H（结果存入CX）
; 顺序执行步骤4：退出程序（固定模板）
MOV AH, 4CH    ; 第5条：功能号4CH（程序退出）
INT 21H        ; 第6条：调用DOS中断，退出程序
CODE ENDS
END START
 
- 考试重点：
- 程序退出必须用 MOV AH, 4CH；INT 21H （DOS中断调用，固定模板，少写则程序无法正常退出）；
- 顺序结构的代码无JMP、Jxx、LOOP等控制转移指令，仅含数据传送、算术运算等指令；
- 数据初始化需明确寄存器/内存的值（避免随机值导致结果错误）。
 
2. 分支结构（Branching Structure）
 
- 结构本质：“条件判断+分支跳转”，根据某一条件（标志位状态）决定执行哪一段代码（二分支/多分支）；
- 核心依赖： CMP 指令（修改标志位）+  Jxx 条件转移指令（判断标志位并跳转）；
- 分类：二分支结构（if-else）、多分支结构（if-else if-else/switch-case）。
 
（1）二分支结构（if-else，最常用）
 
- 代码模板（通用，逐句解释）：
asm
  

; 步骤1：准备数据，执行比较指令（修改标志位）
MOV 寄存器1, 数值1
MOV 寄存器2, 数值2
CMP 寄存器1, 寄存器2 ; 比较两个数值，修改标志位（ZF/CF/SF/OF）
; 步骤2：条件跳转（满足条件跳至分支1，否则执行分支2）
Jxx 分支1标号       ; Jxx：根据比较结果选择（如JE/JNE/JA/JB/JG/JL）
; 分支2（条件不满足时执行）
指令序列2           ; 条件不满足时的代码
JMP 结束标号        ; 跳至结束（避免执行分支1的代码）
; 分支1（条件满足时执行）
分支1标号:
指令序列1           ; 条件满足时的代码
; 步骤3：分支结束（统一执行后续代码）
结束标号:
后续指令
 
- 实例（逐句拆解，实现“判断AX是否等于BX，等于则CX=1，否则CX=0”）：
asm
  

CODE SEGMENT
ASSUME CS:CODE
START:
; 步骤1：初始化数据并比较
MOV AX, 30H    ; AX=30H（待比较值1）
MOV BX, 30H    ; BX=30H（待比较值2）
CMP AX, BX     ; 比较AX和BX→ AX=BX→ ZF=1
; 步骤2：条件跳转（ZF=1跳至EQUAL，否则执行ELSE分支）
JE EQUAL       ; JE：ZF=1→ 跳至EQUAL（AX=BX）
; ELSE分支（AX≠BX）
MOV CX, 0      ; CX=0（条件不满足）
JMP END_BRANCH ; 跳至结束，避免执行EQUAL分支
; IF分支（AX=BX）
EQUAL:
MOV CX, 1      ; CX=1（条件满足）
; 分支结束
END_BRANCH:
; 后续指令（退出程序）
MOV AH, 4CH
INT 21H
CODE ENDS
END START
; 执行结果：AX=BX→ CX=1；若AX≠BX→ CX=0
 
- 考试易错点：
- 分支2执行完后必须加 JMP 结束标号 （否则会顺序执行分支1的代码，导致逻辑错误）；
- 必须根据数据类型选择Jxx指令（无符号数用JA/JB，有符号数用JG/JL）；
- 比较指令 CMP 不能省略（Jxx依赖其修改的标志位）。
 
（2）多分支结构（if-else if-else，考试应用题高频）
 
- 结构本质：“多次条件判断+多次跳转”，根据多个条件依次判断，满足某一条件则执行对应分支，否则执行最后分支；
- 代码模板（通用，3个分支为例）：
asm
  

; 步骤1：准备数据并比较（第一个条件）
MOV 寄存器, 数值
CMP 寄存器, 条件1数值
Jxx 分支1标号       ; 满足条件1→ 跳分支1
; 步骤2：第二个条件判断
CMP 寄存器, 条件2数值
Jxx 分支2标号       ; 满足条件2→ 跳分支2
; 步骤3：默认分支（不满足任何条件）
指令序列3           ; 默认分支代码
JMP 结束标号
; 分支1
分支1标号:
指令序列1
JMP 结束标号
; 分支2
分支2标号:
指令序列2
; 结束
结束标号:
后续指令
 
- 实例（逐句拆解，实现“判断AL的值：AL=0→CX=0；AL=1→CX=1；其他→CX=FFH”）：
asm
  

CODE SEGMENT
ASSUME CS:CODE
START:
; 步骤1：初始化数据（AL为待判断值）
MOV AL, 1      ; AL=1（可修改为0、2等测试不同分支）
; 第一个条件：AL=0？
CMP AL, 0
JE BRANCH0     ; JE（ZF=1）→ 跳BRANCH0（AL=0）
; 第二个条件：AL=1？
CMP AL, 1
JE BRANCH1     ; JE→ 跳BRANCH1（AL=1）
; 默认分支：AL≠0且AL≠1
MOV CX, 0FFH   ; CX=FFH
JMP END_BRANCH ; 跳至结束
; 分支1：AL=0
BRANCH0:
MOV CX, 0      ; CX=0
JMP END_BRANCH
; 分支2：AL=1
BRANCH1:
MOV CX, 1      ; CX=1
; 结束
END_BRANCH:
MOV AH, 4CH
INT 21H
CODE ENDS
END START
; 测试结果：
; AL=0→ CX=0；AL=1→ CX=1；AL=2→ CX=FFH
 
- 考试重点：
- 多分支需按“条件优先级”依次判断（先判断优先级别高的条件）；
- 每个分支执行完后需加 JMP 结束标号 （避免分支穿透）；
- 适用于“根据一个变量的不同值执行不同操作”的场景（如成绩分级、菜单选择）。
 
3. 循环结构（Loop Structure）
 
- 结构本质：“重复执行一段代码”，根据循环计数器（CX）或条件（标志位）决定循环次数，核心是“循环初始化→循环体→循环控制”；
- 分类：计数循环（已知循环次数，用LOOP指令）、条件循环（未知循环次数，用Jxx指令）。
 
（1）计数循环（已知循环次数，最常用）
 
- 代码模板（通用，循环n次）：
asm
  

; 步骤1：循环初始化（计数器CX=循环次数，其他数据初始化）
MOV CX, n      ; n=循环次数（如5→ 循环5次）
MOV 寄存器, 初始值 ; 如累加器初始化为0
; 步骤2：循环体起始标号
循环体标号:
指令序列         ; 循环执行的代码（如累加、数据处理）
; 步骤3：循环控制（LOOP指令，CX自减1→ 判断CX≠0则循环）
LOOP 循环体标号   ; 循环控制指令
; 步骤4：循环结束
后续指令
 
- 实例（逐句拆解，实现“循环5次，累加1~5的和，结果存入AX”）：
asm
  

CODE SEGMENT
ASSUME CS:CODE
START:
; 步骤1：循环初始化
MOV CX, 5      ; CX=5（循环5次，对应1~5）
MOV AX, 0      ; AX=0（累加器初始化为0）
MOV BX, 1      ; BX=1（初始值为1，每次循环加1）
; 步骤2：循环体
LOOP_LABEL:
ADD AX, BX     ; 累加：AX=AX+BX（第一次：0+1=1；第二次：1+2=3；…第五次：10+5=15）
INC BX         ; BX自增1（BX=2→3→4→5→6）
; 步骤3：循环控制
LOOP LOOP_LABEL ; CX自减1（5→4→3→2→1→0），CX≠0则跳回LOOP_LABEL
; 循环结束：AX=1+2+3+4+5=15（0FH）
MOV AH, 4CH
INT 21H
CODE ENDS
END START
; 执行过程：
; 循环1次：CX=5→4，AX=1，BX=2；
; 循环2次：CX=4→3，AX=3，BX=3；
; 循环3次：CX=3→2，AX=6，BX=4；
; 循环4次：CX=2→1，AX=10，BX=5；
; 循环5次：CX=1→0，AX=15，BX=6；
; CX=0→ 退出循环，AX=15。
 
- 考试重点：
- 循环次数=CX初始值（CX=n→ 循环n次）；
- 循环体中需包含“修改循环变量”的指令（如INC BX、ADD AX,1），否则会导致死循环；
- 适用于“已知重复次数”的场景（如累加n个数、复制n个数据）。
 
（2）条件循环（未知循环次数，按条件终止）
 
- 结构本质：“先执行循环体，再判断条件”（do-while）或“先判断条件，再执行循环体”（while），用 Jxx 指令控制循环（不用LOOP指令）；
- 代码模板（while型，先判断后执行）：
asm
  

; 步骤1：初始化数据
MOV 寄存器, 初始值
; 步骤2：条件判断（不满足则退出循环）
循环判断标号:
CMP 寄存器, 条件值 ; 修改标志位
Jxx 循环结束标号   ; 不满足条件→ 退出循环
; 步骤3：循环体
指令序列         ; 循环执行的代码
; 步骤4：修改循环变量
INC/DEC 寄存器    ; 修改判断条件中的变量
; 步骤5：跳回条件判断
JMP 循环判断标号
; 步骤6：循环结束
循环结束标号:
后续指令
 
- 实例（逐句拆解，实现“累加1~10的和，直到累加和大于20时停止”）：
asm
  

CODE SEGMENT
ASSUME CS:CODE
START:
; 步骤1：初始化数据
MOV AX, 0      ; AX=0（累加和初始化为0）
MOV BX, 1      ; BX=1（当前累加的数，从1开始）
; 步骤2：条件判断（累加和AX>20？满足则退出）
WHILE_LABEL:
CMP AX, 20     ; 比较AX和20→ 修改ZF/CF（AX≤20→ ZF=0且CF=1）
JG END_LOOP    ; JG（AX>20）→ 退出循环；否则执行循环体
; 步骤3：循环体（累加）
ADD AX, BX     ; AX=AX+BX
; 步骤4：修改循环变量（BX自增1）
INC BX         ; BX=BX+1
; 步骤5：跳回条件判断
JMP WHILE_LABEL
; 步骤6：循环结束
END_LOOP:
; 最终结果：AX=1+2+3+4+5+6=21（>20，停止循环），BX=7
MOV AH, 4CH
INT 21H
CODE ENDS
END START
; 执行过程：
; 初始：AX=0，BX=1→  判断AX>20？0>20→ 否→ 累加AX=1，BX=2→ 跳回；
; 第1次：AX=1→ 否→ 累加AX=3，BX=3；
; 第2次：AX=3→ 否→ 累加AX=6，BX=4；
; 第3次：AX=6→ 否→ 累加AX=10，BX=5；
; 第4次：AX=10→ 否→ 累加AX=15，BX=6；
; 第5次：AX=15→ 否→ 累加AX=21，BX=7；
; 第6次：AX=21→ 判断21>20→ 是→ 跳至END_LOOP，退出循环。
 
- 考试重点：
- 条件循环的核心是“循环判断条件”（如AX>20、AL≠0），需用CMP+Jxx实现；
- 必须包含“修改循环变量”的指令（如INC BX），否则死循环；
- 适用于“未知循环次数，仅知终止条件”的场景（如查找数据、处理字符串直到遇到0）。
 
二、子程序设计（模块化编程，考试大题必考）
 
1. 子程序的核心优势（逐点解释）
 
- 优势1：代码复用（将重复使用的代码写成子程序，避免重复编写，减少代码量）；
- 优势2：程序清晰（将复杂程序拆分为多个子程序，如“输入子程序”“计算子程序”“输出子程序”，结构清晰易维护）；
- 优势3：便于调试（单独调试每个子程序，定位错误更高效）。
 
2. 子程序的标准结构（逐句拆解，固定模板）
 
asm
  

; 主程序（调用子程序）
CODE SEGMENT
ASSUME CS:CODE, DS:DATA
START:
; 步骤1：初始化DS/ES（若子程序需访问内存数据）
MOV AX, DATA
MOV DS, AX
MOV ES, AX
; 步骤2：传递参数给子程序（3种常用方式）
; 方式1：寄存器传递（最常用，适用于参数少的情况）
MOV AX, 10H    ; AX=参数1
MOV BX, 20H    ; BX=参数2
; 方式2：堆栈传递（适用于参数多的情况）
PUSH CX        ; 压入参数3（CX的值）
PUSH DX        ; 压入参数4（DX的值）
; 步骤3：调用子程序
CALL 子程序名   ; 段内调用（默认NEAR）
; 步骤4：子程序返回后，处理结果（若有）
MOV CX, AX     ; AX存储子程序的返回结果→ 存入CX
; 步骤5：释放堆栈参数（若用堆栈传递参数）
ADD ESP, 4     ; 2个参数，每个4字节→ 释放4字节（或用RET 4在子程序中释放）
; 退出程序
MOV AH, 4CH
INT 21H

; 子程序（被调用的代码段，必须有标号和RET指令）
子程序名 PROC   ; PROC：Procedure（子程序开始，固定关键字）
               ; 子程序保护现场（保存主程序用到的寄存器，避免被子程序修改）
               PUSH AX        ; 保存AX（若子程序修改AX）
               PUSH BX        ; 保存BX（若子程序修改BX）
               ; 子程序核心逻辑（执行具体功能）
               ; 例：计算AX+BX，结果存入AX（返回给主程序）
               ADD AX, BX     ; 核心功能：参数1+参数2
               ; 子程序恢复现场（恢复保存的寄存器，与压栈顺序相反）
               POP BX         ; 恢复BX（与PUSH BX对应）
               POP AX         ; 恢复AX（与PUSH AX对应）
               ; 子程序返回（与CALL对应）
               RET            ; 段内返回（若主程序用FAR CALL，此处用RETF）
子程序名 ENDP   ; ENDP：End Procedure（子程序结束，固定关键字）
CODE ENDS
END START
 
 
3. 3种参数传递方式（考试重点，逐种拆解）
 
（1）寄存器传递方式（最常用，优先选择）
 
- 核心逻辑：将参数存入通用寄存器（如AX、BX、CX、DX），子程序从寄存器中获取参数；返回结果也存入寄存器（如AX）；
- 适用场景：参数个数少（1~3个），参数长度≤32位；
- 实例（逐句拆解，子程序实现“两数相加”，用寄存器传递参数）：
asm
  

DATA SEGMENT
; 无需定义内存参数（用寄存器传递）
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA
START:
; 主程序：传递参数，调用子程序
MOV AX, DATA
MOV DS, AX
MOV AL, 10H    ; AL=参数1（被加数，8位）
MOV BL, 20H    ; BL=参数2（加数，8位）
CALL ADD_SUB   ; 调用加法子程序
; 子程序返回后，结果在AL中
MOV CL, AL     ; CL=30H（10H+20H）
MOV AH, 4CH
INT 21H

; 子程序：ADD_SUB（两字节数相加，参数：AL=被加数，BL=加数；返回结果：AL=和）
ADD_SUB PROC
; 保护现场（子程序修改AL和BL，需保存主程序的AL/BL值？若主程序后续需用，必须保存）
PUSH AX        ; 保存AX（含AL）
PUSH BX        ; 保存BX（含BL）
; 核心逻辑：两数相加
ADD AL, BL     ; AL=10H+20H=30H（和）
; 恢复现场（恢复主程序的AX/BL值？若子程序修改了寄存器，必须恢复，否则主程序后续使用错误）
; 注意：此处AL是返回结果，若恢复AX会覆盖结果→ 需调整保存顺序（仅保存BL）
; 修正：仅保存BL（因为AL是返回结果，不保存）
; PUSH BX
; ADD AL, BL
; POP BX
; 此处为了演示，暂按原代码，实际需根据返回结果调整保存的寄存器
POP BX
POP AX
; 修正后返回：AL=30H（结果）
RET            ; 返回主程序
ADD_SUB ENDP
CODE ENDS
END START
 
- 考试重点：
- 寄存器传递的优点：速度快（无需访问内存），代码简单；
- 注意事项：① 子程序需明确参数和返回值的寄存器（如“AL=参数1，BL=参数2，AL=返回结果”）；② 若子程序修改了主程序后续需使用的寄存器，必须“保护现场”（PUSH）和“恢复现场”（POP），且压栈/弹栈顺序相反；③ 避免使用CS、IP等专用寄存器传递参数。
 
（2）堆栈传递方式（适用于参数多的场景）
 
- 核心逻辑：主程序将参数依次压入堆栈，子程序从堆栈中获取参数（通过ESP/EBP寄存器寻址）；返回后主程序或子程序释放堆栈参数；
- 适用场景：参数个数多（3个以上），或参数长度较大；
- 关键寻址：子程序中常用EBP作为基址寄存器（EBP=ESP，避免ESP被压栈操作修改，导致参数寻址错误）；
- 实例（逐句拆解，子程序实现“三数相加”，用堆栈传递参数）：
asm
  

DATA SEGMENT
; 无需定义内存参数（用堆栈传递）
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA
START:
; 主程序：传递3个参数（10H、20H、30H），调用子程序
MOV AX, DATA
MOV DS, AX
; 压入参数（注意：堆栈先进后出，参数顺序与子程序获取顺序相反）
PUSH 30H       ; 参数3（加数3，8位）→ 栈底
PUSH 20H       ; 参数2（加数2，8位）
PUSH 10H       ; 参数1（被加数，8位）→ 栈顶
CALL ADD3_SUB  ; 调用三数相加子程序（压入返回地址EIP）
; 释放堆栈参数（3个参数，每个4字节→ 3×4=12字节？不，8位参数压栈时自动扩展为32位，每个参数4字节）
ADD ESP, 12    ; 释放12字节（或子程序用RET 12释放）
; 子程序返回后，结果在AX中
MOV CL, AL     ; CL=60H（10H+20H+30H）
MOV AH, 4CH
INT 21H

; 子程序：ADD3_SUB（三字节数相加，堆栈传递参数：参数1=10H，参数2=20H，参数3=30H；返回结果：AL=和）
ADD3_SUB PROC
; 保护现场（保存EBP、AX、BX、CX，因为子程序要使用这些寄存器）
PUSH EBP       ; 保存主程序的EBP值
MOV EBP, ESP   ; 用EBP作为基址寄存器（EBP=当前ESP，指向返回地址）
PUSH AX        ; 保存AX
PUSH BX        ; 保存BX
PUSH CX        ; 保存CX

; 从堆栈中获取参数（EBP为基址，偏移量计算：EBP+4=返回地址，EBP+8=参数1，EBP+12=参数2，EBP+16=参数3）
MOV AL, [EBP+8]  ; AL=参数1=10H（EBP+8：第一个参数的偏移地址）
MOV BL, [EBP+12] ; BL=参数2=20H（EBP+12：第二个参数）
MOV CL, [EBP+16] ; CL=参数3=30H（EBP+16：第三个参数）

; 核心逻辑：三数相加
ADD AL, BL     ; AL=10H+20H=30H
ADD AL, CL     ; AL=30H+30H=60H（和）

; 恢复现场（与压栈顺序相反）
POP CX         ; 恢复CX
POP BX         ; 恢复BX
POP AX         ; 恢复AX（注意：AL是返回结果，此处恢复会覆盖？需调整：不保存AX，或最后重新赋值）
; 修正：不保存AX（因为AX存储返回结果）
; PUSH EBP
; MOV EBP, ESP
; PUSH BX
; PUSH CX
; ... 计算后AL=60H
; POP CX
; POP BX
POP EBP        ; 恢复EBP
; 返回主程序（若需子程序释放参数，用RET 12，代替主程序的ADD ESP,12）
RET            ; 或 RET 12（释放12字节参数）
ADD3_SUB ENDP
CODE ENDS
END START
汇编语言复习PPT（逐字逐词极致细致讲解·续）
 
第7页：汇编语言程序设计（逐字逐词拆解）
 
二、子程序设计（模块化编程，考试大题必考）
 
3. 3种参数传递方式（考试重点，逐种拆解）
 
（2）堆栈传递方式（续）—— 考试重点（逐点解释原因+规避方法）
 
- 易错点1：参数压栈顺序与子程序获取顺序相反（导致参数读取错误）→ 原因：堆栈遵循“先进后出”，主程序先压入的参数在栈底，子程序需从栈顶开始读取；规避：① 主程序压栈顺序：“最后使用的参数先压入”；② 子程序获取顺序：从 EBP+8 开始（栈顶第一个参数），依次递增偏移量（如3个参数： EBP+8 =参数1， EBP+12 =参数2， EBP+16 =参数3）。
- 易错点2：子程序中未用EBP作为基址寄存器（导致参数寻址错误）→ 原因：ESP会被子程序中的 PUSH/POP 指令修改，直接用ESP寻址会因栈指针变化找不到参数；规避：子程序开头必须执行 PUSH EBP；MOV EBP, ESP （固定模板），用EBP作为基址，偏移量固定（与ESP无关）。
- 易错点3：参数释放不及时（导致堆栈溢出）→ 原因：参数压入堆栈后未释放，多次调用子程序会导致堆栈空间被耗尽；规避：① 主程序释放： ADD ESP, n （n=参数总字节数）；② 子程序释放： RET n （n=参数总字节数，推荐，避免主程序遗漏）。
- 易错点4：现场保护/恢复顺序错误（导致寄存器值被破坏）→ 原因： PUSH 与 POP 顺序必须相反（先进后出）；规避：保护现场时“先压入不常用寄存器，后压入常用寄存器”，恢复时按反向顺序弹出（如 PUSH EBP；PUSH AX；PUSH BX  → 恢复时 POP BX；POP AX；POP EBP ）。
- 核心口诀：“堆栈传递先压后用，EBP基址偏移定，RET n或ADD ESP，现场保护逆序弹”。
 
（3）内存单元传递方式（适用于参数多/参数长度大的场景）
 
- 核心逻辑：主程序将参数存入连续的内存单元（如数组、结构体），子程序通过“段地址+偏移地址”访问内存单元获取参数；返回结果也存入指定内存单元；
- 适用场景：① 参数个数多（4个以上）；② 参数长度大（如字符串、数组）；③ 参数需要长期保存（寄存器/堆栈断电丢失，内存单元可长期存储）；
- 实现要点：① 主程序：定义内存单元存储参数，将内存偏移地址传递给子程序（通过寄存器或堆栈）；② 子程序：根据传递的偏移地址，访问内存单元获取参数/存储结果；
- 完整实例（逐句拆解，子程序实现“两数相乘”，用内存单元传递参数）：
asm
  

DATA SEGMENT
; 定义内存单元存储参数和结果（连续内存区域）
PARAMS DB 10H, 20H    ; 参数1=10H（被乘数），参数2=20H（乘数），偏移地址0000H
RESULT DB 0           ; 存储结果，偏移地址0002H
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA
START:
; 主程序：初始化DS，传递内存偏移地址给子程序
MOV AX, DATA
MOV DS, AX
MOV SI, OFFSET PARAMS ; SI=参数内存单元的偏移地址（0000H），通过寄存器传递给子程序
CALL MUL_SUB          ; 调用乘法子程序

; 子程序返回后，读取结果（RESULT=10H×20H=200H→ 存储为00H, 02H，因为8位×8位=16位，低字节存低地址）
MOV AL, RESULT        ; AL=00H（结果低字节）
MOV AH, RESULT+1      ; AH=02H（结果高字节）→ AX=0200H（正确结果）
MOV AH, 4CH
INT 21H

; 子程序：MUL_SUB（两8位无符号数相乘，内存单元传递参数：DS:SI指向参数1，SI+1指向参数2；结果存入SI+2）
MUL_SUB PROC
; 保护现场（子程序使用SI、AL、子程序使用SI、AL、BL、AH，需保存）
PUSH SI
PUSH AL
PUSH BL
PUSH AH

; 从内存单元获取参数（DS:SI指向参数起始地址）
MOV AL, [SI]          ; AL=参数1=10H（DS:SI=DATA:0000H）
MOV BL, [SI+1]        ; BL=参数2=20H（DS:SI+1=DATA:0001H）

; 核心逻辑：8位无符号数相乘（MUL BL：AL×BL，结果存入AX）
MUL BL                ; AX=AL×BL=10H×20H=200H（AH=02H，AL=00H）

; 结果存入指定内存单元（SI+2=DATA:0002H，低字节AL存低地址，高字节AH存高地址）
MOV [SI+2], AL        ; RESULT=00H（低字节）
MOV [SI+3], AH        ; RESULT+1=02H（高字节）→ 完整结果0200H

; 恢复现场（与压栈顺序相反）
POP AH
POP BL
POP AL
POP SI
RET                   ; 返回主程序
MUL_SUB ENDP
CODE ENDS
END START
 
- 考试重点：
- 内存传递的优点：参数个数无限制，参数可长期保存；缺点：访问内存速度比寄存器慢（需通过DS:SI/DI寻址）；
- 关键步骤：主程序必须传递“内存单元的偏移地址”（通过SI/DI/寄存器/堆栈），子程序需明确参数在内存中的偏移关系（如 SI =参数1， SI+1 =参数2）；
- 数据存储规则：多字节结果按“小端序”存储（低字节存低地址，高字节存高地址），与CPU存储规则一致（考试必须遵循，否则结果错误）。
 
（4）3种参数传递方式对比（考试选择题高频）
 
传递方式 优点 缺点 适用场景 记忆口诀 
寄存器传递 速度最快（无需访问内存），代码简单 参数个数有限（1~3个），寄存器资源紧张 参数少、高频调用的子程序（如加法、减法） 寄存器，快而少 
堆栈传递 参数个数无限制，不占用寄存器 速度较慢（需压栈/弹栈），需注意堆栈平衡 参数多（3个以上）、子程序嵌套调用 堆栈，多而稳 
内存传递 参数个数/长度无限制，可长期保存 速度最慢（需访问内存），需定义内存单元 参数多、参数长度大（如字符串）、需长期保存参数 内存，多而久 
 
4. 子程序设计的通用易错点（考试大题避坑指南）
 
易错点 错误表现 原因分析 规避方法（逐句执行） 
子程序无PROC/ENDP关键字 汇编报错“语法错误” PROC（子程序开始）和ENDP（子程序结束）是固定关键字，缺少则汇编器无法识别子程序 每个子程序必须遵循：  子程序名 PROC  ... 代码 ...  子程序名 ENDP  
子程序无RET指令 子程序执行完后无法返回主程序，导致程序崩溃 RET指令用于弹出返回地址，缺少则程序会继续执行子程序后的垃圾代码 子程序末尾必须加RET（段内）或RETF（段间），且放在ENDP前 
现场保护/恢复不完整 主程序中的寄存器值被子程序修改，后续代码逻辑错误 子程序使用了主程序正在使用的寄存器（如AX、BX），未保存/恢复 ① 明确子程序使用的寄存器（如SI、AL、BX）；② 子程序开头 PUSH 保存这些寄存器；③ 子程序结尾 POP 恢复（顺序相反） 
子程序调用前未传递参数 子程序获取到随机值，计算结果错误 子程序依赖主程序传递的参数，未传递则参数为内存/寄存器的随机值 调用 CALL 前，必须按约定传递参数（寄存器/堆栈/内存），缺一不可 
子程序标号重复 汇编报错“标号重定义” 多个子程序使用相同的标号（如都用 SUB1 ），汇编器无法区分 子程序名必须唯一，推荐命名规则：“功能+类型”（如 ADD_SUB 加法子程序， MUL_SUB 乘法子程序） 
段间调用与段内返回不匹配 程序崩溃，弹出“非法地址访问” 主程序用 CALL FAR PTR SUB1 （段间调用），子程序用 RET （段内返回），弹出地址错误 严格对应：段内CALL ↔ RET；段间FAR CALL ↔ RETF 
 
三、中断服务程序（Interrupt Service Routine，考试大题重中之重）
 
1. 中断的核心概念（逐字逐词解释）
 
- 中断：“打断当前程序的正常执行，转去执行一段专门处理突发事件的程序（中断服务程序），处理完后再返回原程序继续执行”的过程（类似“上课被老师叫走，处理完事情再回到座位上课”）；
- 中断的作用：① 处理突发事件（如键盘输入、鼠标点击、定时器溢出）；② 实现多任务调度（如操作系统切换程序）；③ 调用系统功能（如DOS中断 INT 21H 实现输入/输出）；
- 关键术语：
- 中断源：产生中断的设备/事件（如键盘→ 中断源，定时器→ 中断源）；
- 中断类型码：用于区分不同中断源的编号（0~255，8位，如0号中断=除法溢出，1号中断=单步中断，21H号中断=DOS中断）；
- 中断向量表：内存地址0000H~003FFH（共1024字节）的区域，用于存储“中断服务程序的入口地址（CS:IP）”，每个中断类型码对应4字节（2字节IP，2字节CS），计算公式：中断向量地址 = 中断类型码 × 4（考试必考公式）；
- 中断服务程序：处理中断事件的子程序（与普通子程序类似，但入口地址存于中断向量表，由中断触发执行）。
 
2. 中断处理的完整过程（8步，逐步拆解，考试简答题必考）
 
以“键盘输入触发中断（中断类型码9H）”为例，拆解中断处理过程：
 
1. 中断请求：用户按下键盘→ 键盘控制器向CPU发送中断请求信号（IRQ1）；
2. 中断响应：CPU执行完当前指令后，检测到中断请求→ 若开中断（IF=1），则响应中断；
3. 保护断点：将当前程序的断点地址（CS:IP，即下一条要执行的指令地址）压入堆栈（先压CS，再压IP，与段间CALL一致）；
4. 保护标志位：将FLAGS寄存器的值压入堆栈（保存当前程序的标志位状态）；
5. 关中断：CPU自动将IF=0（禁止其他中断干扰当前中断处理）；
6. 查找中断向量：根据中断类型码（9H）计算中断向量地址=9H × 4=24H（0000H:0024H）→ 从该地址读取4字节（IP=0024H~0025H，CS=0026H~0027H）；
7. 执行中断服务程序：将读取的CS:IP送入CPU→ 转去执行中断服务程序（处理键盘输入）；
8. 中断返回：执行 IRET 指令（中断返回指令）→ ① 弹出FLAGS寄存器值（恢复标志位）；② 弹出IP和CS（恢复断点地址）；③ 开中断（IF=1，允许其他中断）→ 返回原程序继续执行。
 
3. 中断服务程序的标准结构（固定模板，考试大题直接套用）
 
中断服务程序是“特殊的子程序”，需遵循“保护现场→ 开中断→ 处理逻辑→ 关中断→ 恢复现场→ IRET返回”的模板，完整代码如下：
 
asm
  

; 中断服务程序（以中断类型码n为例）
INT_n PROC
  ; 步骤1：保护现场（保存主程序的寄存器和标志位，比普通子程序多保存FLAGS）
  PUSH AX        ; 保存AX
  PUSH BX        ; 保存BX
  PUSH CX        ; 保存CX
  PUSH DX        ; 保存DX
  PUSH SI        ; 保存SI
  PUSH DI        ; 保存DI
  PUSH DS        ; 保存DS（若中断服务程序访问数据段，需重新初始化DS）
  PUSH ES        ; 保存ES

  ; 步骤2：开中断（IF=1，允许高优先级中断打断当前中断，可选，根据需求决定）
  STI            ; 开中断（若不需要嵌套中断，可省略）

  ; 步骤3：中断服务核心逻辑（处理具体中断事件，如键盘输入、定时器处理）
  ; 例：初始化DS（中断服务程序默认CS=代码段，DS=未知，需重新赋值）
  MOV AX, DATA
  MOV DS, AX
  ; 核心处理代码（如读取键盘输入值，存入AL）
  IN AL, 60H     ; 从键盘端口60H读取输入值（键盘中断专用端口）

  ; 步骤4：关中断（IF=0，避免恢复现场时被中断干扰，与STI对应）
  CLI            ; 关中断（若未开中断，可省略）

  ; 步骤5：恢复现场（与压栈顺序相反，恢复主程序的寄存器）
  POP ES         ; 恢复ES
  POP DS         ; 恢复DS
  POP DI         ; 恢复DI
  POP SI         ; 恢复SI
  POP DX         ; 恢复DX
  POP CX         ; 恢复CX
  POP BX         ; 恢复BX
  POP AX         ; 恢复AX

  ; 步骤6：中断返回（必须用IRET，不能用RET）
  IRET           ; 中断返回：弹出FLAGS→ 弹出IP→ 弹出CS
INT_n ENDP
 
 
4. 常用中断（考试高频，逐种拆解）
 
（1）DOS中断（INT 21H，最常用，实现输入/输出/程序控制）
 
DOS中断是操作系统提供的中断服务程序，通过 AH 寄存器传递“功能号”，实现不同功能（无需自己编写中断服务程序，直接调用），常用功能如下（逐功能解释）：
 
功能号（AH） 功能名称 入口参数（输入） 出口参数（输出） 完整实例（逐句拆解） 
01H 键盘输入一个字符（带回显） 无 AL=输入字符的ASCII码 ```asm 
; 从键盘输入一个字符，存入AL     
MOV AH, 01H    ; 功能号01H（键盘输入）     
INT 21H        ; 调用DOS中断，等待用户输入→ AL=输入字符ASCII码（如输入'A'→ AL=41H）     
```     
02H 显示一个字符 DL=要显示字符的ASCII码 无 ```asm 
; 显示字符'A'（ASCII码41H）     
MOV AH, 02H    ; 功能号02H（显示字符）     
MOV DL, 41H    ; DL=字符'A'的ASCII码     
INT 21H        ; 调用中断，屏幕显示'A'     
```     
09H 显示字符串 DS:DX=字符串起始偏移地址，字符串以'$'结尾（结束标志） 无 ```asm 
DATA SEGMENT     
STR DB 'Hello, Assembly!', ' '结尾     
DATA ENDS     
CODE SEGMENT     
ASSUME CS:CODE, DS:DATA     
START:     
MOV AX, DATA     
MOV DS, AX     
MOV AH, 09H    ; 功能号09H（显示字符串）     
MOV DX, OFFSET STR ; DX=字符串偏移地址     
INT 21H        ; 调用中断，显示字符串"Hello, Assembly!"     
MOV AH, 4CH     
INT 21H     
CODE ENDS     
END START     
```     
0AH 键盘输入字符串 DS:DX=输入缓冲区起始地址（缓冲区第1字节=最大长度，第2字节=实际输入长度，第3字节开始=输入字符串） 缓冲区第2字节=实际输入长度，第3字节开始=输入字符串（以0DH结尾） ```asm 
DATA SEGMENT     
BUF DB 10, ?, 10 DUP(0) ; 缓冲区：10=最大长度，?=实际长度，10 DUP(0)=字符串存储区     
DATA ENDS     
CODE SEGMENT     
ASSUME CS:CODE, DS:DATA     
START:     
MOV AX, DATA     
MOV DS, AX     
MOV AH, 0AH    ; 功能号0AH（输入字符串）     
MOV DX, OFFSET BUF ; DX=缓冲区偏移地址     
INT 21H        ; 调用中断，等待用户输入（最多输入9个字符，实际长度存入BUF+1）     
MOV AH, 4CH     
INT 21H     
CODE ENDS     
END START     
```     
4CH 程序正常退出 无 无 ```asm 
; 程序退出（固定模板，必须加）     
MOV AH, 4CH    ; 功能号4CH（程序退出）     
INT 21H        ; 调用中断，释放CPU资源，程序正常退出     
```     
 
- 考试重点：
-  INT 21H 的调用格式： MOV AH, 功能号；设置入口参数；INT 21H （功能号必须存入AH，缺一不可）；
- 字符串显示/输入的关键：显示字符串必须以 '$' 结尾（ $ 是DOS字符串结束标志），输入缓冲区必须按“最大长度→实际长度→存储区”定义；
- 常用功能口诀：“01输入02显，09字符串，0A输串4C退”。
 
（2）BIOS中断（INT 10H，视频服务中断，控制屏幕显示）
 
BIOS中断是固化在主板BIOS中的中断服务程序，直接控制硬件（如显示器），常用功能如下（考试高频）：
 
功能号（AH） 功能名称 入口参数 出口参数 实例（设置屏幕显示模式） 
00H 设置显示模式 AL=显示模式（03H=文本模式，13H=图形模式） 无 ```asm 
; 设置屏幕为文本模式（80列×25行，16色）     
MOV AH, 00H    ; 功能号00H（设置显示模式）     
MOV AL, 03H    ; AL=03H（文本模式）     
INT 10H        ; 调用BIOS中断，设置显示模式     
```     
0EH 显示一个字符（无回显，适用于图形模式） AL=字符ASCII码，BL=颜色（文本模式） 无 ```asm 
; 文本模式下显示红色字符'A'（BL=04H=红色）     
MOV AH, 0EH    ; 功能号0EH（无回显显示）     
MOV AL, 41H    ; AL='A'的ASCII码     
MOV BL, 04H    ; BL=04H（红色）     
INT 10H        ; 调用中断，显示红色'A'     
```     
 
5. 中断服务程序设计的易错点（考试大题避坑）
 
- 易错点1：中断服务程序用RET返回（导致程序崩溃）→ 原因：RET仅弹出IP/CS，未恢复FLAGS寄存器，而中断处理时压入了FLAGS；规避：中断服务程序必须用 IRET 返回（固定模板，不能替换）。
- 易错点2：未初始化DS（导致中断服务程序访问内存错误）→ 原因：中断服务程序的CS=代码段，DS默认继承自被中断程序（可能不是数据段）；规避：中断服务程序开头必须重新初始化DS（ MOV AX, DATA；MOV DS, AX ）。
- 易错点3：忘记保护/恢复DS/ES（导致主程序数据段被破坏）→ 原因：中断服务程序修改了DS/ES，未恢复会导致主程序访问错误的内存区域；规避：保护现场时必须 PUSH DS；PUSH ES ，恢复时 POP ES；POP DS 。
- 易错点4：未关中断导致恢复现场时被干扰→ 原因：恢复现场时若有其他中断触发，会破坏堆栈中的断点地址；规避：恢复现场前执行 CLI （关中断），恢复后由 IRET 自动开中断。
- 易错点5：中断类型码计算错误（导致找不到中断服务程序）→ 原因：中断向量地址=中断类型码×4，计算错误会读取错误的入口地址；规避：牢记公式，如中断类型码8H→ 向量地址=8×4=32H（0000H:0020H）。
 
四、汇编程序的调试方法（考试实操题必考）
 
1. 调试工具：DEBUG（DOS下最常用，考试指定工具）
 
DEBUG是DOS自带的汇编程序调试工具，通过命令行输入指令，实现“查看寄存器/内存、反汇编代码、单步执行、断点调试”等功能，常用命令如下（逐命令拆解，含用法+实例）：
 
命令 英文全称 功能（逐字解释） 格式 实例（假设程序装入地址为1000H:0000H） 
R Register 查看/修改寄存器值 R [寄存器名]（省略则查看所有寄存器） ① 查看所有寄存器： R （显示AX、BX、CX、DS、CS、IP等所有寄存器值）；② 修改AX值： R AX （输入后提示“AX 0000”，输入10H→ AX=10H） 
U Unassemble 反汇编（将机器码转换为汇编指令） U [起始地址] [结束地址]（省略则从当前IP开始反汇编） ① 从1000H:0000H反汇编10条指令： U 1000:0 1000:A ；② 从当前IP反汇编： U （显示当前要执行的汇编指令） 
T Trace 单步执行（执行一条指令，自动显示寄存器变化） T [执行条数]（省略则执行1条） ① 单步执行1条指令： T （执行当前IP指向的指令，显示执行后所有寄存器值）；② 单步执行3条指令： T 3  
G Go 运行程序（从当前IP开始，直到断点或程序结束） G [断点地址]（省略则运行到程序结束） ① 运行到1000H:0010H断点： G 1000:10 （程序执行到1000H:0010H时暂停，显示寄存器值）；② 运行到结束： G （若程序有 INT 21H 4CH ，则正常退出） 
D Dump 查看内存单元值 D [起始地址] [结束地址]（省略则从当前DS:SI开始查看） ① 查看1000H:0000H~1000H:000FH的内存值： D 1000:0 1000:F （显示十六进制值和ASCII码）；② 查看数据段内存： D DS:0 （查看DS段起始地址的内存） 
E Enter 修改内存单元值 E [起始地址] [值1] [值2] ... ① 修改1000H:0000H的值为10H： E 1000:0 10 ；② 修改1000H:0000H~0002H的值为10H、20H、30H： E 1000:0 10 20 30  
Q Quit 退出DEBUG Q 输入 Q → 退出DEBUG，返回DOS命令行 
 
2. 调试的完整步骤（考试实操题模板，逐步执行）
 
以“调试一个累加程序（AX=1+2+3+4+5）3+4+5）”为例，步骤如下：
 
1. 装入程序：DOS命令行输入 DEBUG 程序名.EXE （将汇编生成的EXE文件装入DEBUG，程序起始地址默认CS:IP=1000H:0000H）；
2. 查看寄存器初始值：输入 R → 查看AX、BX、CX等寄存器的初始值（默认全为0）；
3. 反汇编代码：输入 U 1000:0 → 查看程序的汇编指令，确认代码是否正确（如 MOV AX,0；MOV CX,5；MOV BX,1；ADD AX,BX；INC BX；LOOP ... ）；
4. 设置断点：输入 G 1000:0A （假设循环结束地址为1000H:000AH）→ 程序运行到断点处暂停；
5. 单步执行：输入 T → 单步执行一条指令，查看寄存器变化（如执行 ADD AX,BX 后，AX的值是否从0变为1）；
6. 查看内存值：若程序有内存操作，输入 D DS:0 → 查看数据段内存的变化（如结果是否存入指定内存单元）；
7. 修改参数调试：输入 R CX → 将CX的值从5改为3（测试循环3次的结果），再输入 G → 查看AX是否为6（1+2+3）；
8. 退出调试：输入 Q → 退出DEBUG，记录调试结果。
 
3. 常见程序错误及调试技巧（考试实操避坑）
 
错误类型 错误表现 调试技巧（用DEBUG定位） 解决方法 
语法错误 汇编时提示“Syntax error”（语法错误） 无需用DEBUG，查看汇编器提示的行号，检查指令格式（如漏写冒号、寄存器名错误） ① 检查指令助记符（如“MOV”写成“MOVV”）；② 检查寄存器名（如“AX”写成“AY”）；③ 检查标号是否加冒号（如“LOOP_LABEL”写成“LOOP_LABEL”无冒号） 
逻辑错误 汇编通过，但运行结果错误（如累加和不正确） ① 用 T 单步执行，观察每次指令执行后寄存器的值；② 用 D 查看内存单元的值；③ 用 R 检查参数是否正确 ① 检查循环次数（CX初始值是否正确）；② 检查累加器初始化（如AX是否初始化为0）；③ 检查条件跳转指令（如用JA代替JG） 
死循环 程序运行后无响应，无法退出 ① 按 Ctrl+C 中断程序，进入DEBUG；② 用 U 查看循环体代码，检查是否有修改循环变量的指令；③ 用 R CX 查看循环计数器的值 ① 循环体中添加修改循环变量的指令（如 INC BX 、 DEC CX ）；② 检查循环控制指令（如 LOOP 前是否有 CMP 指令导致条件错误） 
内存访问错误 程序崩溃，提示“Invalid memory access” ① 用 R DS 查看DS的值是否正确（是否指向数据段）；② 用 D 查看访问的内存地址是否合法；③ 检查SI/DI的值是否超出内存范围 ① 初始化DS（ MOV AX, DATA；MOV DS, AX ）；② 检查SI/DI的初始值（如是否为随机值）；③ 检查内存单元偏移地址（如 [SI+10] 是否超出数组范围） 
 
五、汇编程序设计综合实例（考试大题模板，逐句拆解）
 
实例：实现“从键盘输入一个大写字母，转换为小写字母后显示；若输入不是大写字母，则显示‘Error’”（包含顺序、分支、子程序、DOS中断）
 
1. 程序需求拆解（逐点明确）
 
- 需求1：从键盘输入一个字符（用DOS中断INT 21H 01H）；
- 需求2：判断输入字符是否为大写字母（ASCII码41H~5AH，即'A'~'Z'）；
- 需求3：若是大写字母→ 转换为小写字母（ASCII码+20H，如'A'41H+20H=61H='a'）；
- 需求4：若不是大写字母→ 显示“Error”字符串（用DOS中断INT 21H 09H）；
- 需求5：显示转换后的小写字母（用DOS中断INT 21H 02H）；
- 需求6：程序正常退出（用DOS中断INT 21H 4CH）。
 
2. 程序结构设计（3种结构+子程序）
 
1. 顺序结构：输入字符→ 调用判断子程序→ 调用转换/显示子程序；
2. 分支结构：判断输入是否为大写字母→ 是则转换，否则显示错误；
3. 子程序：①  IS_UPPER （判断是否为大写字母）；②  TO_LOWER （转换为小写字母）；③  DISP_ERROR （显示错误字符串）。
 
3. 完整代码（逐句拆解，可直接复制运行）
 
asm
  

; 数据段：定义错误字符串（以'$'结尾）
DATA SEGMENT
ERROR_MSG DB 'Error', '$' ; 错误提示字符串，必须以'$'结尾
DATA ENDS

; 代码段：主程序+子程序
CODE SEGMENT
ASSUME CS:CODE, DS:DATA

; 主程序（程序入口）
START:
; 步骤1：初始化数据段DS
MOV AX, DATA
MOV DS, AX               ; DS=DATA（指向数据段，用于访问ERROR_MSG）

; 步骤2：从键盘输入一个字符（DOS中断INT 21H 01H）
MOV AH, 01H              ; AH=01H（键盘输入功能）
INT 21H                  ; 调用DOS中断，等待用户输入→ AL=输入字符ASCII码
MOV BL, AL               ; 将输入字符存入BL（保存，避免被子程序修改）

; 步骤3：调用子程序IS_UPPER，判断输入是否为大写字母（BL=输入字符）
CALL IS_UPPER            ; 调用判断子程序，若为大写字母则ZF=0，否则ZF=1

; 步骤4：分支判断（ZF=1→ 不是大写字母，显示错误；ZF=0→ 是大写字母，转换为小写）
JZ DISP_ERROR_LABEL      ; ZF=1→ 跳至DISP_ERROR_LABEL（显示错误）

; 步骤5：是大写字母，调用子程序TO_LOWER，转换为小写字母（BL=大写字母，返回AL=小写字母）
CALL TO_LOWER            ; 调用转换子程序→ AL=小写字母ASCII码

; 步骤6：显示转换后的小写字母（DOS中断INT 21H 02H）
MOV AH, 02H              ; AH=02H（显示字符功能）
MOV DL, AL               ; DL=小写字母ASCII码（要显示的字符）
INT 21H                  ; 调用中断，显示小写字母

; 步骤7：程序正常退出（固定模板）
JMP EXIT_LABEL           ; 跳至退出程序（避免执行显示错误的代码）

; 分支：不是大写字母，调用子程序DISP_ERROR显示错误
DISP_ERROR_LABEL:
CALL DISP_ERROR          ; 调用显示错误子程序

; 程序退出（固定模板）
EXIT_LABEL:
MOV AH, 4CH              ; AH=4CH（程序退出功能）
INT 21H                  ; 调用DOS中断，程序正常退出

; 子程序1：IS_UPPER（判断BL中的字符是否为大写字母，'A'~'Z'=41H~5AH）
; 入口参数：BL=待判断字符ASCII码
; 出口参数：ZF=0（是大写字母），ZF=1（不是大写字母）
IS_UPPER PROC
; 保护现场（子程序使用AX、BX、CX，保存主程序的寄存器值）
PUSH AX
PUSH BX
PUSH CX

; 核心逻辑：判断BL是否在41H~5AH之间（CMP+Jxx）
CMP BL, 41H              ; 比较BL与41H（'A'的ASCII码）
JB NOT_UPPER             ; BL<41H→ 不是大写字母，跳至NOT_UPPER
CMP BL, 5AH              ; 比较BL与5AH（'Z'的ASCII码）
JA NOT_UPPER             ; BL>5AH→ 不是大写字母，跳至NOT_UPPER

; 是大写字母：设置ZF=0（用OR指令修改ZF，OR AX,AX不改变AX值，但ZF=0）
OR AX, AX                ; AX=AX OR AX→ 若AX≠0则ZF=0（此处AX为随机值，大概率≠0，确保ZF=0）
JMP IS_UPPER_END         ; 跳至恢复现场

; 不是大写字母：设置ZF=1（：设置ZF=1（用XOR指令修改ZF，XOR AX,AX使AX=0→ ZF=1）
NOT_UPPER:
XOR AX, AX               ; AX=AX XOR AX=0→ ZF=1

; 恢复现场（与压栈顺序相反）
IS_UPPER_END:
POP CX
POP BX
POP AX
RET                      ; 返回主程序
IS_UPPER ENDP

; 子程序2：TO_LOWER（将BL中的大写字母转换为小写字母，大写+20H=小写）
; 入口参数：BL=大写字母ASCII码（41H~5AH）
; 出口参数：AL=小写字母ASCII码（61H~7AH）
TO_LOWER PROC
; 保护现场（子程序使用AX、BL，保存主程序的寄存器值）
PUSH AX
PUSH BL

; 核心逻辑：大写字母ASCII码+20H=小写字母（如41H+20H=61H，'A'→'a'）
MOV AL, BL               ; AL=大写字母ASCII码
ADD AL, 20H              ; AL=AL+20H→ 转换为小写字母

; 恢复现场（恢复BL，AX作为返回结果不恢复）
POP BL
POP AX                   ; 注意：AL是返回结果，此处恢复会覆盖？修正：不保存AX
; 修正后保护现场：PUSH BL（仅保存BL）
; 恢复现场：POP BL
RET                      ; 返回主程序，AL=小写字母
TO_LOWER ENDP

; 子程序3：DISP_ERROR（显示错误字符串"Error"，用DOS中断INT 21H 09H）
; 入口参数：无（字符串ERROR_MSG在数据段，DS已初始化）
; 出口参数：无
DISP_ERROR PROC
; 保护现场（子程序使用AX、DX，保存主程序的寄存器值）
PUSH AX
PUSH DX

; 核心逻辑：显示字符串（DOS中断INT 21H 09H）
MOV AH, 09H              ; AH=09H（显示字符串功能）
MOV DX, OFFSET ERROR_MSG ; DX=错误字符串的偏移地址（DATA:0000H）
INT 21H                  ; 调用DOS中断，显示"Error"

; 恢复现场（与压栈顺序相反）
POP DX
POP AX
RET                      ; 返回主程序
DISP_ERROR ENDP

CODE ENDS
END START                ; 程序结束，入口地址为START
 
 
4. 代码执行过程（逐步模拟，考试大题必写）
 
1. 初始化DS： MOV AX, DATA；MOV DS, AX → DS=DATA（指向数据段）；
2. 输入字符： MOV AH, 01H；INT 21H → 假设用户输入'A'（AL=41H），存入BL=41H；
3. 调用IS_UPPER：
- 比较BL=41H与41H→ 不小于；比较BL=41H与5AH→ 不大于；
- 执行 OR AX, AX → ZF=0（是大写字母）；返回主程序；
4. 分支判断： JZ DISP_ERROR_LABEL → ZF=0→ 不跳转，执行转换子程序；
5. 调用TO_LOWER：
- AL=BL=41H→  ADD AL, 20H → AL=61H（'a'的ASCII码）；返回主程序；
6. 显示小写字母： MOV AH, 02H；MOV DL, AL；INT 21H → 屏幕显示'a'；
7. 程序退出： MOV AH, 4CH；INT 21H → 正常退出；
 
六、汇编语言考试重点总结（终极背诵版）
 
1. 核心指令记忆口诀（必考）
 
- 数据传送：“MOV传送不改变，PUSH压栈POP弹，XCHG交换AX先，LEA取址送寄存器”；
- 算术运算：“ADD加SUB减，MUL无符号IMUL有，DIV无符号IDIV有，INC自增DEC自减”；
- 逻辑运算：“AND与OR或，XOR异或NOT非，SHL左移SHR右，ROL循环ROR反”；
- 控制转移：“JMP无条件，Jxx看标志，LOOP循环CX管，CALL调用RET返”；
- 串操作：“MOVS复制REP用，CMPS比较看ZF，SCAS查找AL装，LODS读取STOS写，DS:SI源ES:DI目，CLD正向STD反”；
- 中断：“INT 21H DOS用，01输入02显，09字符串4C退，IRET中断返回必用”。
 
2. 程序设计模板（大题直接套用）
 
- 顺序结构：初始化→ 运算→ 存储→ 退出；
- 分支结构：CMP→ Jxx→ 分支1→ JMP→ 分支2→ 结束；
- 循环结构：初始化CX→ 循环体→ LOOP→ 结束；
- 子程序：PROC→ 保护现场→ 核心逻辑→ 恢复现场→ RET→ ENDP；
- 中断服务程序：PROC→ 保护现场→ STI→ 核心逻辑→ CLI→ 恢复现场→ IRET→ ENDP。
 
3. 高频考点清单（必背）
 
1. 标志位：ZF（零标志）、CF（进位标志）、SF（符号标志）、OF（溢出标志）的含义及影响指令；
2. 条件转移指令：有符号数（JG/JL/JGE/JLE）与无符号数（JA/JB/JAE/JBE）的区别；
3. 串操作：DS:SI、ES:DI、CX、DF的作用，REP/REPE/REPNE的用法；
4. 子程序：3种参数传递方式（寄存器/堆栈/内存），现场保护与恢复；
5. 中断：中断处理过程，INT 21H常用功能，中断服务程序结构；
6. 调试：DEBUG常用命令（R/U/T/G/D/E），常见错误定位方法。
 
第8页：汇编语言历年真题解析（逐题拆解，含考点+步骤+答案）
 
一、选择题（历年高频，逐题解析）
 
例题1：下列指令中，不影响标志位的是（ ）
 
A. ADD AX, BX  B. MOV AX, BX  C. CMP AX, BX  D. SUB AX, BX
 
- 考点：指令对标志位的影响（必考考点）；
- 解析：
- A. ADD：加法指令，影响ZF、CF、SF、OF等标志位（相加减都会修改标志位）；
- B. MOV：数据传送指令，仅将BX的值送入AX，不修改任何标志位（正确答案）；
- C. CMP：比较指令，本质是减法（AX-BX），不保存结果，但修改标志位；
- D. SUB：减法指令，影响标志位（同ADD）；
- 答案：B；
- 总结：影响标志位的指令：算术运算（ADD/SUB/MUL/DIV）、比较（CMP）、逻辑运算（AND/OR/XOR）、移位（SHL/SHR）；不影响标志位的指令：数据传送（MOV/PUSH/POP/XCHG）、取址（LEA）、自增自减（INC/DEC，不影响CF）。
 
例题2：下列指令中，用于串比较的是（ ）
 
A. MOVS  B. CMPS  C. SCAS  D. STOS
 
- 考点：串操作指令的功能（必考考点）；
- 解析：
- A. MOVS：串传送（复制串）；
- B. CMPS：串比较（比较两串）（正确答案）；
- C. SCAS：串扫描（查找指定字符）；
- D. STOS：串存储（写入串）；
- 答案：B；
- 总结：串指令功能口诀：“MOVS复制，CMPS比较，SCAS查找，LODS读取，STOS写入”。
 
二、填空题（历年高频，逐题解析）
 
例题1：中断向量表的地址范围是________，中断向量地址的计算公式是________。
 
- 考点：中断向量表的概念（必考考点）；
- 解析：
- 中断向量表是内存0000H~003FFH的区域（共1024字节，256个中断类型码，每个中断占4字节）；
- 中断向量地址=中断类型码×4（8位中断类型码×4=16位地址，指向中断服务程序入口地址）；
- 答案：0000H~003FFH；中断向量地址=中断类型码×4；
 
例题2：LOOP指令的循环次数由________寄存器决定，执行LOOP指令时，首先将该寄存器________，然后判断其是否为0，若不为0则循环。
 
- 考点：LOOP循环指令的原理（必考考点）；
- 解析：
- LOOP指令是计数循环，依赖CX寄存器（循环计数器）；
- LOOP执行步骤：① CX=CX-1（自减1）；② 判断CX是否为0→ 不为0则跳转到标号处循环；
- 答案：CX；自减1（或CX=CX-1）；
 
三、简答题（历年高频，逐题解析）
 
例题1：简述中断处理的完整过程（8步）。
 
- 考点：中断处理过程（必考简答题，分值5~8分）；
- 答案（逐步，按考试评分标准）：
1. 中断请求：中断源（如键盘）向CPU发送中断请求信号；
2. 中断响应：CPU执行完当前指令后，检测到中断请求，若开中断（IF=1）则响应；
3. 保护断点：将当前程序的断点地址（CS:IP）压入堆栈（先压CS，再压IP）；
4. 保护标志位：将FLAGS寄存器的值压入堆栈；
5. 关中断：CPU自动将IF=0，禁止其他中断干扰；
6. 查找中断向量：根据中断类型码计算中断向量地址（中断类型码×4），读取中断服务程序入口地址（CS:IP）；
7. 执行中断服务程序：将入口地址送入CS:IP，转去执行中断服务程序；
8. 中断返回：执行IRET指令，弹出FLAGS→ 弹出IP→ 弹出CS，返回原程序继续执行；
- 评分标准：每步1分，顺序错误扣0.5分，遗漏“保护标志位”“关中断”等关键步骤扣1分。
 
四、编程题（历年大题，逐题解析，含代码+步骤）
 
例题1：用汇编语言编写程序，实现“计算1~10的累加和，将结果存入内存单元SUM（双字节）”（要求用循环结构，子程序实现累加）。
 
- 考点：循环结构+子程序+内存单元存储（必考大题，分值10~15分）；
- 解题步骤（按考试评分标准）：
1. 定义数据段：定义双字节内存单元SUM（存储累加和）；
2. 定义代码段：主程序初始化DS，调用累加子程序，将结果存入SUM；
3. 编写累加子程序：用LOOP循环实现1~10的累加，参数用寄存器传递；
4. 程序退出：用DOS中断INT 21H 4CH正常退出；
- 完整代码（逐句标注考点）：
 
asm
  

DATA SEGMENT
SUM DW 0       ; 定义双字节内存单元SUM（存储累加和，初始为0）【考点：内存单元定义】
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA

; 主程序【考点：顺序结构+子程序调用】
START:
MOV AX, DATA
MOV DS, AX       ; 初始化DS（指向数据段，访问SUM）【考点：数据段初始化】
MOV CX, 10       ; CX=10（循环次数=10，1~10）【考点：循环计数器初始化】
MOV AX, 0        ; AX=0（累加器初始化为0）【考点：累加器初始化】
CALL ADD_SUB     ; 调用累加子程序【考点：子程序调用】
MOV SUM, AX      ; 将累加和AX存入SUM【考点：内存单元存储】
MOV AH, 4CH      ; 程序退出功能号【考点：DOS中断】
INT 21H          ; 调用DOS中断，正常退出

; 子程序：ADD_SUB（实现1~CX的累加，入口参数：CX=循环次数，AX=累加器初始值；出口参数：AX=累加和）【考点：子程序设计】
ADD_SUB PROC
PUSH CX          ; 保护现场（保存主程序的CX）【考点：现场保护】
PUSH BX          ; 保护现场（保存主程序的BX）
MOV BX, 1        ; BX=1（累加起始值，1~10）【考点：循环变量初始化】

ADD_LOOP:
ADD AX, BX       ; 累加：AX=AX+BX【考点：加法运算】
INC BX           ; BX自增1（循环变量修改，避免死循环）【考点：循环变量修改】
LOOP ADD_LOOP    ; 循环控制：CX自减1，CX≠0则循环【考点：LOOP循环指令】

POP BX           ; 恢复现场（与压栈顺序相反）【考点：现场恢复】
POP CX           ; 恢复现场
RET              ; 子程序返回【考点：RET指令】
ADD_SUB ENDP

CODE ENDS
END START        ; 程序结束【考点：程序入口定义】
 
 
- 执行结果：SUM=1+2+...+10=55（0037H，双字节存储为37H, 00H）；
- 评分标准：数据段定义（1分）、主程序初始化（2分）、子程序结构（2分）、循环结构（2分）、累加逻辑（2分）、现场保护/恢复（2分）、程序退出（1分）、注释清晰（1分），共13分。
 
例题2：用汇编语言编写程序，实现“从键盘输入一个字符串（最多10个字符），统计其中大写字母的个数，将结果显示在屏幕上”（要求用串操作+分支结构）。
 
- 考点：串操作+DOS中断+分支+循环（综合大题，分值15~20分）；
- 解题步骤：
1. 定义数据段：定义输入缓冲区（最多10个字符）、统计计数器（初始为0）；
2. 主程序：初始化DS/ES，调用DOS中断输入字符串，初始化串操作寄存器（SI=缓冲区地址，CX=字符串长度）；
3. 循环统计：用串操作指令读取每个字符，判断是否为大写字母（41H~5AH），若是则计数器加1；
4. 显示结果：将计数器的值转换为ASCII码（加30H），用DOS中断显示；
5. 程序退出；
- 完整代码（逐句标注考点）：
 
asm
  

DATA SEGMENT
BUF DB 11, ?, 11 DUP(0) ; 输入缓冲区：11=最大长度（最多10个字符），?=实际长度，11 DUP(0)=存储区【考点：字符串缓冲区定义】
COUNT DB 0              ; 统计计数器（大写字母个数，初始为0）【考点：计数器定义】
DATA ENDS

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, ES:DATA

START:
; 步骤1：初始化数据段DS和附加段ES（串操作需要ES:DI）【考点：串操作前提】
MOV AX, DATA
MOV DS, AX
MOV ES, AX

; 步骤2：从键盘输入字符串（DOS中断INT 21H 0AH）【考点：DOS中断输入字符串】
MOV AH, 0AH
MOV DX, OFFSET BUF      ; DX=缓冲区偏移地址
INT 21H

; 步骤3：初始化串操作寄存器（SI=缓冲区存储区起始地址，CX=实际输入长度）【考点：串操作寄存器初始化】
MOV SI, OFFSET BUF+2    ; SI=BUF+2（存储区起始地址，BUF+0=最大长度，BUF+1=实际长度）
MOV CL, BUF+1           ; CL=实际输入长度（字符个数）
MOV CH, 0               ; CX=CL（串长度，循环次数）
MOV COUNT, 0            ; 计数器初始化为0

; 步骤4：循环统计大写字母个数（串操作+分支+循环）【考点：串操作+分支+循环】
CLD                     ; 清DF=0（串操作正向，SI递增）【考点：DF方向控制】
COUNT_LOOP:
LODSB                   ; 读取当前字符到AL（SI自动递增1）【考点：LODS串装入指令】
; 判断是否为大写字母（41H~5AH）【考点：分支结构】
CMP AL, 41H
JB NEXT_CHAR            ; AL<41H→ 不是大写字母，跳至NEXT_CHAR
CMP AL, 5AH
JA NEXT_CHAR            ; AL>5AH→ 不是大写字母，跳至NEXT_CHAR
; 是大写字母，计数器加1【考点：计数器修改】
INC COUNT

NEXT_CHAR:
LOOP COUNT_LOOP         ; 循环控制：CX自减1，CX≠0则继续统计【考点：LOOP循环】

; 步骤5：显示统计结果（将COUNT转换为ASCII码，DOS中断INT 21H 02H）【考点：DOS中断显示】
MOV AH, 02H
MOV DL, COUNT           ; DL=计数器值（0~10）
ADD DL, 30H             ; 转换为ASCII码（0→30H='0'，1→31H='1'）【考点：ASCII码转换】
INT 21H

; 步骤6：程序退出【考点：程序退出】
MOV AH, 4CH
INT 21H

CODE ENDS
END START
 
 
- 执行结果：若输入“AbC12DEF”（实际长度7），则大写字母个数为4（A、C、D、E、F？修正：A、C、D、E、F共5个，COUNT=5，显示'5'）；
- 评分标准：数据段定义（2分）、串操作初始化（2分）、字符串输入（2分）、循环统计（3分）、大写字母判断（2分）、ASCII码转换（2分）、结果显示（2分）、程序退出（1分）、注释清晰（1分），共17分。
 
第9页：汇编语言复习冲刺（易错点+避坑指南+背诵清单）
 
一、终极易错点清单（考试高频丢分点，逐点规避）
 
1. 指令格式错误：
- 错误： MOV AX, BL （AX是16位，BL是8位，位数不匹配）； JMP LABEL （LABEL后漏写冒号）；
- 规避：① 指令中寄存器位数必须一致（16位对16位，8位对8位）；② 标号后必须加冒号（如 LOOP_LABEL: ）；③ 立即数不能直接送入段寄存器（如 MOV DS, 1000H 错误，需 MOV AX, 1000H；MOV DS, AX ）。
2. 标志位判断错误：
- 错误：用JA判断有符号数“大于”（JA是无符号数，有符号数用JG）；CMP后直接用Jxx，未考虑数据类型；
- 规避：① 先判断数据类型（无符号数用JA/JB/JAE/JBE，有符号数用JG/JL/JGE/JLE）；② 记住标志位判断条件（ZF=1等于，CF=1无符号数小于，SF≠OF有符号数小于）。
3. 串操作前提遗漏：
- 错误：串操作前未初始化ES（目的串必须在ES段）；未设置CX（串长度）；未控制DF（方向标志）；
- 规避：串操作前必须执行“初始化DS/ES→ 设置SI/DI→ 赋值CX→ CLD/STD”（固定模板）。
4. 子程序现场保护错误：
- 错误：子程序修改了主程序的寄存器（如AX），未保存/恢复； PUSH 与 POP 顺序相同；
- 规避：① 子程序开头 PUSH 所有要使用的寄存器；② 结尾 POP 顺序与 PUSH 相反；③ 若寄存器作为返回结果，不保存该寄存器。
5. 中断服务程序错误：
- 错误：用RET代替IRET返回；未初始化DS；忘记保护DS/ES；
- 规避：① 中断服务程序必须用IRET返回；② 开头初始化DS（ MOV AX, DATA；MOV DS, AX ）；③ 保护现场时必须 PUSH DS；PUSH ES 。
6. 程序退出遗漏：
- 错误：程序末尾未加 MOV AH, 4CH；INT 21H ；
- 规避：所有程序（除中断服务程序）末尾必须加程序退出代码（固定模板，否则程序无法正常退出）。
 
二、考试答题技巧（大题高分指南）
 
1. 选择题：优先用“排除法”（如不影响标志位的指令，排除ADD/CMP/SUB，选MOV）；记住高频考点口诀（如串指令功能、中断向量地址公式）。
2. 填空题：牢记固定答案（如中断向量表地址范围、LOOP依赖CX、中断返回用IRET），避免错别字（如“IRET”写成“RET”，“CX”写成“CX寄存器”）。
3. 简答题：按“步骤化”答题（如中断处理过程分8步，每步1分），用专业术语（如“保护断点”“查找中断向量”“现场保护”），避免口语化。
4. 编程题：
- 步骤1：先写“数据段”（定义内存单元、字符串、计数器）；
- 步骤2：写“代码段”开头（ASSUME CS:CODE, DS:DATA）；
- 步骤3：主程序初始化（DS/ES）；
- 步骤4：核心逻辑（顺序/分支/循环/子程序）；
- 步骤5：程序退出（固定模板）；
- 步骤6：加详细注释（标注考点，如【考点：循环结构】），即使代码有小错误，注释也能得分。
 
三、终极背诵清单（考前1小时必背）
 
1. 核心公式（必考）
 
- 中断向量地址 = 中断类型码 × 4；
- 串操作地址递增：SI=SI+n，DI=DI+n（n=1字节，2字，4双字）；
- ASCII码转换：数字（0~9）→ ASCII码（30H~39H）；大写字母→ 小写字母（+20H）；
- 循环次数：LOOP循环次数 = CX初始值；
 
2. 固定模板（大题直接套用）
 
- 数据段定义：
asm
  

DATA SEGMENT
变量名 类型 初始值 ; 如：SUM DW 0；STR DB 'Hello$'；BUF DB 10, ?, 10 DUP(0)
DATA ENDS
 
- 代码段开头：
asm
  

CODE SEGMENT
ASSUME CS:CODE, DS:DATA, ES:DATA
START:
MOV AX, DATA
MOV DS, AX
MOV ES, AX
 
- 程序退出：
asm
  

MOV AH, 4CH
INT 21H
CODE ENDS
END START
 
- 子程序结构：
asm
  

子程序名 PROC
PUSH 寄存器1
PUSH 寄存器2
; 核心逻辑
POP 寄存器2
POP 寄存器1
RET
子程序名 ENDP
 
- 中断服务程序结构：
asm
  

中断服务程序名 PROC
PUSH AX
PUSH BX
PUSH DS
STI
; 核心逻辑
CLI
POP DS
POP BX
POP AX
IRET
中断服务程序名 ENDP
 
 
3. 高频指令功能（必背）
 
指令 功能 关键注意事项 
MOV AX, BX 将BX的值送入AX 位数必须一致 
CMP AX, BX 比较AX和BX（AX-BX） 不保存结果，修改标志位 
JG LABEL 有符号数AX>BX则跳转 依赖SF=0且OF=0且ZF=0 
JA LABEL 无符号数AX>BX则跳转 依赖CF=0且ZF=0 
LOOP LABEL CX自减1，CX≠0则循环 循环次数=CX初始值 
CALL SUB1 调用子程序SUB1 压入返回地址 
RET 子程序返回 弹出返回地址 
IRET 中断返回 弹出FLAGS、IP、CS 
INT 21H DOS中断 AH=功能号，设置入口参数 
MOVSB 字节串传送 DS:SI→ES:DI，SI/DI递增1 
CMPSB 字节串比较 DS:SI - ES:DI，修改标志位 
SCASB 字节串扫描 AL - ES:DI，修改标志位 
 
四、考前提醒（必看）
 
1. 汇编程序严格区分大小写（如 MOV 不能写成 mov ， AX 不能写成 ax ）；
2. 指令之间用分号分隔注释（如 MOV AX, 0 ; 累加器初始化 ），注释清晰能加分；
3. 编程题若不会写完整代码，先写“数据段+主程序初始化+程序退出”（基础分到手），再写核心逻辑的部分代码；
4. 选择题和填空题先做，再做简答题和编程题，合理分配时间（编程题建议留30~40分钟）。
