# 操作系统期末考点总结（完整版）

## 一、操作系统概述

### 1. 操作系统特征



* **并发性**：多个程序在同一时间间隔内运行

* **共享性**：系统资源可供多个并发进程共同使用

* **虚拟性**：通过虚拟技术将物理资源转换为逻辑上的多倍资源

* **异步性**：进程以不可预知的速度向前推进

### 2. 内核态与用户态



* **内核态**：操作系统内核运行的状态，具有最高特权级

* **用户态**：用户程序运行的状态，特权级较低

* **指令区分**：特权指令只能在内核态执行，普通指令可在用户态执行

### 3. 中断与异常



* **中断**：外部事件引起的中断，如 I/O 完成中断

* **异常**：内部事件引起的中断，如指令错误、缺页异常

* **处理流程**：中断请求→中断响应→中断处理→中断返回

## 二、内存管理

### 1. 内存分配方式

#### 连续分配



* **单一连续分配**：整个内存分为系统区和用户区，用户区只能装入一个进程

* **固定分区**：内存划分为若干固定大小的分区，每个分区装入一个进程

* **动态分区**：根据进程大小动态分配内存空间

* **可重定位分区**：通过紧凑技术合并碎片，提高内存利用率

#### 非连续分配

##### 分页存储管理



* **基本原理**：将进程逻辑地址空间划分为固定大小的页，物理内存划分为相同大小的页框

* **地址结构**：逻辑地址 = 页号 + 页内偏移量

* **页表**：记录页号到物理块号的映射关系

* **地址转换过程**：

1. 计算页号 = 逻辑地址 / 页面大小

2. 计算页内偏移 = 逻辑地址 % 页面大小

3. 查页表得到物理块号

4. 物理地址 = 物理块号 × 页面大小 + 页内偏移

**例题 1**：某系统页面大小为 4KB，逻辑地址为 32 位，其中页号占 20 位，页内偏移占 12 位。若页表中页号 2 对应的物理块号为 10，求逻辑地址 0x20008 对应的物理地址。

**解答**：



* 页号 = 0x20008 >> 12 = 0x2

* 页内偏移 = 0x20008 & 0xFFF = 0x8

* 物理地址 = 10 × 4KB + 8 = 0xA0008

##### 分段存储管理



* **基本原理**：按程序的逻辑结构划分段，每个段有自己的段号和段内偏移

* **地址结构**：二维地址（段号，段内偏移）

* **段表**：记录段号、段长、段的起始地址

##### 段页式存储管理



* **结合分页和分段的优点**：先分段，再分页

* **地址结构**：段号 + 页号 + 页内偏移

* **地址转换**：需要查段表和页表，访问内存次数较多

### 2. 虚拟内存

#### 基本概念



* **局部性原理**：程序执行时，在一段时间内，指令的执行和数据的访问往往集中在一定的范围内

* **虚拟内存**：基于局部性原理，在内存和外存之间进行页面交换，使程序可以在较小的内存空间中运行

#### 请求分页系统



* **缺页中断**：当访问的页面不在内存时产生的中断

* **页面置换算法**：

**OPT（最佳置换算法）**



* 选择未来最长时间内不会被访问的页面置换

* 理论最优，但无法实现

**FIFO（先进先出算法）**



* 选择最先进入内存的页面置换

* 可能出现 Belady 异常：分配的物理块数增加，缺页率反而上升

**LRU（最近最少使用算法）**



* 选择最近最少使用的页面置换

* 基于程序的局部性原理，实际效果较好

**CLOCK（时钟算法）**



* 改进的 LRU 算法，通过访问位实现

* 维护一个循环链表，当需要置换时，从当前位置开始扫描，遇到访问位为 0 的页面置换

**CLOCK + 算法**



* 引入修改位，优先置换 "未访问 + 未修改" 的页面

* 减少磁盘 I/O 次数，提高效率

**例题 2**：某进程分配 3 个物理块，页面访问序列为 7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1。分别用 FIFO 和 LRU 算法计算缺页次数。

**解答**：



* FIFO：缺页次数 = 12 次（出现 Belady 异常）

* LRU：缺页次数 = 9 次

### 3. 快表与多级页表

#### 快表（TLB）



* **基本概念**：Translation Lookaside Buffer，硬件支持的高速缓存

* **有效访问时间（EAT）计算**：


  * EAT = 命中率 × (快表访问时间 + 内存访问时间) + (1 - 命中率) × (快表访问时间 + 内存访问时间 × 2)

**例题 3**：假设快表访问时间为 20ns，内存访问时间为 100ns，快表命中率为 90%，求有效访问时间。

**解答**：



* EAT = 0.9 × (20 + 100) + 0.1 × (20 + 100 × 2) = 0.9 × 120 + 0.1 × 220 = 108 + 22 = 130ns

#### 多级页表



* **基本原理**：将页表也进行分页，形成多级结构

* **访问次数**：


  * 快表命中：访问 1 次内存

  * 快表未命中：访问 3 次内存（页目录表 + 页表 + 物理内存）

  * 缺页：访问更多次（需要从磁盘读取页面）

### 4. 抖动和工作集

#### 抖动（Thrashing）



* **定义**：进程在运行中频繁发生页面换入换出的现象

* **根本原因**：分配给进程的驻留集过小，无法满足进程当前工作集需求

* **后果**：CPU 利用率急剧下降，系统吞吐量严重降低

#### 工作集（Working Set）



* **定义**：进程在最近一段时间间隔内频繁访问的页面集合

* **工作集窗口**：时间间隔长度

* **工作集 W (t, Δ)**：在时刻 t，窗口 Δ 内访问的页面集合

* **意义**：驻留集大小必须≥工作集大小，否则会导致频繁缺页

## 三、进程管理

### 1. 进程状态转换

#### 三种基本状态



* **就绪状态**：进程已获得除 CPU 外的所有必要资源，等待调度

* **执行状态**：进程正在 CPU 上运行

* **阻塞状态**：进程因等待某一事件而暂停执行

#### 状态转换条件



* **就绪→执行**：进程被调度程序选中

* **执行→就绪**：时间片用完或被高优先级进程抢占

* **执行→阻塞**：进程等待某事件（如 I/O 操作）

* **阻塞→就绪**：等待的事件发生

**例题 4**：操作系统低优先级进程被高优先级进程抢占或者时间片用光，由执行态变为（ ）状态。

A. 就绪 B. 挂起 C. 睡眠 D. 阻塞

**解答**：A. 就绪

### 2. PV 操作

#### 基本概念



* **信号量**：用于实现进程同步和互斥的变量

* **P 操作**：申请资源，信号量减 1，若结果小于 0 则阻塞

* **V 操作**：释放资源，信号量加 1，若结果大于等于 0 则唤醒一个阻塞进程

#### 两类信号量



* **互斥信号量**：初值为 1，用于实现进程互斥

* **同步信号量**：初值为 0，用于实现进程同步

#### 经典同步问题

**生产者 - 消费者问题**



```
// 信号量定义

semaphore mutex = 1;    // 互斥信号量，保护临界区

semaphore empty = N;    // 同步信号量，表示空缓冲区数量

semaphore full = 0;     // 同步信号量，表示满缓冲区数量

// 生产者进程

producer() {

&#x20;   while(1) {

&#x20;       produce\_item();

&#x20;       P(empty);       // 申请空缓冲区

&#x20;       P(mutex);       // 进入临界区

&#x20;       add\_item\_to\_buffer();

&#x20;       V(mutex);       // 离开临界区

&#x20;       V(full);        // 增加满缓冲区数量

&#x20;   }

}

// 消费者进程

consumer() {

&#x20;   while(1) {

&#x20;       P(full);        // 申请满缓冲区

&#x20;       P(mutex);       // 进入临界区

&#x20;       remove\_item\_from\_buffer();

&#x20;       V(mutex);       // 离开临界区

&#x20;       V(empty);       // 增加空缓冲区数量

&#x20;       consume\_item();

&#x20;   }

}
```

**读者 - 写者问题**



```
// 信号量定义

semaphore rw\_mutex = 1; // 读写互斥信号量

semaphore mutex = 1;    // 保护read\_count的互斥信号量

int read\_count = 0;     // 读者计数器

// 读者进程

reader() {

&#x20;   while(1) {

&#x20;       P(mutex);       // 保护read\_count

&#x20;       read\_count++;

&#x20;       if(read\_count == 1) {

&#x20;           P(rw\_mutex); // 第一个读者申请写锁

&#x20;       }

&#x20;       V(mutex);       // 释放read\_count保护

&#x20;      &#x20;

&#x20;       read\_data();    // 读操作

&#x20;      &#x20;

&#x20;       P(mutex);       // 保护read\_count

&#x20;       read\_count--;

&#x20;       if(read\_count == 0) {

&#x20;           V(rw\_mutex); // 最后一个读者释放写锁

&#x20;       }

&#x20;       V(mutex);       // 释放read\_count保护

&#x20;   }

}

// 写者进程

writer() {

&#x20;   while(1) {

&#x20;       P(rw\_mutex);    // 申请写锁

&#x20;       write\_data();   // 写操作

&#x20;       V(rw\_mutex);    // 释放写锁

&#x20;   }

}
```

**吸烟者问题**



```
// 信号量定义

semaphore tobacco = 0;  // 烟草和纸

semaphore paper = 0;    // 烟草和火柴

semaphore match = 0;    // 纸和火柴

semaphore agent = 1;    // 代理商信号量

// 吸烟者1（有烟草）

smoker1() {

&#x20;   while(1) {

&#x20;       P(paper);       // 等待纸和火柴

&#x20;       make\_cigarette();

&#x20;       smoke();

&#x20;       V(agent);       // 通知代理商

&#x20;   }

}

// 吸烟者2（有纸）

smoker2() {

&#x20;   while(1) {

&#x20;       P(match);       // 等待烟草和火柴

&#x20;       make\_cigarette();

&#x20;       smoke();

&#x20;       V(agent);       // 通知代理商

&#x20;   }

}

// 吸烟者3（有火柴）

smoker3() {

&#x20;   while(1) {

&#x20;       P(tobacco);     // 等待烟草和纸

&#x20;       make\_cigarette();

&#x20;       smoke();

&#x20;       V(agent);       // 通知代理商

&#x20;   }

}

// 代理商进程

agent() {

&#x20;   while(1) {

&#x20;       P(agent);       // 等待吸烟者通知

&#x20;       int random = rand() % 3;

&#x20;       if(random == 0) {

&#x20;           V(tobacco); // 提供烟草和纸

&#x20;       } else if(random == 1) {

&#x20;           V(paper);   // 提供烟草和火柴

&#x20;       } else {

&#x20;           V(match);   // 提供纸和火柴

&#x20;       }

&#x20;   }

}
```

**哲学家进餐问题**



```
// 信号量定义

semaphore chopstick\[5] = {1, 1, 1, 1, 1}; // 筷子信号量

semaphore room = 4;                       // 最多4个哲学家同时进餐

// 哲学家i进程

philosopher(int i) {

&#x20;   while(1) {

&#x20;       think();

&#x20;       P(room);         // 进入房间

&#x20;       P(chopstick\[i]); // 拿左边筷子

&#x20;       P(chopstick\[(i+1)%5]); // 拿右边筷子

&#x20;       eat();

&#x20;       V(chopstick\[i]); // 放左边筷子

&#x20;       V(chopstick\[(i+1)%5]); // 放右边筷子

&#x20;       V(room);         // 离开房间

&#x20;   }

}
```

**例题 5**：进程 P1、P2、P3、P4、P5 的前驱图如下。若用 PV 操作控制进程并发执行的过程，则需要相应于进程执行过程设置 5 个信号量 S1、S2、S3、S4 和 S5，且信号量初值都等于零。下图中 a 处应填写（ ）；b 和 c、d 和 e 处应分别填写（ ），f、g 和 h 应分别填写（ ）。

**解答**：



* a 处：V (S1) 和 V (S2)

* b 和 c：P (S1) 和 V (S3)

* d 和 e：P (S2) 和 V (S4)

* f、g 和 h：P (S3)、P (S4) 和 V (S5)

## 四、I/O 管理

### 1. I/O 软件层次结构

#### 层次模型



1. **用户层程序**：系统调用、SPOOLing 技术

2. **上接口**：提供给用户的接口

3. **独立性软件**：逻辑物理地址转换、四张表（DCT、COCT、CHCT、SDT）

4. **驱动程序**：设备驱动一对一

5. **中断处理程序**：处理 I/O 中断

6. **下接口**：与硬件的接口

7. **设备控制器**：设备和设备控制一对多

8. **设备**：具体的 I/O 设备

#### 中断处理



* **中断类型**：


  * 中断：外部事件引起，允许嵌套

  * 异常：内部事件引起，部分不允许嵌套

* **处理流程**：中断请求→中断响应→中断处理→中断返回

### 2. 缓冲技术

#### 引入缓冲的原因



* 缓和 CPU 与 I/O 设备速度不匹配的矛盾

* 减少对 CPU 的中断频率

* 提高 CPU 和 I/O 设备的并行性

#### 缓冲类型



* **单缓冲**：一个缓冲区

* **双缓冲**：两个缓冲区，可实现并行操作

* **循环缓冲**：多个缓冲区组成循环队列

* **缓冲池**：多个缓冲区组成的缓冲池

### 3. SPOOLing 技术



* **基本概念**：Simultaneous Peripheral Operations On-Line，假脱机技术

* **工作原理**：将独占设备虚拟化为共享设备

* **组成部分**：输入井、输出井、输入缓冲区、输出缓冲区、输入进程、输出进程

* **应用**：共享打印技术

### 4. 磁盘调度算法

#### 基本概念



* **寻道时间**：磁头移动到指定磁道的时间

* **旋转延迟**：等待指定扇区旋转到磁头位置的时间

* **传输时间**：数据从磁盘传输到内存的时间

#### 常见调度算法

**FCFS（先来先服务）**



* 按请求到达的顺序处理

* 公平但效率低

**SSTF（最短寻道时间优先）**



* 选择离当前磁头位置最近的请求处理

* 平均寻道时间短，但可能导致饥饿

**SCAN（扫描算法 / 电梯算法）**



* 磁头向一个方向移动，处理所有经过的请求，到达边界后反向

* 避免饥饿，性能较好

**LOOK 算法**



* 改进的 SCAN 算法，磁头移动到最远的请求位置后反向

* 不需要到达物理边界，减少无效移动

**C-SCAN（循环扫描算法）**



* 磁头向一个方向移动，处理所有经过的请求，到达边界后直接返回起点

* 响应时间更均匀

**C-LOOK 算法**



* 改进的 C-SCAN 算法，磁头移动到最远的请求位置后直接返回起点

* 不需要到达物理边界

**例题 6**：磁盘请求的柱面访问序列为 98,183,37,122,14,124,65,67，磁头起始位置为 53。分别用 FCFS、SSTF、SCAN 算法计算总寻道长度。

**解答**：



* FCFS：总寻道长度 = 640

* SSTF：总寻道长度 = 236

* SCAN：总寻道长度 = 300

## 五、文件管理

### 1. 文件的逻辑结构

#### 顺序文件



* 记录按顺序存储

* 定长记录支持随机存取，可变长记录只能顺序查找

#### 索引文件



* 为文件建立索引表，记录与索引项一一对应

* 支持随机存取与快速增删

#### 索引顺序文件



* 结合顺序文件与索引的优势

* 记录分组后建索引，适合大型文件

### 2. 文件的物理结构

#### 顺序分配



* 为文件分配连续磁盘块

* 顺序存取快，支持随机访问，但产生碎片

#### 链接分配



* **隐式链接**：磁盘块用指针串联，仅记录起始块

* **显式链接（FAT）**：用文件分配表记录块的链接关系

#### 索引分配



* 为文件建索引表，记录块的位置

* 支持随机访问与拓展，但索引表占用空间

### 3. 文件目录结构

#### 单级目录



* 简单但不支持重名，无分类

#### 两级目录



* 支持用户级重名，但无法分类

#### 多级（树形）目录



* 支持分类与重名

* 通过绝对路径和相对路径定位文件

#### 无环图目录



* 树形结构基础上增加共享链接

* 实现文件共享，解决共享时的删除问题

### 4. 文件存储空间管理

#### 空闲表法



* 记录连续空闲区，分配用首次适应、最佳适应等算法

* 回收需合并相邻空闲区

#### 空闲链表法



* 按盘块 / 盘区为单位链空闲块

* 分配从链头取，回收挂到链尾

#### 位示图法



* 用二进制位映射盘块状态（0 = 空闲，1 = 占用）

* 需掌握 "盘块号↔字号、位号" 的转换公式

#### 成组链接法



* UNIX 采用，适合大型文件系统

* 平衡空间与效率

## 六、死锁处理

### 1. 死锁的必要条件



* **互斥条件**：资源只能被一个进程使用

* **请求和保持条件**：进程已保持至少一个资源，又请求其他资源

* **不可剥夺条件**：资源只能被进程主动释放

* **循环等待条件**：进程之间形成资源请求循环

### 2. 银行家算法

#### 基本思想



* 将操作系统比作银行家，进程比作客户，资源比作贷款额度

* 分配资源前检查系统是否处于安全状态

* 安全状态：存在进程执行顺序，使所有进程均能获得最大资源需求并完成

#### 数据结构



* **可用资源向量 Available**：系统中各类资源的可用数量

* **最大需求矩阵 Max**：每个进程对各类资源的最大需求

* **分配矩阵 Allocation**：每个进程已获得的各类资源数量

* **需求矩阵 Need**：每个进程还需要的各类资源数量（Need = Max - Allocation）

#### 算法步骤



1. **请求检查**：如果 Request ≤ Need 且 Request ≤ Available，转步骤 2

2. **模拟分配**：

* Available = Available - Request

* Allocation = Allocation + Request

* Need = Need - Request

1. **安全性检查**：检查系统是否处于安全状态

* 找到一个进程 Pi，使得 Need ≤ Work（Work 初始为 Available）

* Work = Work + Allocation

* 重复直到所有进程都完成或无法继续

1. **结果处理**：如果安全则实际分配，否则撤销模拟分配

**例题 7**：系统有 3 类资源 A (10)、B (5)、C (7)，进程 P0-P4 的最大需求和已分配资源如下表所示。



| 进程 | Max(A,B,C) | Allocation(A,B,C) | Need(A,B,C) |
| -- | ---------- | ----------------- | ----------- |
| P0 | 7,5,3      | 0,1,0             | 7,4,3       |
| P1 | 3,2,2      | 2,0,0             | 1,2,2       |
| P2 | 9,0,2      | 3,0,2             | 6,0,0       |
| P3 | 2,2,2      | 2,1,1             | 0,1,1       |
| P4 | 4,3,3      | 0,0,2             | 4,3,1       |

当前可用资源 Available=(3,3,2)。若进程 P1 发出请求 Request (1,0,2)，系统能否同意该请求？

**解答**：



1. **请求检查**：Request (1,0,2) ≤ Need (1,2,2) 且 Request (1,0,2) ≤ Available (3,3,2)，满足条件

2. **模拟分配**：

* Available = (3,3,2) - (1,0,2) = (2,3,0)

* Allocation\[P1] = (2,0,0) + (1,0,2) = (3,0,2)

* Need\[P1] = (1,2,2) - (1,0,2) = (0,2,0)

1. **安全性检查**：

* Work = (2,3,0)

* 找到 P1：Need (0,2,0) ≤ Work，Work = (2,3,0) + (3,0,2) = (5,3,2)

* 找到 P3：Need (0,1,1) ≤ Work，Work = (5,3,2) + (2,1,1) = (7,4,3)

* 找到 P4：Need (4,3,1) ≤ Work，Work = (7,4,3) + (0,0,2) = (7,4,5)

* 找到 P0：Need (7,4,3) ≤ Work，Work = (7,4,5) + (0,1,0) = (7,5,5)

* 找到 P2：Need (6,0,0) ≤ Work，所有进程完成

1. **结论**：系统处于安全状态，可以同意请求

## 七、重要考点总结

### 内存管理



* 分页地址转换计算

* 页面置换算法（FIFO、LRU、OPT、CLOCK、CLOCK+）

* 快表有效访问时间计算

* 抖动和工作集概念

* 多级页表访问次数计算

### 进程管理



* 进程状态转换条件

* PV 操作实现进程同步互斥

* 经典同步问题（生产者 - 消费者、读者 - 写者、吸烟者、哲学家）

### I/O 管理



* I/O 软件层次结构

* SPOOLing 技术原理

* 磁盘调度算法（FCFS、SSTF、SCAN、LOOK、C-SCAN、C-LOOK）

* 总寻道长度计算

### 文件管理



* 文件逻辑结构和物理结构

* 文件目录结构

* 文件存储空间管理方法

### 死锁处理



* 死锁的必要条件

* 银行家算法安全性检查

## 八、答题技巧



1. **概念题**：准确理解基本概念，注意区分相似概念

2. **计算题**：掌握计算方法，注意单位和公式

* 分页地址转换

* 快表有效访问时间

* 缺页率计算

* 磁盘寻道长度计算

1. **应用题**：理解算法原理，能够画出状态转换图

* PV 操作实现同步互斥

* 页面置换过程模拟

* 磁盘调度过程模拟

1. **分析题**：结合实际场景，分析优缺点和适用范围

记住：操作系统是一门实践性很强的课程，理解原理比死记硬背更重要！

> （注：文档部分内容可能由 AI 生成）