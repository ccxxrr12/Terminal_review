## 一、网络程序设计基础（上）
### （一）核心概念：网络程序与单机程序的区别
| 维度 | 单机程序 | 网络程序 |
| --- | --- | --- |
| 架构与依赖 | 单体架构，所有代码和资源均在本地 | 异地交互（不同主机、OS、编程语言） |
| 数据存储与处理 | 本地化（硬盘存储，依赖本地CPU/内存） | 存储-处理异地（远程服务器存储/云端计算） |
| 调试与维护 | 单独进行 | 需多端协同配合 |
| 性能与响应 | 稳定高速（不受网络影响，依赖本地硬件） | 受网络影响大（延迟/丢包导致卡顿，依赖网络质量+服务器负载） |
| 安全性 | 防本地破解（风险：破解、逆向工程，用户负责数据安全） | 防网络攻击（风险：DDoS、注入、数据窃取，服务提供商负责数据安全） |

### （二）网络程序的特点与分类
1. **核心特点**：分布式（功能拆分到多机器，协同完成任务，对用户透明）、逻辑设计复杂（跨语言/系统交互、多模态数据操控）、调试分析困难（主机崩溃、网络失效、拥塞、资源过载）
2. **分类**：
   - 远程控制类应用程序
   - 网络探测类应用程序
   - 网络管理类应用程序
   - 远程通信类应用程序
   - 信息发布类应用程序

### （三）网络程序设计的基础问题及解决方案
| 基础问题 | 解决方案 |
| --- | --- |
| 如何拆解功能模块？ | 具体应用具体分析，按业务逻辑拆分核心功能（如数据传输、逻辑处理、存储交互） |
| 如何标识通信主体？ | TCP/IP协议族中通过“IP地址（网络层，全球唯一）+端口号（传输层，主机内唯一）+物理地址（网络接口层）”唯一标识；结合NAT（网络地址转换）、域名解析（DNS/Hosts）、NetBIOS解析（Lmhosts/WINS）处理复杂场景 |
| 使用哪个层次的协议传输数据？ | 基于TCP/IP四层模型选择：应用层（HTTP/FTP）、传输层（TCP/UDP）、网络层（IP）、网络接口层；编程接口可选择套接字（流式/数据报/原始）、原始网卡编程（nPcap/DPDK）等 |
| 如何实现通信双方的收发同步？ | 基于通信模型（C/S/P2P）设计交互逻辑，结合协议约定（如请求-响应机制、心跳包） |
| 如何封装/解析数据包？ | 按协议规范定义报文格式（首部+数据），封装时添加协议字段，解析时按格式提取内容 |
| 如何保证传输可靠性？ | 选择TCP协议（面向连接、重传、流量控制），应用层添加校验和、确认机制 |
| 如何提高传输效率？ | 选择UDP协议（无连接、低开销），使用缓存（CDN）、负载均衡、数据压缩 |
| 如何处理多通道数据收发？ | 采用I/O复用模型（select/事件选择/重叠I/O/完成端口）、多线程/多进程 |
| 如何处理故障？ | 添加错误检测（超时重传、心跳检测）、故障转移（多服务器冗余） |

### （四）IP地址分类与域名解析
1. **IP地址分类**：
   - A类地址：首位0，网络地址占7位，主机地址占24位
   - B类地址：前两位10，网络地址占14位，主机地址占16位
   - C类地址：前三位110，网络地址占21位，主机地址占8位
   - D类地址：前四位1110，用于组播
   - E类地址：前四位1111，保留备用
2. **域名解析**：将域名转换为IP地址，通过Hosts文件（本地）或DNS服务器（网络）实现
3. **NetBIOS解析**：将NetBIOS名称映射为IP地址，通过Lmhosts文件或WINS服务器实现，适用于局域网文件/打印机共享、网络发现

### （五）网络程序基本通信模型
1. **核心问题：会聚点问题**
   - 问题描述：通信双方同时启动时，无明确连接目标，导致无法建立通信
   - 解决方案：客户-服务器（C/S）模型（一方启动后持续等待对方连接）
2. **客户-服务器（C/S）模型**
   - 客户端特征：主动角色、发送请求、接收响应并处理
   - 服务器特征：被动角色、等待请求、处理请求并返回结果
   - 关键关系：
     - 数量关系：1台服务器可对应多个客户端（10/1000/10万+），要求服务器具备高并发处理能力
     - 位置关系：同主机、同局域网、跨局域网，需考虑网络路由、NAT穿透
     - 角色关系：单服务器-多客户端、多服务器-多客户端，需设计分布式协作逻辑
3. **服务器的分类与特点**
   - 按连接方式：
     - 面向连接服务器（TCP）：适用于传输可靠性高、交换数据量大的场景（如Web服务器、文件服务器）
     - 无连接服务器（UDP）：适用于1对多通信、通信代价小的场景（如DNS服务器、视频服务器）
   - 按处理方式：
     - 循环服务器：同一时刻仅处理一个请求，适用于短期访问型客户端（T<1/KN，T为处理时间，K为客户数，N为每秒请求数）
     - 并发服务器：同一时刻处理多个请求，适用于长期访问型客户端（T>1/KN）
   - 按功能负载：
     - 瘦服务器：业务逻辑集中在客户端，服务器仅提供数据存储/访问，优点是客户端设计灵活，缺点是更新复杂、通信开销大
     - 胖服务器：业务逻辑集中在服务器，客户端仅负责用户交互，优点是升级容易、部署便捷、网络开销小，缺点是交互实时性弱

### （六）考核评价
- 作业报告：25%
- 单元实践考评+综合实践报告：25%
- 笔试：50%
- 额外：课前演讲考评

## 二、网络程序设计基础（下）
### （一）客户-服务器（C/S）模型的扩展
1. **传统C/S模型的不足**
   - 兼容性差：专用客户端需适配不同OS（Windows/CentOS/Ubuntu），阻碍推广
   - 维护困难：客户端版本更新需用户手动升级，维护成本高
   - 安全性难以保证：客户端执行逻辑功能和数据操作，易被逆向破解（如IDA Pro+x64dbg）
2. **浏览-服务器（B/S）模型**
   - 定义：基于万维网技术的特殊C/S模型，客户端为浏览器，通过HTTP/HTTPS协议与服务器通信
   - 优点：
     - 兼容性好：只要安装浏览器即可访问，无需专用客户端
     - 维护简单：仅需修改服务器端代码，用户随时访问最新功能
     - 安全性高：核心逻辑和数据操作对用户透明，避免客户端破解风险
   - 不足：服务器开发复杂，负载繁重（集中处理大量请求）
   - 三级结构优化：客户端（浏览器）→应用业务服务器→数据服务器，减轻应用服务器负载，提升可靠性和可维护性（如百度网盘：浏览器→应用服务器→数据库服务器）
3. **服务器性能与可用性优化**
   - 提升性能：
     - 垂直扩展（scale up）：增强单服务器硬件性能（CPU/内存/硬盘）
     - 水平扩展（scale out）：多服务器集群+负载均衡（分配请求，优化资源使用）
     - 缓存机制：CDN（内容分发网络）缓存静态资源，提高访问速度
   - 保证可用性：P2P模型（非中心化、健壮性强、可扩展性好、负载均衡），节点既是客户端也是服务器，避免单服务器瘫痪导致系统失效（如Napster、迅雷、比特币、Pbot僵尸网络）

### （二）网络编程接口设计要求
1. **核心作用**：作为应用程序与TCP/IP协议软件的交互桥梁，TCP/IP标准仅定义功能集，未规定接口细节
2. **位置**：位于应用层与传输层之间，屏蔽通信细节和硬件差异，提供统一调用接口
3. **设计原则**：
   - 兼容性强：避免依赖厂商内部数据表示和专属OS特征，支持多厂商环境
   - 功能完整：提供通信全生命周期操作（资源分配、端点指定、连接管理、数据收发、异常处理、资源释放）
4. **主流编程接口**：
   - Berkeley Socket：Berkeley UNIX的套接字接口（工业标准）
   - Transport Layer Interface（TLI）：AT&T System V的传输层接口
   - Windows Sockets（WinSock）：Windows系统的套接字接口，兼容Berkeley Socket

### （三）套接字（Socket）核心概念
1. **定义**：应用程序与远程进程数据传输的接口，是支持TCP/IP网络通信的基本操作单元，作为应用程序与协议实现的桥梁
2. **标识方式**：通过五元组（协议，本地地址，本地端口号，远地地址，远地端口号）唯一标识通信链路
3. **套接字类型**：
   - 流式套接字（SOCK_STREAM）：面向连接、可靠的字节流服务（基于TCP）
   - 数据报套接字（SOCK_DGRAM）：无连接、不可靠的数据报服务（基于UDP）
   - 原始套接字（SOCK_RAW）：直接访问底层协议（IP/ICMP），支持自定义数据包
4. **套接字结构**：包含描述符、发送/接收队列、状态、协议信息、端点地址等

### （四）网络编程接口函数设计
1. **设计思路**：
   - 扩展一般I/O原语：基于Linux文件I/O（open/close/read/write），扩展套接字描述符和网络操作功能
   - 设计新接口：如Windows Sockets，提供专用网络通信函数
2. **Windows Sockets 1.1库函数分类及核心功能**
| 函数类别 | 核心函数 | 功能描述 |
| --- | --- | --- |
| 套接字函数 | socket() | 创建套接字 |
|  | closesocket() | 关闭套接字，释放资源 |
|  | bind() | 绑定本地地址和端口 |
|  | getpeername() | 获取对等方地址和端口 |
|  | getsockname() | 获取自身关联的地址和端口 |
| 网络连接函数 | listen() | 监听外来连接 |
|  | connect() | 与远程主机建立连接 |
|  | accept() | 确认连接，创建数据套接字 |
|  | shutdown() | 关闭单方向连接 |
| 数据传输函数 | send() | 发送数据（已连接套接字） |
|  | sendto() | 发送数据（无连接套接字，需指定目标地址） |
|  | recv() | 接收数据（已连接套接字） |
|  | recvfrom() | 接收数据（无连接套接字，获取来源地址） |
| 字节顺序转换函数 | htonl() | 32位主机字节序→网络字节序 |
|  | htons() | 16位主机字节序→网络字节序 |
|  | ntohl() | 32位网络字节序→主机字节序 |
|  | ntohs() | 16位网络字节序→主机字节序 |
| 地址转换函数 | inet_addr() | 点分十进制字符串→整数IP |
|  | inet_ntoa() | 整数IP→点分十进制字符串 |
| 套接字控制函数 | getsockopt() | 获取套接字选项 |
|  | setsockopt() | 设置套接字选项 |
|  | ioctlsocket() | 控制套接字状态 |
|  | select() | 实现异步I/O，获取套接字状态 |
| 数据库函数 | gethostbyaddr()/gethostbyname() | 通过IP/主机名获取主机信息 |
|  | getprotobyname()/getprotobynumber() | 通过名称/编号获取协议信息 |
|  | getservbyname()/getservbyport() | 通过名称/端口获取服务信息 |
| Windows专有函数 | WSAStartup() | 初始化WinSock DLL |
|  | WSACleanup() | 终止WinSock DLL调用 |
|  | WSAGetLastError() | 获取错误码 |
|  | WSASetLastError() | 设置错误码 |

### （五）问题分析与解答
1. **问题1**：如何提升服务器的性能，为更多用户提供服务？
   - 解答：采用“垂直扩展+水平扩展+缓存优化”组合策略。垂直扩展增强单服务器硬件性能；水平扩展通过多服务器集群+负载均衡分配请求，避免单点过载；缓存机制（如CDN）缓存热点资源，减少服务器重复处理，提升响应速度。
2. **问题2**：当服务器被瘫痪后，如何确保系统仍能为用户提供服务？
   - 解答：采用P2P模型，节点无中心依赖，任意节点加入/退出不影响整体系统；同时设计服务器冗余备份，当主服务器瘫痪时，从服务器自动切换提供服务，结合故障检测（心跳包）实现快速故障转移。

## 三、流式套接字编程（上）
### （一）流式套接字的核心概念与适用场景
1. **定义**：基于TCP协议的套接字（SOCK_STREAM），提供面向连接、可靠的字节流服务，支持双工传输、流量控制
2. **适用场景**：
   - 可靠性要求高的传输应用（如HTTP/HTTPS、SMTP、FTP）
   - 大数据量传输应用（如文件传输、数据库同步）
   - 实时通信应用（如即时通讯、远程登录）
3. **常见应用层服务**：HTTP、FTP、SMTP、POP3、TELNET、数据库协议（MySQL、MongoDB）、直播流媒体协议（RTMP、HLS、FLV）

### （二）流式套接字编程模型（核心流程）
#### 1. 服务器端流程
1. 套接字初始化（WSAStartup()）
2. 创建流式套接字（socket()：AF_INET+SOCK_STREAM+0）
3. 绑定本地地址和端口（bind()）
4. 监听客户端连接（listen()）
5. 接收连接请求（accept()：创建新的连接套接字ns）
6. 数据收发（send()/recv()）
7. 关闭连接套接字（closesocket(ns)）
8. 关闭监听套接字（closesocket(s)）
9. 终止WinSock DLL（WSACleanup()）

#### 2. 客户端流程
1. 套接字初始化（WSAStartup()）
2. 创建流式套接字（socket()：AF_INET+SOCK_STREAM+0）
3. 指定服务器地址和端口
4. 发送连接请求（connect()）
5. 数据收发（send()/recv()）
6. 关闭套接字（closesocket(s)）
7. 终止WinSock DLL（WSACleanup()）

#### 3. 核心函数详解
| 函数 | 定义与参数 | 功能与返回值 | 关键说明 |
| --- | --- | --- | --- |
| socket() | SOCKET socket(int af, int type, int protocol) | 创建套接字，返回套接字句柄；错误返回INVALID_SOCKET | af=AF_INET（Internet域），type=SOCK_STREAM（流式），protocol=0（默认TCP） |
| closesocket() | int closesocket(SOCKET s) | 关闭套接字，释放资源；成功返回0，失败返回SOCKET_ERROR | 需成对关闭监听套接字和连接套接字 |
| bind() | int bind(SOCKET s, const struct sockaddr *name, int namelen) | 绑定本地地址到套接字；成功返回0，失败返回SOCKET_ERROR | 地址类型：常规地址（特定IP+端口）、通配地址（INADDR_ANY+0，内核自动分配IP/端口）；客户端一般不手动绑定（系统自动分配） |
| listen() | int listen(SOCKET s, int backlog) | 将套接字设为被动监听状态，指定请求队列最大长度；成功返回0，失败返回SOCKET_ERROR | backlog为未完成连接队列+已完成连接队列的最大值（BSD4.2最大为5） |
| accept() | SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen) | 接收连接请求，返回新的连接套接字；错误返回INVALID_SOCKET | 必须在listen()后调用，新套接字用于与当前客户端通信，原监听套接字继续接收其他请求 |
| connect() | int connect(SOCKET s, const struct sockaddr *name, int namelen) | 向服务器发送连接请求（完成TCP三次握手）；成功返回0，失败返回SOCKET_ERROR | 未绑定的套接字会由系统自动分配本地IP和端口；常见错误：ETIMEDOUT（连接超时）、ECONNREFUSED（端口未开放）、EHOSTUNREACH（主机不可达） |
| send() | int send(SOCKET s, const char *buf, int len, int flags) | 发送数据；成功返回发送字节数，失败返回SOCKET_ERROR | flags=MSG_DONTROUTE（不路由）、MSG_OOB（带外数据）；流式套接字无长度限制，发送成功≠数据到达（仅表示数据写入内核缓存） |
| recv() | int recv(SOCKET s, char *buf, int len, int flags) | 接收数据；成功返回接收字节数，失败返回SOCKET_ERROR | flags=MSG_OOB（处理带外数据）、MSG_PEEK（保留数据）；接收缓冲区不足时，流式套接字可通过循环调用接收完整数据 |

### （三）服务器工作原理与并发处理
1. **循环服务器**：同一时刻仅处理一个客户端请求，处理完后再接收下一个，适用于短期访问型客户端（如简单查询）
2. **并发服务器（多线程）**：接收连接请求后创建新线程，由线程处理该客户端的数据收发，主线程继续监听新请求，适用于长期访问型客户端（如文件传输、实时通信）
   - 核心逻辑：主线程（socket→bind→listen→accept→创建线程）→子线程（send/recv→closesocket(ns)）
   - 关键：线程中需保护共享资源，避免竞争；客户端断开后及时销毁线程，释放资源

### （四）TCP连接监控与心跳机制
1. **TCP的局限性**：TCP仅保证协议层可靠性（重传、流量控制），不保证应用层可靠性，存在两种失败模式：
   - 主机崩溃：对方主机突然宕机，无任何通知
   - 通信线路中断：网络断开且无数据传输时，双方无法察觉（TCP设计目标是维持通信能力，容错强但反应慢）
2. **心跳机制（解决方案）**：
   - 功能：判断连接有效性、维持连接存活性
   - 实现策略：
     - 复用连接+单向心跳：客户端定期发送心跳包，服务器未收到则断开连接
     - 复用连接+双向心跳：双方定期互发心跳包，未收到则重试后断开
     - 独立连接+双向心跳：单独建立心跳连接，不影响业务数据传输
   - 应用场景：手机应用在线状态维持、工控设备故障检测、分布式系统协作、游戏服务器资源释放

### （五）问题分析与解答
1. **问题1**：服务器如何处理多个客户端的请求？
   - 解答：根据客户端访问类型选择处理方式。短期访问型客户端采用循环服务器（简单高效）；长期访问型客户端采用并发服务器（多线程/多进程），或I/O复用模型（select/事件选择），避免线程膨胀导致的资源浪费。
2. **问题2**：流式套接字服务器的编写与客户端有哪些不同？
   - 解答：
     | 对比项 | 服务器端 | 客户端 |
     | --- | --- | --- |
     | 套接字数量 | 监听套接字（1个）+连接套接字（n个，并发时） | 仅1个通信套接字 |
     | 核心操作 | bind()→listen()→accept() | connect() |
     | 地址绑定 | 必须手动绑定本地地址和端口 | 一般由系统自动分配（无需手动bind） |
     | 连接发起 | 被动接收连接 | 主动发起连接 |
3. **问题3**：TCP提供了可靠的面向连接的传输服务，使用TCP的应用程序一定可靠吗？
   - 解答：不一定。TCP仅保证协议层的可靠性（如数据不丢失、不重复、按序到达），但无法处理应用层的异常（如主机崩溃、网络中断、应用程序宕机）。需通过应用层机制（如心跳包、超时重传、数据校验）补充，确保端到端的完整可靠性。

## 四、流式套接字编程（下）- TCP的流传输控制
### （一）TCP的字节流特性
1. **核心特点**：无边界、传送时机未知、写入/读出/传送形态各异
   - 无边界：TCP将数据视为连续字节流，不保留应用程序的消息边界（如客户端分两次发送"HELLO"和"WORLD"，服务器可能一次接收"HELLOWORLD"）
   - 传送时机：TCP根据网络状况（MTU、拥塞程度）、接收方缓存状态决定数据打包时机，与send()调用发送的数据量无直接关系
2. **关键现象**：
   - 发送方：send()成功仅表示数据写入内核缓存，不代表数据已发送或到达接收方
   - 接收方：recv()返回时机不可预测，可能接收全部数据、部分数据或无数据（需通过返回值判断）

### （二）TCP流传送过程剖析
1. **发送方视角**：应用程序→应用层缓存→send()→TCP套接字发送缓存→TCP协议（根据网络状况打包）→网络传输
2. **接收方视角**：网络传输→TCP套接字接收缓存→recv()→应用层缓存→应用程序
3. **核心结论**：
   - 发送方：TCP打包策略取决于网络MTU、接收方缓存、网络拥塞程度，与send()调用次数无关
   - 接收方：recv()返回值可能为0（连接关闭）、SOCK_ERROR（出错）、正数（接收字节数），需循环接收才能获取完整数据

### （三）流数据的正确接收方法
#### 1. 完整接收流数据（循环接收）
- 核心逻辑：通过循环调用recv()，直到接收完所有数据或连接关闭/出错
- 代码框架：
```c
do {
    char recvbuf[MSGSZ];
    memset(recvbuf, 0, MSGSZ);
    int iResult = recv(ConnectSocket, recvbuf, MSGSZ, 0);
    if (iResult > 0) {
        printf("Bytes received: %d\n", iResult);
        // 处理接收的数据
    } else if (iResult == 0) {
        printf("Connection closed\n");
        break;
    } else {
        printf("recv failed with error: %d\n", WSAGetLastError());
        break;
    }
} while (iResult > 0);
```

#### 2. 定长接收（界定数据长度）
- 适用场景：已知每次传输的数据长度固定（如固定大小的数据包）
- 核心逻辑：指定固定接收长度，循环调用recv()直到接收字节数达到固定长度
- 代码实现：
```c
int recvn(SOCKET s, char *recvbuf, unsigned int fixedlen) {
    int cnt = fixedlen; // 剩余未接收字节数
    while (cnt > 0) {
        int iResult = recv(s, recvbuf, cnt, 0);
        if (iResult < 0) {
            printf("接收发生错误: %d\n", WSAGetLastError());
            return -1;
        }
        if (iResult == 0) {
            printf("连接关闭\n");
            return fixedlen - cnt; // 返回已接收字节数
        }
        recvbuf += iResult; // 缓存指针后移
        cnt -= iResult; // 更新剩余字节数
    }
    return fixedlen; // 接收完整，返回固定长度
}
```

#### 3. 变长接收（长度字段+内容字段）
- 适用场景：数据长度不固定（如动态生成的消息、文件数据）
- 核心逻辑：先接收固定长度的“长度字段”（2字节/4字节），再根据长度字段接收对应长度的“内容字段”
- 代码实现：
```c
int recvvl(SOCKET s, char *recvbuf, unsigned int recvbuflen) {
    unsigned int reclen; // 存储消息长度
    // 接收长度字段（4字节）
    int iResult = recvn(s, (char *)&reclen, sizeof(unsigned int));
    if (iResult < 0) return -1;
    // 网络字节序转换为主机字节序
    reclen = ntohl(reclen);
    // 接收内容字段
    iResult = recvn(s, recvbuf, reclen);
    if (iResult < 0) return -1;
    return iResult;
}
```

#### 4. 边界标识接收（寻找结束符）
- 适用场景：文本数据传输（如HTTP协议），通过特定字符（如回车符\n、换行符\r）标识消息边界
- 核心逻辑：循环接收数据，直到检测到边界标识为止（如HTTP请求以"\r\n\r\n"结束）

### （四）自定义协议设计
1. **设计原则**：需考虑变长消息分界、消息内容格式、版本兼容、消息类型区分、错误校验、序列控制
2. **协议首部格式（示例）**：
   | 字段 | 长度 | 功能 |
   | --- | --- | --- |
   | 消息类型 | 2字节 | 区分指令（1）、心跳（2）、数据（3） |
   | 操作码 | 2字节 | 区分请求（0）、响应（1）、通知（2） |
   | 数据长度 | 4字节 | 后续内容字段的长度 |
   | 校验和 | 2字节 | 验证数据完整性 |
   | 内容字段 | 变长 | 业务数据（如指令参数、文件数据） |
3. **参考协议**：
   - MQTT协议（物联网）：固定报头+可变报头+有效载荷
   - Modbus TCP协议（工控）：长度+单元标识符+功能码+数据

### （五）问题分析与解答
1. **问题1**：放大缓冲区可以保证数据完整接收吗？
   - 解答：不能。流式套接字的接收完整性与缓冲区大小无必然关系，仅增大缓冲区可能导致部分数据残留或内存浪费。正确做法是根据数据类型选择接收方式：定长数据用定长接收，变长数据用“长度字段+内容字段”接收，文本数据用边界标识接收，同时通过循环recv()确保接收完整。
2. **问题2**：在TCP数据流上，如何准确操控数据边界？
   - 解答：核心是“找边界”或“定边界”。找边界：通过协议约定的边界标识（如HTTP的\r\n\r\n）；定边界：通过固定数据长度（定长接收）或长度字段（变长接收），将无边界的字节流转换为有明确边界的应用层消息。
3. **问题3**：如何正确分割流数据？
   - 解答：结合应用场景选择分割方式。单次请求-响应场景用边界标识或定长接收；多次请求-响应场景用变长接收（长度字段+内容字段），避免不同消息混淆；复杂场景可设计自定义协议，通过首部字段明确消息边界和类型。

## 五、数据报套接字编程
### （一）数据报套接字的核心概念与适用场景
1. **定义**：基于UDP协议的套接字（SOCK_DGRAM），提供无连接、不可靠的数据报服务，支持多对多通信、广播/多播
2. **UDP协议特点**：
   - 无连接：无需三次握手/四次挥手，直接发送数据
   - 不可靠：不保证数据到达、不保证按序到达、不重传
   - 高效：头部开销小（8字节），传输延迟低
3. **适用场景**：
   - 简单高效需求大于可靠需求的场景（如DNS查询、NTP时间同步）
   - 广播/多播场景（如局域网设备发现、视频直播）
   - 1对多通信场景（如游戏服务器、实时音视频会议）
4. **常见应用层服务**：DNS、DHCP、TFTP、SNMP、HTTP3、音视频会议协议（Zoom、WeLink）

### （二）数据报套接字编程模型（核心流程）
#### 1. 服务器端流程
1. 套接字初始化（WSAStartup()）
2. 创建数据报套接字（socket()：AF_INET+SOCK_DGRAM+0）
3. 绑定本地地址和端口（bind()）
4. 数据收发（recvfrom()/sendto()）
5. 关闭套接字（closesocket(s)）
6. 终止WinSock DLL（WSACleanup()）

#### 2. 客户端流程
1. 套接字初始化（WSAStartup()）
2. 创建数据报套接字（socket()：AF_INET+SOCK_DGRAM+0）
3. 指定服务器地址和端口
4. 数据收发（sendto()/recvfrom()）
5. 关闭套接字（closesocket(s)）
6. 终止WinSock DLL（WSACleanup()）

#### 3. 核心函数详解（与流式套接字对比）
| 函数 | 数据报套接字（UDP） | 流式套接字（TCP） |
| --- | --- | --- |
| socket() | type=SOCK_DGRAM，protocol=IPPROTO_UDP | type=SOCK_STREAM，protocol=IPPROTO_TCP |
| 发送数据 | sendto()：需指定目标地址（IP+端口），支持1对多发送 | send()：无需指定目标地址（已连接），仅1对1发送 |
| 接收数据 | recvfrom()：可获取数据来源地址，支持过滤特定来源 | recv()：不关心来源地址，接收流数据 |
| 连接管理 | 无connect()/listen()/accept()，可调用connect()绑定目标地址（简化send/recv调用） | 必须通过connect()/listen()/accept()建立连接 |
| 数据长度 | 发送数据长度≤底层协议MTU（默认1500字节），超出则截断 | 无长度限制，TCP自动分片 |

### （三）基于DNS的安全通信（代码框架）
1. **应用场景**：利用DNS协议隧道进行隐蔽通信（可监测网络环境下的数据传输）
2. **DNS协议特点**：基于UDP，端口53，广泛开放，不易被拦截
3. **客户端流程**：
   | 步骤 | 函数和相关操作 |
   | --- | --- |
   | 1 | 创建数据报套接字（socket(AF_INET, SOCK_DGRAM, 0)） |
   | 2 | 设置服务器IP（192.168.1.1）和端口（53） |
   | 3 | 发送指令请求（sendto()：伪造DNS A记录请求，如"2roAUSwVqwOWCaaDC.test.com"） |
   | 4 | 接收服务器响应（recvfrom()：解析DNS A记录响应，获取指令） |
   | 5 | 执行指令 |
   | 6 | 关闭套接字（closesocket(s)） |
4. **服务器流程**：
   | 步骤 | 函数和相关操作 |
   | --- | --- |
   | 1 | 创建数据报套接字（socket(AF_INET, SOCK_DGRAM, 0)） |
   | 2 | 绑定本地IP（192.168.1.1）和端口（53） |
   | 3 | 接收客户端请求（recvfrom()：解析DNS请求中的指令） |
   | 4 | 处理请求（执行指令或准备数据） |
   | 5 | 发送响应（sendto()：伪造DNS A记录响应，如"99.250.a.b"表示有文件待发送） |
   | 6 | 关闭套接字（closesocket(s)） |
5. **DNS响应格式约定**：
   - 99.250.a.b：服务端有待发送文件，文件名为a+b
   - a.b.c.d：服务端发送文件分片，abc为数据，d为索引
   - 1.2.3.0：文件分片发送完成

### （四）提高数据报的接收完整性
1. **丢包原因**：
   - 系统缓冲区不足：UDP接收缓冲区默认8KB，数据量过大时会丢包
   - 网络拥塞：UDP无流量控制，数据包超过网络承载能力会被丢弃
   - 应用程序处理不及时：数据到达后未及时接收，被新数据覆盖
2. **解决方案**：
   - 增大系统接收缓冲区：通过setsockopt()设置SO_RCVBUF选项（Windows最大8MB）
     ```c
     int recvbuf_len = 16 * 1024; // 16KB
     int len = sizeof(recvbuf_len);
     setsockopt(s, SOL_SOCKET, SO_RCVBUF, (const char *)&recvbuf_len, len);
     ```
   - 静态流量控制：通信双方协商缓冲区长度，发送方根据接收方缓冲区状态调整发送速率
   - 应用层重传机制：添加序号和确认机制，接收方未收到数据或序号不连续时请求重传
   - 数据分片：超过MTU的数据包手动分片，接收方重组

### （五）问题分析与解答
1. **问题1**：与流式套接字相比，数据报套接字的操作有何区别？
   - 解答：
     | 对比项 | 数据报套接字（UDP） | 流式套接字（TCP） |
     | --- | --- | --- |
     | 连接管理 | 无连接，无需建立/关闭连接 | 面向连接，需三次握手/四次挥手 |
     | 套接字创建 | type=SOCK_DGRAM | type=SOCK_STREAM |
     | 数据传输 | 发送需指定目标地址，接收可获取来源地址 | 发送无需指定地址（已连接），接收不关心来源 |
     | 数据完整性 | 以数据报为单位，接收完整或丢失，不可分割 | 字节流，需循环接收保证完整 |
     | 可靠性 | 不可靠（无重传、无流量控制） | 可靠（重传、流量控制、按序到达） |
     | 适用场景 | 短消息、广播/多播、实时通信 | 大数据量、高可靠性需求场景 |
2. **问题2**：一定能完整接收到指令数据吗？
   - 解答：不能。UDP是不可靠协议，存在丢包风险（测试表明，默认缓冲区下丢包率可达80%以上）。需通过组合策略保证接收完整性：增大系统缓冲区、应用层重传、数据分片与重组、流量控制，同时在代码中处理接收失败的情况（如超时重传请求）。
3. **问题3**：服务器如何处理多个客户端的请求？
   - 解答：数据报套接字服务器无需创建新套接字，通过recvfrom()获取每个客户端的地址，处理后用sendto()向对应地址发送响应。由于UDP无连接，服务器可同时接收多个客户端的请求，按接收顺序处理或采用并发处理（如多线程），适用于高并发短请求场景（如DNS服务器）。

## 六、I/O复用模型
### （一）核心问题：1对多通信的及时处理
1. **传统方案的局限性**：
   - 逐个循环处理：效率低下，某个套接字阻塞时会影响其他客户端
   - 多线程处理：线程维护复杂，资源消耗大，线程切换开销高
2. **I/O复用模型的核心思想**：单线程同时监控多个套接字的I/O状态，当某个套接字准备就绪（可读/可写/有异常）时，再进行相应的I/O操作，避免阻塞导致的效率问题

### （二）网络通信I/O操作中的等待
1. **等待场景**：
   - 输入操作（recv()/recvfrom()）：等待网络数据到达内核缓存
   - 输出操作（send()/sendto()）：等待套接字缓存有空闲空间
   - 连接请求（accept()）：等待客户端连接请求
   - 连接响应（connect()）：等待服务器连接响应
2. **阻塞I/O模型**：
   - 流程：应用程序调用I/O函数→内核等待数据准备→数据拷贝到用户缓存→函数返回
   - 优点：简单直接，适用于单个套接字
   - 缺点：多个套接字时会阻塞，影响整体处理效率
3. **非阻塞I/O模型**：
   - 流程：应用程序调用I/O函数→无数据则立即返回错误→循环调用直到数据准备就绪
   - 优点：可处理多个套接字
   - 缺点：多次系统调用消耗资源，处理时机滞后

### （三）四种I/O复用模型详解
#### 1. select模型
1. **核心原理**：将需要监控的套接字放入读/写/异常集合（fd_set），调用select()函数阻塞等待，直到某个集合中的套接字准备就绪，函数返回就绪套接字数量
2. **关键函数与宏**：
   - FD_ZERO(&set)：初始化套接字集合
   - FD_SET(s, &set)：将套接字s加入集合
   - FD_CLR(s, &set)：将套接字s从集合中移除
   - FD_ISSET(s, &set)：判断套接字s是否在就绪集合中
   - select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)：监控套接字集合，返回就绪数量
3. **编程框架（服务器）**：
   ```c
   fd_set fdR;
   struct timeval timeout = {3, 0}; // 超时3秒
   SOCKET s = socket(AF_INET, SOCK_STREAM, 0);
   bind(s, (struct sockaddr *)&addr, sizeof(addr));
   listen(s, 5);
   FD_ZERO(&fdR);
   FD_SET(s, &fdR);
   while (1) {
       fd_set tmp = fdR; // 每次重新初始化（select会修改集合）
       int ret = select(0, &tmp, NULL, NULL, &timeout);
       if (ret < 0) break;
       if (FD_ISSET(s, &tmp)) { // 监听套接字就绪（有新连接）
           SOCKET ns = accept(s, NULL, NULL);
           FD_SET(ns, &fdR); // 将新连接加入集合
       }
       // 遍历连接套接字，处理就绪的I/O
       for (auto ns : conn_sockets) {
           if (FD_ISSET(ns, &tmp)) {
               char buf[1024];
               int len = recv(ns, buf, sizeof(buf), 0);
               if (len <= 0) { // 连接关闭或出错
                   closesocket(ns);
                   FD_CLR(ns, &fdR);
               } else {
                   send(ns, buf, len, 0); // 回射数据
               }
           }
       }
   }
   ```
4. **优缺点**：
   - 优点：跨平台兼容性好（Windows/Linux），实现简单
   - 缺点：效率低（遍历所有套接字），套接字数量限制（FD_SETSIZE=64），不公平（按顺序处理，后就绪的套接字可能被延迟）

#### 2. 事件选择模型（WSAEventSelect）
1. **核心原理**：将套接字与事件对象关联，通过WSAEventSelect()注册需要监控的网络事件（如FD_READ、FD_WRITE），调用WSAWaitForMultipleEvents()等待事件触发，再通过WSAEnumNetworkEvents()获取就绪事件
2. **关键函数**：
   - WSACreateEvent()：创建事件对象
   - WSAEventSelect(s, hEvent, event_mask)：关联套接字与事件，指定监控事件（FD_READ/FD_WRITE/FD_ACCEPT等）
   - WSAWaitForMultipleEvents(nEvents, phEvents, fWaitAll, dwTimeout, fAlertable)：等待事件触发，返回就绪事件索引
   - WSAEnumNetworkEvents(s, hEvent, &networkEvents)：获取就绪事件详情
   - WSACloseEvent(hEvent)：关闭事件对象
3. **核心事件类型**：
   - FD_READ：内核接收缓存有数据
   - FD_WRITE：内核发送缓存有空闲
   - FD_ACCEPT：有新连接请求
   - FD_CONNECT：连接建立成功
   - FD_CLOSE：连接关闭
4. **优缺点**：
   - 优点：无套接字数量限制，效率高于select（事件触发而非遍历）
   - 缺点：仅支持Windows系统，事件对象管理复杂

#### 3. 重叠I/O模型
1. **核心原理**：基于Windows重叠I/O机制，应用程序通过WSAOVERLAPPED结构体投递I/O请求（WSASend/WSARecv），请求立即返回，内核后台处理I/O操作，完成后通过事件对象或完成例程通知应用程序
2. **关键组件**：
   - WSAOVERLAPPED结构体：关联事件对象和I/O操作状态
   - 扩展套接字函数：WSASocket（创建重叠I/O套接字）、WSASend、WSARecv、AcceptEx
3. **编程框架**：
   ```c
   // 创建重叠I/O套接字
   SOCKET s = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
   bind(s, (struct sockaddr *)&addr, sizeof(addr));
   listen(s, 5);
   // 创建事件对象和重叠结构
   WSAEVENT hEvent = WSACreateEvent();
   WSAOVERLAPPED overlapped;
   ZeroMemory(&overlapped, sizeof(overlapped));
   overlapped.hEvent = hEvent;
   // 异步接收数据
   WSABUF wsaBuf;
   char buf[1024];
   wsaBuf.buf = buf;
   wsaBuf.len = sizeof(buf);
   DWORD bytesRecv = 0, flags = 0;
   WSARecv(s, &wsaBuf, 1, &bytesRecv, &flags, &overlapped, NULL);
   // 等待事件触发
   WSAWaitForMultipleEvents(1, &hEvent, FALSE, WSA_INFINITE, FALSE);
   // 获取I/O操作结果
   WSAGetOverlappedResult(s, &overlapped, &bytesRecv, FALSE, &flags);
   // 处理数据
   ```
4. **优缺点**：
   - 优点：异步I/O，效率高，支持大量套接字
   - 缺点：仅支持Windows系统，编程复杂，需管理重叠结构和事件对象

#### 4. 完成端口模型（IOCP）
1. **核心原理**：Windows最高效的I/O复用模型，基于线程池处理异步I/O请求。应用程序创建完成端口，将套接字与完成端口绑定，投递I/O请求（WSASend/WSARecv），内核完成I/O后将结果放入完成端口队列，线程池中的线程从队列获取结果并处理
2. **关键函数**：
   - CreateIoCompletionPort()：创建完成端口，或绑定套接字与完成端口
   - PostQueuedCompletionStatus()：向完成端口队列投递自定义消息
   - GetQueuedCompletionStatus()：从队列获取I/O完成通知
3. **核心优势**：
   - 线程复用：线程池大小与CPU核数匹配（避免线程切换开销）
   - 高效：内核级通知，无轮询，支持海量套接字
   - 可扩展性强：适用于高并发服务器（如Web服务器、游戏服务器）
4. **适用场景**：Windows平台下的高并发网络应用（支持10万+并发连接）

### （四）问题分析与解答
1. **问题**：APT控制服务器如何及时处理与多个受控主机的远程通信？
   - 解答：选择合适的I/O复用模型。若需跨平台，采用select模型（简单场景）；若为Windows平台且并发量中等，采用事件选择模型；若为Windows平台且高并发（1万+连接），采用完成端口模型。核心逻辑：
     - 监控两类套接字：TCP监听套接字（处理新连接）、TCP连接套接字（处理数据收发）
     - 新连接到达时，将连接套接字加入监控集合/绑定到完成端口
     - 数据就绪时，触发I/O操作，处理后向受控主机发送响应
     - 支持优先级处理：在事件选择模型或完成端口模型中，为不同价值的受控主机（如政府机构、普通用户）分配不同优先级的事件或线程，优先处理高价值目标的请求

## 七、原始套接字编程
### （一）原始套接字的核心概念与适用场景
1. **定义**：直接访问底层协议（IP/ICMP/TCP/UDP）的套接字（SOCK_RAW），允许应用程序构造自定义数据包，接收内核不处理的协议数据包
2. **与标准套接字的区别**：
   | 对比项 | 标准套接字（流式/数据报） | 原始套接字 |
   | --- | --- | --- |
   | 可操控数据 | 仅数据内容 | IP首部+TCP/UDP/ICMP首部+数据内容 |
   | 套接字创建 | type=SOCK_STREAM/SOCK_DGRAM，无需指定协议 | type=SOCK_RAW，需明确指定协议（IPPROTO_TCP/IPPROTO_UDP/IPPROTO_ICMP） |
   | 权限要求 | 普通用户 | 管理员权限（Windows/Linux） |
   | 端点地址 | IP+端口号 | 仅IP地址（端口号可选） |
   | 适用场景 | 常规数据传输 | 网络探测、数据包捕获、网络攻防、自定义协议 |
3. **适用场景**：
   - 发送：灵活定制的探测应用（如端口扫描、漏洞检测）
   - 接收：基于数据包捕获的应用（如网络监控、流量分析）
   - 收发：特殊传输应用（如自定义协议、网络攻防）

### （二）原始套接字编程模型（核心流程）
1. 创建原始套接字（管理员权限）：
   ```c
   SOCKET rawSock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP); // TCP原始套接字
   ```
2. 构造自定义数据包（IP首部+协议首部+数据）
3. 发送数据包（sendto()）
4. 接收数据包（recvfrom()）
5. 解析数据包
6. 关闭套接字（closesocket(rawSock)）

### （三）使用原始套接字发送数据
1. **数据包构造**：
   - 核心：手动填充IP首部、TCP/UDP/ICMP首部，确保格式正确（字节顺序、校验和、字段长度）
   - TCP首部结构体示例：
     ```c
     struct TCPHDR {
         uint16_t sport; // 源端口（网络字节序）
         uint16_t dport; // 目的端口（网络字节序）
         uint32_t seq; // 序列号（网络字节序）
         uint32_t ack; // 确认号（网络字节序）
         uint16_t win; // 窗口大小（网络字节序）
         uint16_t flags; // 标志位（SYN=0x002，ACK=0x010，SYN+ACK=0x012）
         uint16_t sum; // 校验和（网络字节序）
         uint16_t urp; // 紧急指针（网络字节序）
     };
     ```
   - IP首部构造（可选，通过IP_HDRINCL选项操控）：
     ```c
     int optval = 1;
     setsockopt(rawSock, IPPROTO_IP, IP_HDRINCL, (char *)&optval, sizeof(optval));
     ```
2. **关键注意事项**：
   - 字节顺序：主机字节序（小端）→网络字节序（大端），使用htons()（16位）、htonl()（32位）转换
   - 校验和计算：TCP/UDP校验和需包含伪首部（源IP、目的IP、协议号、数据长度），步骤：
     1. 将校验和字段置0
     2. 以16位为单位对数据求和（包括伪首部）
     3. 二进制反码求和
     4. 将结果填入校验和字段
   - 缓冲区长度：满足MTU限制（默认1500字节），避免数据包过大被分片或过小不满足以太网最小帧长度（46字节）
   - 结构体初始化：用memset()清零，避免垃圾数据导致数据包无效

3. **发送示例（TCP SYN扫描）**：
   ```c
   // 构造TCP SYN包
   char sendbuf[40];
   memset(sendbuf, 0, sizeof(sendbuf));
   struct TCPHDR *tcphdr = (struct TCPHDR *)sendbuf;
   tcphdr->sport = htons(64433); // 源端口（随机大端口）
   tcphdr->dport = htons(443); // 目的端口（HTTPS）
   tcphdr->seq = htonl(0); // 序列号
   tcphdr->ack = htonl(0); // 确认号
   tcphdr->win = htons(8192); // 窗口大小
   tcphdr->flags = htons(0x002); // SYN标志位
   tcphdr->sum = 0; // 校验和置0
   // 计算校验和（需构造TCP伪首部）
   tcphdr->sum = CheckSum((USHORT *)sendbuf, sizeof(sendbuf));
   // 发送数据包
   struct sockaddr_in destAddr;
   destAddr.sin_family = AF_INET;
   destAddr.sin_addr.s_addr = inet_addr("202.196.23.1");
   destAddr.sin_port = htons(443);
   sendto(rawSock, sendbuf, sizeof(sendbuf), 0, (struct sockaddr *)&destAddr, sizeof(destAddr));
   ```

### （四）使用原始套接字接收数据
1. **接收流程**：
   - 网卡工作模式：需设置为混杂模式（接收所有流过网卡的帧），通过nPcap或Wireshark实现（原始套接字无法直接设置网卡模式）
   - 套接字选项：设置SIO_RCVALL选项，接收所有IP数据包
     ```c
     DWORD optval = 1;
     WSAIoctl(rawSock, SIO_RCVALL, &optval, sizeof(optval), NULL, 0, NULL, NULL, NULL);
     ```
   - 数据筛选：接收后解析IP首部和协议首部，根据源IP、目的IP、端口号、协议类型筛选目标数据包
     ```c
     char recvbuf[1500];
     struct sockaddr_in srcAddr;
     int srcLen = sizeof(srcAddr);
     int len = recvfrom(rawSock, recvbuf, sizeof(recvbuf), 0, (struct sockaddr *)&srcAddr, &srcLen);
     if (len > 0) {
         struct IPHDR *iphdr = (struct IPHDR *)recvbuf;
         if (iphdr->protocol == IPPROTO_TCP) { // 筛选TCP数据包
             struct TCPHDR *tcphdr = (struct TCPHDR *)(recvbuf + sizeof(struct IPHDR));
             if (ntohs(tcphdr->dport) == 64433 && (tcphdr->flags & htons(0x012))) {
                 // 接收SYN+ACK响应，端口开放
             }
         }
     }
     ```
2. **关键注意事项**：
   - 数据分层：接收的数据包包含以太网帧头+IP首部+协议首部+数据，需按层级解析
   - 协议筛选：内核仅将未处理的数据包（如ICMP、IGMP、自定义协议）传递给原始套接字，TCP/UDP数据包需通过SIO_RCVALL选项接收
   - 性能优化：大量数据包时需采用多线程或I/O复用，避免接收缓冲区溢出

### （五）原始套接字在网络攻防中的应用
1. **SYN Flood攻击**：发送大量TCP SYN包，耗尽服务器连接资源（半连接队列满），导致正常连接无法建立
2. **Teardrop攻击**：伪造IP分片数据包，使目标主机重组时内存溢出，导致系统蓝屏
3. **反射放大攻击**：伪造目标IP地址，向开放特定端口的服务器发送请求，服务器响应数据包放大后发送给目标主机，造成带宽耗尽
4. **网络探测**：TCP SYN扫描（探测开放端口）、ICMP ping扫描（探测存活主机）、TTL traceroute（路由跟踪）

### （六）问题分析与解答
1. **问题1**：如何在全世界IP地址范围内，获知开放TCP协议承载的443、993、465和995号端口的服务器？
   - 解答：采用原始套接字实现TCP SYN扫描，步骤如下：
     1. 遍历IP地址范围（1.1.1.1~255.255.255.255，排除特殊地址）
     2. 对每个IP的目标端口（443/993/465/995）构造TCP SYN包，发送给目标主机
     3. 监听网络，接收目标主机的响应：
        - 收到SYN+ACK包：端口开放
        - 收到RST包：端口关闭
        - 无响应：主机不可达或端口过滤
     4. 优化策略：并发发送（提高扫描速度）、分布式扫描（全球节点协同，缩短时间）、设置超时重传（处理网络延迟）
2. **问题2**：为什么TCP首部字段的取值出现了错误？
   - 解答：核心原因是字节顺序转换错误。X86架构主机采用小端字节序，而网络协议采用大端字节序，未进行转换会导致字段值错误（如端口号64433→0xFA21，小端存储为21 FA，网络传输后解析为0x21FA=8698，与预期不符）。解决方案：所有协议字段（端口号、序列号、校验和等）均需通过htons()/htonl()转换为网络字节序，接收时通过ntohs()/ntohl()转换为主机字节序。
3. **问题3**：为什么接收不到服务器发回的连接确认响应？
   - 解答：可能的原因及解决方案：
     - 网卡工作模式未设置为混杂模式：通过nPcap或Wireshark设置，确保接收所有流过网卡的数据包
     - 套接字未开启SIO_RCVALL选项：调用WSAIoctl()设置该选项，接收所有IP数据包
     - 数据包筛选逻辑错误：检查IP首部和TCP首部的解析代码，确保正确筛选目标响应（如源IP、目的端口、SYN+ACK标志位）
     - 网络防火墙拦截：关闭本地防火墙或配置规则，允许接收ICMP/TCP响应包

## 八、复习与考试提示
### （一）复习重点
1. 核心模型：C/S、B/S、P2P模型的特点与适用场景
2. 套接字编程：流式（TCP）、数据报（UDP）、原始套接字的编程流程、核心函数、差异对比
3. 关键技术：TCP流控制（定长/变长接收）、心跳机制、I/O复用模型（select/事件选择/完成端口）、原始套接字数据包构造与解析
4. 问题解决：网络程序设计的基础问题、TCP/UDP的局限性及解决方案、高并发处理策略

### （二）考试题型预测
1. 选择题：网络程序分类、套接字类型、协议适用场景、函数功能
2. 填空题：IP地址分类、套接字核心函数、I/O复用模型关键步骤
3. 简答题：C/S与B/S模型区别、TCP与UDP差异、心跳机制实现、校验和计算步骤
4. 编程题：流式/数据报套接字简单程序（如回射程序）、I/O复用模型服务器框架、原始套接字数据包构造
5. 分析题：网络程序故障排查（如丢包、连接失败）、协议数据包解析

### （三）答题注意事项
1. 编程题：严格按题目要求选择套接字类型和协议，避免冗余代码，确保功能正确（如数据收发完整、连接正常关闭）
2. 分析题：结合协议特性和编程模型，逐步排查问题，给出具体解决方案（如丢包问题从缓冲区、流量控制、重传机制入手）
3. 简答题：突出核心区别和关键步骤，避免冗长，确保逻辑清晰（如TCP三次握手步骤、select模型工作流程）